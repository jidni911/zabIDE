

!function(t, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).mdb = e()
}(this, function() {
    "use strict";
    var t, e = Object.defineProperty, i = (t, i, n) => (( (t, i, n) => {
        i in t ? e(t, i, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n
        }) : t[i] = n
    }
    )(t, "symbol" != typeof i ? i + "" : i, n),
    n);
    globalThis,
    t = function() {
        return function(t) {
            function e(n) {
                if (i[n])
                    return i[n].exports;
                var s = i[n] = {
                    i: n,
                    l: !1,
                    exports: {}
                };
                return t[n].call(s.exports, s, s.exports, e),
                s.l = !0,
                s.exports
            }
            var i = {};
            return e.m = t,
            e.c = i,
            e.i = function(t) {
                return t
            }
            ,
            e.d = function(t, i, n) {
                e.o(t, i) || Object.defineProperty(t, i, {
                    configurable: !1,
                    enumerable: !0,
                    get: n
                })
            }
            ,
            e.n = function(t) {
                var i = t && t.__esModule ? function() {
                    return t.default
                }
                : function() {
                    return t
                }
                ;
                return e.d(i, "a", i),
                i
            }
            ,
            e.o = function(t, e) {
                return Object.prototype.hasOwnProperty.call(t, e)
            }
            ,
            e.p = "",
            e(e.s = 3)
        }([function(t, e, i) {
            var n, s, o;
            s = [t, i(7)],
            n = function(t, e) {
                function i(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }
                var n, s = (n = e) && n.__esModule ? n : {
                    default: n
                }, o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t
                }
                : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                }
                , a = function() {
                    function t(t, e) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1,
                            n.configurable = !0,
                            "value"in n && (n.writable = !0),
                            Object.defineProperty(t, n.key, n)
                        }
                    }
                    return function(e, i, n) {
                        return i && t(e.prototype, i),
                        n && t(e, n),
                        e
                    }
                }(), r = function() {
                    function t(e) {
                        i(this, t),
                        this.resolveOptions(e),
                        this.initSelection()
                    }
                    return a(t, [{
                        key: "resolveOptions",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            this.action = t.action,
                            this.container = t.container,
                            this.emitter = t.emitter,
                            this.target = t.target,
                            this.text = t.text,
                            this.trigger = t.trigger,
                            this.selectedText = ""
                        }
                    }, {
                        key: "initSelection",
                        value: function() {
                            this.text ? this.selectFake() : this.target && this.selectTarget()
                        }
                    }, {
                        key: "selectFake",
                        value: function() {
                            var t = this
                              , e = "rtl" == document.documentElement.getAttribute("dir");
                            this.removeFake(),
                            this.fakeHandlerCallback = function() {
                                return t.removeFake()
                            }
                            ,
                            this.fakeHandler = this.container.addEventListener("click", this.fakeHandlerCallback) || !0,
                            this.fakeElem = document.createElement("textarea"),
                            this.fakeElem.style.fontSize = "12pt",
                            this.fakeElem.style.border = "0",
                            this.fakeElem.style.padding = "0",
                            this.fakeElem.style.margin = "0",
                            this.fakeElem.style.position = "absolute",
                            this.fakeElem.style[e ? "right" : "left"] = "-9999px";
                            var i = window.pageYOffset || document.documentElement.scrollTop;
                            this.fakeElem.style.top = i + "px",
                            this.fakeElem.setAttribute("readonly", ""),
                            this.fakeElem.value = this.text,
                            this.container.appendChild(this.fakeElem),
                            this.selectedText = (0,
                            s.default)(this.fakeElem),
                            this.copyText()
                        }
                    }, {
                        key: "removeFake",
                        value: function() {
                            this.fakeHandler && (this.container.removeEventListener("click", this.fakeHandlerCallback),
                            this.fakeHandler = null,
                            this.fakeHandlerCallback = null),
                            this.fakeElem && (this.container.removeChild(this.fakeElem),
                            this.fakeElem = null)
                        }
                    }, {
                        key: "selectTarget",
                        value: function() {
                            this.selectedText = (0,
                            s.default)(this.target),
                            this.copyText()
                        }
                    }, {
                        key: "copyText",
                        value: function() {
                            var t = void 0;
                            try {
                                t = document.execCommand(this.action)
                            } catch (e) {
                                t = !1
                            }
                            this.handleResult(t)
                        }
                    }, {
                        key: "handleResult",
                        value: function(t) {
                            this.emitter.emit(t ? "success" : "error", {
                                action: this.action,
                                text: this.selectedText,
                                trigger: this.trigger,
                                clearSelection: this.clearSelection.bind(this)
                            })
                        }
                    }, {
                        key: "clearSelection",
                        value: function() {
                            this.trigger && this.trigger.focus(),
                            window.getSelection().removeAllRanges()
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.removeFake()
                        }
                    }, {
                        key: "action",
                        set: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "copy";
                            if (this._action = t,
                            "copy" !== this._action && "cut" !== this._action)
                                throw new Error('Invalid "action" value, use either "copy" or "cut"')
                        },
                        get: function() {
                            return this._action
                        }
                    }, {
                        key: "target",
                        set: function(t) {
                            if (void 0 !== t) {
                                if (!t || "object" !== (void 0 === t ? "undefined" : o(t)) || 1 !== t.nodeType)
                                    throw new Error('Invalid "target" value, use a valid Element');
                                if ("copy" === this.action && t.hasAttribute("disabled"))
                                    throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                                if ("cut" === this.action && (t.hasAttribute("readonly") || t.hasAttribute("disabled")))
                                    throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
                                this._target = t
                            }
                        },
                        get: function() {
                            return this._target
                        }
                    }]),
                    t
                }();
                t.exports = r
            }
            ,
            void 0 !== (o = "function" == typeof n ? n.apply(e, s) : n) && (t.exports = o)
        }
        , function(t, e, i) {
            var n = i(6)
              , s = i(5);
            t.exports = function(t, e, i) {
                if (!t && !e && !i)
                    throw new Error("Missing required arguments");
                if (!n.string(e))
                    throw new TypeError("Second argument must be a String");
                if (!n.fn(i))
                    throw new TypeError("Third argument must be a Function");
                if (n.node(t))
                    return function(t, e, i) {
                        return t.addEventListener(e, i),
                        {
                            destroy: function() {
                                t.removeEventListener(e, i)
                            }
                        }
                    }(t, e, i);
                if (n.nodeList(t))
                    return function(t, e, i) {
                        return Array.prototype.forEach.call(t, function(t) {
                            t.addEventListener(e, i)
                        }),
                        {
                            destroy: function() {
                                Array.prototype.forEach.call(t, function(t) {
                                    t.removeEventListener(e, i)
                                })
                            }
                        }
                    }(t, e, i);
                if (n.string(t))
                    return function(t, e, i) {
                        return s(document.body, t, e, i)
                    }(t, e, i);
                throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList")
            }
        }
        , function(t, e) {
            function i() {}
            i.prototype = {
                on: function(t, e, i) {
                    var n = this.e || (this.e = {});
                    return (n[t] || (n[t] = [])).push({
                        fn: e,
                        ctx: i
                    }),
                    this
                },
                once: function(t, e, i) {
                    function n() {
                        s.off(t, n),
                        e.apply(i, arguments)
                    }
                    var s = this;
                    return n._ = e,
                    this.on(t, n, i)
                },
                emit: function(t) {
                    for (var e = [].slice.call(arguments, 1), i = ((this.e || (this.e = {}))[t] || []).slice(), n = 0, s = i.length; n < s; n++)
                        i[n].fn.apply(i[n].ctx, e);
                    return this
                },
                off: function(t, e) {
                    var i = this.e || (this.e = {})
                      , n = i[t]
                      , s = [];
                    if (n && e)
                        for (var o = 0, a = n.length; o < a; o++)
                            n[o].fn !== e && n[o].fn._ !== e && s.push(n[o]);
                    return s.length ? i[t] = s : delete i[t],
                    this
                }
            },
            t.exports = i
        }
        , function(t, e, i) {
            var n, s, o;
            s = [t, i(0), i(2), i(1)],
            n = function(t, e, i, n) {
                function s(t) {
                    return t && t.__esModule ? t : {
                        default: t
                    }
                }
                function o(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }
                function a(t, e) {
                    if (!t)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !e || "object" != typeof e && "function" != typeof e ? t : e
                }
                function r(t, e) {
                    if ("function" != typeof e && null !== e)
                        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                }
                function l(t, e) {
                    var i = "data-clipboard-" + t;
                    if (e.hasAttribute(i))
                        return e.getAttribute(i)
                }
                var h = s(e)
                  , c = s(i)
                  , d = s(n)
                  , u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t
                }
                : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                }
                  , p = function() {
                    function t(t, e) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1,
                            n.configurable = !0,
                            "value"in n && (n.writable = !0),
                            Object.defineProperty(t, n.key, n)
                        }
                    }
                    return function(e, i, n) {
                        return i && t(e.prototype, i),
                        n && t(e, n),
                        e
                    }
                }()
                  , f = function(t) {
                    function e(t, i) {
                        o(this, e);
                        var n = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
                        return n.resolveOptions(i),
                        n.listenClick(t),
                        n
                    }
                    return r(e, t),
                    p(e, [{
                        key: "resolveOptions",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            this.action = "function" == typeof t.action ? t.action : this.defaultAction,
                            this.target = "function" == typeof t.target ? t.target : this.defaultTarget,
                            this.text = "function" == typeof t.text ? t.text : this.defaultText,
                            this.container = "object" === u(t.container) ? t.container : document.body
                        }
                    }, {
                        key: "listenClick",
                        value: function(t) {
                            var e = this;
                            this.listener = (0,
                            d.default)(t, "click", function(t) {
                                return e.onClick(t)
                            })
                        }
                    }, {
                        key: "onClick",
                        value: function(t) {
                            var e = t.delegateTarget || t.currentTarget;
                            this.clipboardAction && (this.clipboardAction = null),
                            this.clipboardAction = new h.default({
                                action: this.action(e),
                                target: this.target(e),
                                text: this.text(e),
                                container: this.container,
                                trigger: e,
                                emitter: this
                            })
                        }
                    }, {
                        key: "defaultAction",
                        value: function(t) {
                            return l("action", t)
                        }
                    }, {
                        key: "defaultTarget",
                        value: function(t) {
                            var e = l("target", t);
                            if (e)
                                return document.querySelector(e)
                        }
                    }, {
                        key: "defaultText",
                        value: function(t) {
                            return l("text", t)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.listener.destroy(),
                            this.clipboardAction && (this.clipboardAction.destroy(),
                            this.clipboardAction = null)
                        }
                    }], [{
                        key: "isSupported",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ["copy", "cut"]
                              , e = "string" == typeof t ? [t] : t
                              , i = !!document.queryCommandSupported;
                            return e.forEach(function(t) {
                                i = i && !!document.queryCommandSupported(t)
                            }),
                            i
                        }
                    }]),
                    e
                }(c.default);
                t.exports = f
            }
            ,
            void 0 !== (o = "function" == typeof n ? n.apply(e, s) : n) && (t.exports = o)
        }
        , function(t, e) {
            var i = 9;
            if ("undefined" != typeof Element && !Element.prototype.matches) {
                var n = Element.prototype;
                n.matches = n.matchesSelector || n.mozMatchesSelector || n.msMatchesSelector || n.oMatchesSelector || n.webkitMatchesSelector
            }
            t.exports = function(t, e) {
                for (; t && t.nodeType !== i; ) {
                    if ("function" == typeof t.matches && t.matches(e))
                        return t;
                    t = t.parentNode
                }
            }
        }
        , function(t, e, i) {
            function n(t, e, i, n, o) {
                var a = s.apply(this, arguments);
                return t.addEventListener(i, a, o),
                {
                    destroy: function() {
                        t.removeEventListener(i, a, o)
                    }
                }
            }
            function s(t, e, i, n) {
                return function(i) {
                    i.delegateTarget = o(i.target, e),
                    i.delegateTarget && n.call(t, i)
                }
            }
            var o = i(4);
            t.exports = function(t, e, i, s, o) {
                return "function" == typeof t.addEventListener ? n.apply(null, arguments) : "function" == typeof i ? n.bind(null, document).apply(null, arguments) : ("string" == typeof t && (t = document.querySelectorAll(t)),
                Array.prototype.map.call(t, function(t) {
                    return n(t, e, i, s, o)
                }))
            }
        }
        , function(t, e) {
            e.node = function(t) {
                return void 0 !== t && t instanceof HTMLElement && 1 === t.nodeType
            }
            ,
            e.nodeList = function(t) {
                var i = Object.prototype.toString.call(t);
                return void 0 !== t && ("[object NodeList]" === i || "[object HTMLCollection]" === i) && "length"in t && (0 === t.length || e.node(t[0]))
            }
            ,
            e.string = function(t) {
                return "string" == typeof t || t instanceof String
            }
            ,
            e.fn = function(t) {
                return "[object Function]" === Object.prototype.toString.call(t)
            }
        }
        , function(t, e) {
            t.exports = function(t) {
                var e;
                if ("SELECT" === t.nodeName)
                    t.focus(),
                    e = t.value;
                else if ("INPUT" === t.nodeName || "TEXTAREA" === t.nodeName) {
                    var i = t.hasAttribute("readonly");
                    i || t.setAttribute("readonly", ""),
                    t.select(),
                    t.setSelectionRange(0, t.value.length),
                    i || t.removeAttribute("readonly"),
                    e = t.value
                } else {
                    t.hasAttribute("contenteditable") && t.focus();
                    var n = window.getSelection()
                      , s = document.createRange();
                    s.selectNodeContents(t),
                    n.removeAllRanges(),
                    n.addRange(s),
                    e = n.toString()
                }
                return e
            }
        }
        ])
    }
    ,
    "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.ClipboardJS = t() : window.ClipboardJS = t(),
    function(t) {
        var e = {};
        function i(n) {
            var s;
            return (e[n] || (s = e[n] = {
                i: n,
                l: !1,
                exports: {}
            },
            t[n].call(s.exports, s, s.exports, i),
            s.l = !0,
            s)).exports
        }
        i.m = t,
        i.c = e,
        i.d = function(t, e, n) {
            i.o(t, e) || Object.defineProperty(t, e, {
                enumerable: !0,
                get: n
            })
        }
        ,
        i.r = function(t) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                value: "Module"
            }),
            Object.defineProperty(t, "__esModule", {
                value: !0
            })
        }
        ,
        i.t = function(t, e) {
            if (1 & e && (t = i(t)),
            8 & e)
                return t;
            if (4 & e && "object" == typeof t && t && t.__esModule)
                return t;
            var n = Object.create(null);
            if (i.r(n),
            Object.defineProperty(n, "default", {
                enumerable: !0,
                value: t
            }),
            2 & e && "string" != typeof t)
                for (var s in t)
                    i.d(n, s, function(e) {
                        return t[e]
                    }
                    .bind(null, s));
            return n
        }
        ,
        i.n = function(t) {
            var e = t && t.__esModule ? function() {
                return t.default
            }
            : function() {
                return t
            }
            ;
            return i.d(e, "a", e),
            e
        }
        ,
        i.o = function(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e)
        }
        ,
        i.p = "",
        i(i.s = 68)
    }([function(t, e) {
        t.exports = function(t) {
            try {
                return !!t()
            } catch (e) {
                return !0
            }
        }
    }
    , function(t, e, i) {
        i = i(21);
        var n = (s = Function.prototype).call
          , s = i && s.bind.bind(n, n);
        t.exports = i ? s : function(t) {
            return function() {
                return n.apply(t, arguments)
            }
        }
    }
    , function(t, e, i) {
        var n = (i = i(39)).all;
        t.exports = i.IS_HTMLDDA ? function(t) {
            return "function" == typeof t || t === n
        }
        : function(t) {
            return "function" == typeof t
        }
    }
    , function(t, e, i) {
        (function(e) {
            function i(t) {
                return t && t.Math == Math && t
            }
            t.exports = i("object" == typeof globalThis && globalThis) || i("object" == typeof window && window) || i("object" == typeof self && self) || i("object" == typeof e && e) || function() {
                return this
            }() || Function("return this")()
        }
        ).call(this, i(36))
    }
    , function(t, e, i) {
        i = i(0),
        t.exports = !i(function() {
            return 7 != Object.defineProperty({}, 1, {
                get: function() {
                    return 7
                }
            })[1]
        })
    }
    , function(t, e, i) {
        var n = i(1)
          , s = i(29)
          , o = n({}.hasOwnProperty);
        t.exports = Object.hasOwn || function(t, e) {
            return o(s(t), e)
        }
    }
    , function(t, e, i) {
        var n = i(3)
          , s = i(26)
          , o = i(5)
          , a = i(47)
          , r = i(42)
          , l = i(41)
          , h = s("wks")
          , c = n.Symbol
          , d = c && c.for
          , u = l ? c : c && c.withoutSetter || a;
        t.exports = function(t) {
            var e;
            return o(h, t) && (r || "string" == typeof h[t]) || (e = "Symbol." + t,
            r && o(c, t) ? h[t] = c[t] : h[t] = (l && d ? d : u)(e)),
            h[t]
        }
    }
    , function(t, e, i) {
        var n = i(9)
          , s = String
          , o = TypeError;
        t.exports = function(t) {
            if (n(t))
                return t;
            throw o(s(t) + " is not an object")
        }
    }
    , function(t, e, i) {
        i = i(21);
        var n = Function.prototype.call;
        t.exports = i ? n.bind(n) : function() {
            return n.apply(n, arguments)
        }
    }
    , function(t, e, i) {
        var n = i(2)
          , s = (i = i(39)).all;
        t.exports = i.IS_HTMLDDA ? function(t) {
            return "object" == typeof t ? null !== t : n(t) || t === s
        }
        : function(t) {
            return "object" == typeof t ? null !== t : n(t)
        }
    }
    , function(t, e, i) {
        var n = i(4)
          , s = i(48)
          , o = i(50)
          , a = i(7)
          , r = i(24)
          , l = TypeError
          , h = Object.defineProperty
          , c = Object.getOwnPropertyDescriptor
          , d = "enumerable"
          , u = "configurable"
          , p = "writable";
        e.f = n ? o ? function(t, e, i) {
            var n;
            return a(t),
            e = r(e),
            a(i),
            "function" == typeof t && "prototype" === e && "value"in i && p in i && !i[p] && (n = c(t, e)) && n[p] && (t[e] = i.value,
            i = {
                configurable: (u in i ? i : n)[u],
                enumerable: (d in i ? i : n)[d],
                writable: !1
            }),
            h(t, e, i)
        }
        : h : function(t, e, i) {
            if (a(t),
            e = r(e),
            a(i),
            s)
                try {
                    return h(t, e, i)
                } catch (n) {}
            if ("get"in i || "set"in i)
                throw l("Accessors not supported");
            return "value"in i && (t[e] = i.value),
            t
        }
    }
    , function(t, e, i) {
        var n = i(83)
          , s = String;
        t.exports = function(t) {
            if ("Symbol" === n(t))
                throw TypeError("Cannot convert a Symbol value to a string");
            return s(t)
        }
    }
    , function(t, e, i) {
        var n = (i = i(1))({}.toString)
          , s = i("".slice);
        t.exports = function(t) {
            return s(n(t), 8, -1)
        }
    }
    , function(t, e, i) {
        var n = i(23)
          , s = TypeError;
        t.exports = function(t) {
            if (n(t))
                throw s("Can't call method on " + t);
            return t
        }
    }
    , function(t, e, i) {
        var n = i(3)
          , s = i(2);
        t.exports = function(t, e) {
            return arguments.length < 2 ? (i = n[t],
            s(i) ? i : void 0) : n[t] && n[t][e];
            var i
        }
    }
    , function(t, e, i) {
        var n = i(71)
          , s = i(13);
        t.exports = function(t) {
            return n(s(t))
        }
    }
    , function(t, e, i) {
        i = i(14),
        t.exports = i("navigator", "userAgent") || ""
    }
    , function(t, e, i) {
        var n = i(4)
          , s = i(10)
          , o = i(22);
        t.exports = n ? function(t, e, i) {
            return s.f(t, e, o(1, i))
        }
        : function(t, e, i) {
            return t[e] = i,
            t
        }
    }
    , function(t, e, i) {
        var n = i(81);
        t.exports = function(t) {
            return (t = +t) != t || 0 == t ? 0 : n(t)
        }
    }
    , , function(t, e, i) {
        var n = i(3)
          , s = i(38).f
          , o = i(17)
          , a = i(30)
          , r = i(28)
          , l = i(78)
          , h = i(57);
        t.exports = function(t, e) {
            var i, c, d, u = t.target, p = t.global, f = t.stat, g = p ? n : f ? n[u] || r(u, {}) : (n[u] || {}).prototype;
            if (g)
                for (i in e) {
                    if (c = e[i],
                    d = t.dontCallGetSet ? (d = s(g, i)) && d.value : g[i],
                    !h(p ? i : u + (f ? "." : "#") + i, t.forced) && void 0 !== d) {
                        if (typeof c == typeof d)
                            continue;
                        l(c, d)
                    }
                    (t.sham || d && d.sham) && o(c, "sham", !0),
                    a(g, i, c, t)
                }
        }
    }
    , function(t, e, i) {
        i = i(0),
        t.exports = !i(function() {
            var t = function() {}
            .bind();
            return "function" != typeof t || t.hasOwnProperty("prototype")
        })
    }
    , function(t, e) {
        t.exports = function(t, e) {
            return {
                enumerable: !(1 & t),
                configurable: !(2 & t),
                writable: !(4 & t),
                value: e
            }
        }
    }
    , function(t, e) {
        t.exports = function(t) {
            return null == t
        }
    }
    , function(t, e, i) {
        var n = i(72)
          , s = i(40);
        t.exports = function(t) {
            return t = n(t, "string"),
            s(t) ? t : t + ""
        }
    }
    , function(t, e, i) {
        i = i(1),
        t.exports = i({}.isPrototypeOf)
    }
    , function(t, e, i) {
        var n = i(74)
          , s = i(27);
        (t.exports = function(t, e) {
            return s[t] || (s[t] = void 0 !== e ? e : {})
        }
        )("versions", []).push({
            version: "3.26.1",
            mode: n ? "pure" : "global",
            copyright: "Â© 2014-2022 Denis Pushkarev (zloirock.ru)",
            license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE",
            source: "https://github.com/zloirock/core-js"
        })
    }
    , function(t, e, i) {
        var n = i(3)
          , s = (i = i(28),
        "__core-js_shared__");
        n = n[s] || i(s, {});
        t.exports = n
    }
    , function(t, e, i) {
        var n = i(3)
          , s = Object.defineProperty;
        t.exports = function(t, e) {
            try {
                s(n, t, {
                    value: e,
                    configurable: !0,
                    writable: !0
                })
            } catch (i) {
                n[t] = e
            }
            return e
        }
    }
    , function(t, e, i) {
        var n = i(13)
          , s = Object;
        t.exports = function(t) {
            return s(n(t))
        }
    }
    , function(t, e, i) {
        var n = i(2)
          , s = i(10)
          , o = i(75)
          , a = i(28);
        t.exports = function(t, e, i, r) {
            var l = (r = r || {}).enumerable
              , h = void 0 !== r.name ? r.name : e;
            if (n(i) && o(i, h, r),
            r.global)
                l ? t[e] = i : a(e, i);
            else {
                try {
                    r.unsafe ? t[e] && (l = !0) : delete t[e]
                } catch (c) {}
                l ? t[e] = i : s.f(t, e, {
                    value: i,
                    enumerable: !1,
                    configurable: !r.nonConfigurable,
                    writable: !r.nonWritable
                })
            }
            return t
        }
    }
    , function(t, e, i) {
        var n, s, o, a, r = i(77), l = i(3), h = i(9), c = i(17), d = i(5), u = i(27), p = i(52), f = (i = i(32),
        "Object already initialized"), g = l.TypeError, m = (l = l.WeakMap,
        r || u.state ? ((o = u.state || (u.state = new l)).get = o.get,
        o.has = o.has,
        o.set = o.set,
        n = function(t, e) {
            if (o.has(t))
                throw g(f);
            return e.facade = t,
            o.set(t, e),
            e
        }
        ,
        s = function(t) {
            return o.get(t) || {}
        }
        ,
        function(t) {
            return o.has(t)
        }
        ) : (i[a = p("state")] = !0,
        n = function(t, e) {
            if (d(t, a))
                throw g(f);
            return e.facade = t,
            c(t, a, e),
            e
        }
        ,
        s = function(t) {
            return d(t, a) ? t[a] : {}
        }
        ,
        function(t) {
            return d(t, a)
        }
        ));
        t.exports = {
            set: n,
            get: s,
            has: m,
            enforce: function(t) {
                return m(t) ? s(t) : n(t, {})
            },
            getterFor: function(t) {
                return function(e) {
                    if (h(e) && (e = s(e)).type === t)
                        return e;
                    throw g("Incompatible receiver, " + t + " required")
                }
            }
        }
    }
    , function(t, e) {
        t.exports = {}
    }
    , function(t, e, i) {
        var n = i(56);
        t.exports = function(t) {
            return n(t.length)
        }
    }
    , function(t, e) {
        t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
    }
    , function(t, e, i) {
        var n = i(8)
          , s = i(1)
          , o = i(11)
          , a = i(58)
          , r = i(59)
          , l = i(26)
          , h = i(85)
          , c = i(31).get
          , d = i(60)
          , u = (i = i(61),
        l("native-string-replace", String.prototype.replace))
          , p = RegExp.prototype.exec
          , f = p
          , g = s("".charAt)
          , m = s("".indexOf)
          , _ = s("".replace)
          , b = s("".slice)
          , v = (l = /b*/g,
        n(p, s = /a/, "a"),
        n(p, l, "a"),
        0 !== s.lastIndex || 0 !== l.lastIndex)
          , y = r.BROKEN_CARET
          , x = void 0 !== /()??/.exec("")[1];
        (v || x || y || d || i) && (f = function(t) {
            var e, i, s, r, l, d, w = this, C = c(w);
            t = o(t);
            if (S = C.raw)
                return S.lastIndex = w.lastIndex,
                T = n(f, S, t),
                w.lastIndex = S.lastIndex,
                T;
            var k = C.groups
              , S = y && w.sticky
              , T = n(a, w)
              , A = (C = w.source,
            0)
              , E = t;
            if (S && (T = _(T, "y", ""),
            -1 === m(T, "g") && (T += "g"),
            E = b(t, w.lastIndex),
            0 < w.lastIndex && (!w.multiline || w.multiline && "\n" !== g(t, w.lastIndex - 1)) && (C = "(?: " + C + ")",
            E = " " + E,
            A++),
            e = new RegExp("^(?:" + C + ")",T)),
            x && (e = new RegExp("^" + C + "$(?!\\s)",T)),
            v && (i = w.lastIndex),
            s = n(p, S ? e : w, E),
            S ? s ? (s.input = b(s.input, A),
            s[0] = b(s[0], A),
            s.index = w.lastIndex,
            w.lastIndex += s[0].length) : w.lastIndex = 0 : v && s && (w.lastIndex = w.global ? s.index + s[0].length : i),
            x && s && 1 < s.length && n(u, s[0], e, function() {
                for (r = 1; r < arguments.length - 2; r++)
                    void 0 === arguments[r] && (s[r] = void 0)
            }),
            s && k)
                for (s.groups = l = h(null),
                r = 0; r < k.length; r++)
                    l[(d = k[r])[0]] = s[d[1]];
            return s
        }
        ),
        t.exports = f
    }
    , function(t, e) {
        var i = function() {
            return this
        }();
        try {
            i = i || new Function("return this")()
        } catch (n) {
            "object" == typeof window && (i = window)
        }
        t.exports = i
    }
    , function(t, e, i) {
        var n = i(20);
        i = i(35);
        n({
            target: "RegExp",
            proto: !0,
            forced: /./.exec !== i
        }, {
            exec: i
        })
    }
    , function(t, e, i) {
        var n = i(4)
          , s = i(8)
          , o = i(70)
          , a = i(22)
          , r = i(15)
          , l = i(24)
          , h = i(5)
          , c = i(48)
          , d = Object.getOwnPropertyDescriptor;
        e.f = n ? d : function(t, e) {
            if (t = r(t),
            e = l(e),
            c)
                try {
                    return d(t, e)
                } catch (i) {}
            if (h(t, e))
                return a(!s(o.f, t, e), t[e])
        }
    }
    , function(t, e) {
        var i = "object" == typeof document && document.all;
        t.exports = {
            all: i,
            IS_HTMLDDA: void 0 === i && void 0 !== i
        }
    }
    , function(t, e, i) {
        var n = i(14)
          , s = i(2)
          , o = i(25)
          , a = (i = i(41),
        Object);
        t.exports = i ? function(t) {
            return "symbol" == typeof t
        }
        : function(t) {
            var e = n("Symbol");
            return s(e) && o(e.prototype, a(t))
        }
    }
    , function(t, e, i) {
        i = i(42),
        t.exports = i && !Symbol.sham && "symbol" == typeof Symbol.iterator
    }
    , function(t, e, i) {
        var n = i(43);
        i = i(0);
        t.exports = !!Object.getOwnPropertySymbols && !i(function() {
            var t = Symbol();
            return !String(t) || !(Object(t)instanceof Symbol) || !Symbol.sham && n && n < 41
        })
    }
    , function(t, e, i) {
        var n, s, o = i(3), a = (i = i(16),
        o.process);
        o = o.Deno;
        !(s = (o = (a = a && a.versions || o && o.version) && a.v8) ? 0 < (n = o.split("."))[0] && n[0] < 4 ? 1 : +(n[0] + n[1]) : s) && i && (!(n = i.match(/Edge\/(\d+)/)) || 74 <= n[1]) && (n = i.match(/Chrome\/(\d+)/)) && (s = +n[1]),
        t.exports = s
    }
    , function(t, e, i) {
        var n = i(45)
          , s = i(23);
        t.exports = function(t, e) {
            return t = t[e],
            s(t) ? void 0 : n(t)
        }
    }
    , function(t, e, i) {
        var n = i(2)
          , s = i(46)
          , o = TypeError;
        t.exports = function(t) {
            if (n(t))
                return t;
            throw o(s(t) + " is not a function")
        }
    }
    , function(t, e) {
        var i = String;
        t.exports = function(t) {
            try {
                return i(t)
            } catch (e) {
                return "Object"
            }
        }
    }
    , function(t, e, i) {
        i = i(1);
        var n = 0
          , s = Math.random()
          , o = i(1. .toString);
        t.exports = function(t) {
            return "Symbol(" + (void 0 === t ? "" : t) + ")_" + o(++n + s, 36)
        }
    }
    , function(t, e, i) {
        var n = i(4)
          , s = i(0)
          , o = i(49);
        t.exports = !n && !s(function() {
            return 7 != Object.defineProperty(o("div"), "a", {
                get: function() {
                    return 7
                }
            }).a
        })
    }
    , function(t, e, i) {
        var n = i(3)
          , s = (i = i(9),
        n.document)
          , o = i(s) && i(s.createElement);
        t.exports = function(t) {
            return o ? s.createElement(t) : {}
        }
    }
    , function(t, e, i) {
        var n = i(4);
        i = i(0);
        t.exports = n && i(function() {
            return 42 != Object.defineProperty(function() {}, "prototype", {
                value: 42,
                writable: !1
            }).prototype
        })
    }
    , function(t, e, i) {
        var n = i(4)
          , s = (i = i(5),
        Function.prototype)
          , o = n && Object.getOwnPropertyDescriptor
          , a = (i = i(s, "name")) && "something" === function() {}
        .name;
        n = i && (!n || o(s, "name").configurable);
        t.exports = {
            EXISTS: i,
            PROPER: a,
            CONFIGURABLE: n
        }
    }
    , function(t, e, i) {
        var n = i(26)
          , s = i(47)
          , o = n("keys");
        t.exports = function(t) {
            return o[t] || (o[t] = s(t))
        }
    }
    , function(t, e, i) {
        var n = i(54)
          , s = i(34).concat("length", "prototype");
        e.f = Object.getOwnPropertyNames || function(t) {
            return n(t, s)
        }
    }
    , function(t, e, i) {
        var n = i(1)
          , s = i(5)
          , o = i(15)
          , a = i(80).indexOf
          , r = i(32)
          , l = n([].push);
        t.exports = function(t, e) {
            var i, n = o(t), h = 0, c = [];
            for (i in n)
                !s(r, i) && s(n, i) && l(c, i);
            for (; e.length > h; )
                !s(n, i = e[h++]) || ~a(c, i) || l(c, i);
            return c
        }
    }
    , function(t, e, i) {
        var n = i(18)
          , s = Math.max
          , o = Math.min;
        t.exports = function(t, e) {
            return (t = n(t)) < 0 ? s(t + e, 0) : o(t, e)
        }
    }
    , function(t, e, i) {
        var n = i(18)
          , s = Math.min;
        t.exports = function(t) {
            return 0 < t ? s(n(t), 9007199254740991) : 0
        }
    }
    , function(t, e, i) {
        function n(t, e) {
            return (t = l[r(t)]) == c || t != h && (o(e) ? s(e) : !!e)
        }
        var s = i(0)
          , o = i(2)
          , a = /#|\.prototype\./
          , r = n.normalize = function(t) {
            return String(t).replace(a, ".").toLowerCase()
        }
          , l = n.data = {}
          , h = n.NATIVE = "N"
          , c = n.POLYFILL = "P";
        t.exports = n
    }
    , function(t, e, i) {
        var n = i(7);
        t.exports = function() {
            var t = n(this)
              , e = "";
            return t.hasIndices && (e += "d"),
            t.global && (e += "g"),
            t.ignoreCase && (e += "i"),
            t.multiline && (e += "m"),
            t.dotAll && (e += "s"),
            t.unicode && (e += "u"),
            t.unicodeSets && (e += "v"),
            t.sticky && (e += "y"),
            e
        }
    }
    , function(t, e, i) {
        var n = i(0)
          , s = i(3).RegExp
          , o = (i = n(function() {
            var t = s("a", "y");
            return t.lastIndex = 2,
            null != t.exec("abcd")
        })) || n(function() {
            return !s("a", "y").sticky
        });
        n = i || n(function() {
            var t = s("^r", "gy");
            return t.lastIndex = 2,
            null != t.exec("str")
        });
        t.exports = {
            BROKEN_CARET: n,
            MISSED_STICKY: o,
            UNSUPPORTED_Y: i
        }
    }
    , function(t, e, i) {
        var n = i(0)
          , s = i(3).RegExp;
        t.exports = n(function() {
            var t = s(".", "s");
            return !(t.dotAll && t.exec("\n") && "s" === t.flags)
        })
    }
    , function(t, e, i) {
        var n = i(0)
          , s = i(3).RegExp;
        t.exports = n(function() {
            var t = s("(?<a>b)", "g");
            return "b" !== t.exec("b").groups.a || "bc" !== "b".replace(t, "$<a>c")
        })
    }
    , function(t, e) {
        t.exports = "\t\n\v\f\r Â áš€â€€â€â€‚â€ƒâ€„â€…â€†â€‡â€ˆâ€‰â€Šâ€¯âŸã€€\u2028\u2029\ufeff"
    }
    , , , , , , function(t, e, i) {
        i.r(e),
        function(t, e) {
            i(37),
            i(89),
            i(97),
            i(105),
            i(108);
            var n, s, o, a, r, l, h, c, d, u, p, f, g, m, _, b, v, y, x, w, C, k, S, T, A, E, M, O, D, $, I, L, P, R, N = "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {}, B = (n = /\blang(?:uage)?-([\w-]+)\b/i,
            s = 0,
            o = N.Prism = {
                manual: N.Prism && N.Prism.manual,
                disableWorkerMessageHandler: N.Prism && N.Prism.disableWorkerMessageHandler,
                util: {
                    encode: function(t) {
                        return t instanceof a ? new a(t.type,o.util.encode(t.content),t.alias) : "Array" === o.util.type(t) ? t.map(o.util.encode) : t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ")
                    },
                    type: function(t) {
                        return Object.prototype.toString.call(t).match(/\[object (\w+)\]/)[1]
                    },
                    objId: function(t) {
                        return t.__id || Object.defineProperty(t, "__id", {
                            value: ++s
                        }),
                        t.__id
                    },
                    clone: function(t, e) {
                        var i = o.util.type(t);
                        switch (e = e || {},
                        i) {
                        case "Object":
                            if (e[o.util.objId(t)])
                                return e[o.util.objId(t)];
                            var n, s = {};
                            for (n in e[o.util.objId(t)] = s,
                            t)
                                t.hasOwnProperty(n) && (s[n] = o.util.clone(t[n], e));
                            return s;
                        case "Array":
                            return e[o.util.objId(t)] ? e[o.util.objId(t)] : (s = [],
                            e[o.util.objId(t)] = s,
                            t.forEach(function(t, i) {
                                s[i] = o.util.clone(t, e)
                            }),
                            s)
                        }
                        return t
                    }
                },
                languages: {
                    extend: function(t, e) {
                        var i, n = o.util.clone(o.languages[t]);
                        for (i in e)
                            n[i] = e[i];
                        return n
                    },
                    insertBefore: function(t, e, i, n) {
                        var s = (n = n || o.languages)[t];
                        if (2 == arguments.length) {
                            for (var a in i = e)
                                i.hasOwnProperty(a) && (s[a] = i[a]);
                            return s
                        }
                        var r, l = {};
                        for (r in s)
                            if (s.hasOwnProperty(r)) {
                                if (r == e)
                                    for (var a in i)
                                        i.hasOwnProperty(a) && (l[a] = i[a]);
                                l[r] = s[r]
                            }
                        return o.languages.DFS(o.languages, function(e, i) {
                            i === n[t] && e != t && (this[e] = l)
                        }),
                        n[t] = l
                    },
                    DFS: function(t, e, i, n) {
                        for (var s in n = n || {},
                        t)
                            t.hasOwnProperty(s) && (e.call(t, s, t[s], i || s),
                            "Object" !== o.util.type(t[s]) || n[o.util.objId(t[s])] ? "Array" !== o.util.type(t[s]) || n[o.util.objId(t[s])] || (n[o.util.objId(t[s])] = !0,
                            o.languages.DFS(t[s], e, s, n)) : (n[o.util.objId(t[s])] = !0,
                            o.languages.DFS(t[s], e, null, n)))
                    }
                },
                plugins: {},
                highlightAll: function(t, e) {
                    o.highlightAllUnder(document, t, e)
                },
                highlightAllUnder: function(t, e, i) {
                    for (var n, s = {
                        callback: i,
                        selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
                    }, a = (o.hooks.run("before-highlightall", s),
                    s.elements || t.querySelectorAll(s.selector)), r = 0; n = a[r++]; )
                        o.highlightElement(n, !0 === e, s.callback)
                },
                highlightElement: function(t, e, i) {
                    for (var s, a = t; a && !n.test(a.className); )
                        a = a.parentNode;
                    a && (r = (a.className.match(n) || [, ""])[1].toLowerCase(),
                    s = o.languages[r]),
                    t.className = t.className.replace(n, "").replace(/\s+/g, " ") + " language-" + r,
                    t.parentNode && (a = t.parentNode,
                    /pre/i.test(a.nodeName)) && (a.className = a.className.replace(n, "").replace(/\s+/g, " ") + " language-" + r);
                    var r, l = {
                        element: t,
                        language: r,
                        grammar: s,
                        code: t.textContent
                    };
                    o.hooks.run("before-sanity-check", l),
                    l.code && l.grammar ? (o.hooks.run("before-highlight", l),
                    e && N.Worker ? ((r = new Worker(o.filename)).onmessage = function(t) {
                        l.highlightedCode = t.data,
                        o.hooks.run("before-insert", l),
                        l.element.innerHTML = l.highlightedCode,
                        i && i.call(l.element),
                        o.hooks.run("after-highlight", l),
                        o.hooks.run("complete", l)
                    }
                    ,
                    r.postMessage(JSON.stringify({
                        language: l.language,
                        code: l.code,
                        immediateClose: !0
                    }))) : (l.highlightedCode = o.highlight(l.code, l.grammar, l.language),
                    o.hooks.run("before-insert", l),
                    l.element.innerHTML = l.highlightedCode,
                    i && i.call(t),
                    o.hooks.run("after-highlight", l),
                    o.hooks.run("complete", l))) : (l.code && (o.hooks.run("before-highlight", l),
                    l.element.textContent = l.code,
                    o.hooks.run("after-highlight", l)),
                    o.hooks.run("complete", l))
                },
                highlight: function(t, e, i) {
                    return t = {
                        code: t,
                        grammar: e,
                        language: i
                    },
                    o.hooks.run("before-tokenize", t),
                    t.tokens = o.tokenize(t.code, t.grammar),
                    o.hooks.run("after-tokenize", t),
                    a.stringify(o.util.encode(t.tokens), t.language)
                },
                matchGrammar: function(t, e, i, n, s, a, r) {
                    var l, h = o.Token;
                    for (l in i)
                        if (i.hasOwnProperty(l) && i[l]) {
                            if (l == r)
                                return;
                            for (var c = i[l], d = (c = "Array" === o.util.type(c) ? c : [c],
                            0); d < c.length; ++d) {
                                var u, p = (b = c[d]).inside, f = !!b.lookbehind, g = !!b.greedy, m = 0, _ = b.alias;
                                g && !b.pattern.global && (u = b.pattern.toString().match(/[imuy]*$/)[0],
                                b.pattern = RegExp(b.pattern.source, u + "g"));
                                for (var b = b.pattern || b, v = n, y = s; v < e.length; y += e[v].length,
                                ++v) {
                                    var x = e[v];
                                    if (e.length > t.length)
                                        return;
                                    if (!(x instanceof h)) {
                                        if (g && v != e.length - 1) {
                                            if (b.lastIndex = y,
                                            !(A = b.exec(t)))
                                                break;
                                            for (var w = A.index + (f ? A[1].length : 0), C = A.index + A[0].length, k = v, S = y, T = e.length; k < T && (S < C || !e[k].type && !e[k - 1].greedy); ++k)
                                                (S += e[k].length) <= w && (++v,
                                                y = S);
                                            if (e[v]instanceof h)
                                                continue;
                                            E = k - v,
                                            x = t.slice(y, S),
                                            A.index -= y
                                        } else {
                                            b.lastIndex = 0;
                                            var A = b.exec(x)
                                              , E = 1
                                        }
                                        if (A) {
                                            f && (m = A[1] ? A[1].length : 0);
                                            C = (w = A.index + m) + (A = A[0].slice(m)).length;
                                            var M = x.slice(0, w)
                                              , O = (x = x.slice(C),
                                            [v, E]);
                                            M = (M && (++v,
                                            y += M.length,
                                            O.push(M)),
                                            new h(l,p ? o.tokenize(A, p) : A,_,A,g));
                                            if (O.push(M),
                                            x && O.push(x),
                                            Array.prototype.splice.apply(e, O),
                                            1 != E && o.matchGrammar(t, e, i, v, y, !0, l),
                                            a)
                                                break
                                        } else if (a)
                                            break
                                    }
                                }
                            }
                        }
                },
                tokenize: function(t, e, i) {
                    var n = [t]
                      , s = e.rest;
                    if (s) {
                        for (var a in s)
                            e[a] = s[a];
                        delete e.rest
                    }
                    return o.matchGrammar(t, n, e, 0, 0, !1),
                    n
                },
                hooks: {
                    all: {},
                    add: function(t, e) {
                        var i = o.hooks.all;
                        i[t] = i[t] || [],
                        i[t].push(e)
                    },
                    run: function(t, e) {
                        var i = o.hooks.all[t];
                        if (i && i.length)
                            for (var n, s = 0; n = i[s++]; )
                                n(e)
                    }
                }
            },
            (a = o.Token = function(t, e, i, n, s) {
                this.type = t,
                this.content = e,
                this.alias = i,
                this.length = 0 | (n || "").length,
                this.greedy = !!s
            }
            ).stringify = function(t, e, i) {
                var n;
                return "string" == typeof t ? t : "Array" === o.util.type(t) ? t.map(function(i) {
                    return a.stringify(i, e, t)
                }).join("") : (n = {
                    type: t.type,
                    content: a.stringify(t.content, e, i),
                    tag: "span",
                    classes: ["token", t.type],
                    attributes: {},
                    language: e,
                    parent: i
                },
                t.alias && (i = "Array" === o.util.type(t.alias) ? t.alias : [t.alias],
                Array.prototype.push.apply(n.classes, i)),
                o.hooks.run("wrap", n),
                i = Object.keys(n.attributes).map(function(t) {
                    return t + '="' + (n.attributes[t] || "").replace(/"/g, "&quot;") + '"'
                }).join(" "),
                "<" + n.tag + ' class="' + n.classes.join(" ") + '"' + (i ? " " + i : "") + ">" + n.content + "</" + n.tag + ">")
            }
            ,
            N.document ? (l = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop()) && (o.filename = l.src,
            o.manual || l.hasAttribute("data-manual") || ("loading" !== document.readyState ? window.requestAnimationFrame ? window.requestAnimationFrame(o.highlightAll) : window.setTimeout(o.highlightAll, 16) : document.addEventListener("DOMContentLoaded", o.highlightAll))) : N.addEventListener && !o.disableWorkerMessageHandler && N.addEventListener("message", function(t) {
                var e = (t = JSON.parse(t.data)).language
                  , i = t.code;
                t = t.immediateClose;
                N.postMessage(o.highlight(i, o.languages[e], e)),
                t && N.close()
            }, !1),
            N.Prism);
            function H(t, e) {
                return t = t.replace(/<S>/g, function() {
                    return h
                }).replace(/<BRACES>/g, function() {
                    return c
                }).replace(/<SPREAD>/g, function() {
                    return d
                }),
                RegExp(t, e)
            }
            function F(t) {
                for (var e = [], i = 0; i < t.length; i++) {
                    var n = t[i]
                      , s = !1;
                    "string" != typeof n && ("tag" === n.type && n.content[0] && "tag" === n.content[0].type ? "</" === n.content[0].content[0].content ? 0 < e.length && e[e.length - 1].tagName === u(n.content[0].content[1]) && e.pop() : "/>" !== n.content[n.content.length - 1].content && e.push({
                        tagName: u(n.content[0].content[1]),
                        openedBraces: 0
                    }) : 0 < e.length && "punctuation" === n.type && "{" === n.content ? e[e.length - 1].openedBraces++ : 0 < e.length && 0 < e[e.length - 1].openedBraces && "punctuation" === n.type && "}" === n.content ? e[e.length - 1].openedBraces-- : s = !0),
                    (s || "string" == typeof n) && 0 < e.length && 0 === e[e.length - 1].openedBraces && (s = u(n),
                    i < t.length - 1 && ("string" == typeof t[i + 1] || "plain-text" === t[i + 1].type) && (s += u(t[i + 1]),
                    t.splice(i + 1, 1)),
                    0 < i && ("string" == typeof t[i - 1] || "plain-text" === t[i - 1].type) && (s = u(t[i - 1]) + s,
                    t.splice(i - 1, 1),
                    i--),
                    t[i] = new r.Token("plain-text",s,null,s)),
                    n.content && "string" != typeof n.content && F(n.content)
                }
            }
            function z(t, e) {
                return t.replace(/<<(\d+)>>/g, function(t, i) {
                    return "(?:" + e[+i] + ")"
                })
            }
            function j(t, e, i) {
                return RegExp(z(t, e), i || "")
            }
            function W(t, e) {
                for (var i = 0; i < e; i++)
                    t = t.replace(/<<self>>/g, function() {
                        return "(?:" + t + ")"
                    });
                return t.replace(/<<self>>/g, "[^\\s\\S]")
            }
            function V(t) {
                return "\\b(?:" + t.trim().replace(/ /g, "|") + ")\\b"
            }
            function Y(t, e) {
                return {
                    interpolation: {
                        pattern: j(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [t]),
                        lookbehind: !0,
                        inside: {
                            "format-string": {
                                pattern: j(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [e, b]),
                                lookbehind: !0,
                                inside: {
                                    punctuation: /^:/
                                }
                            },
                            punctuation: /^\{|\}$/,
                            expression: {
                                pattern: /[\s\S]+/,
                                alias: "language-csharp",
                                inside: p.languages.csharp
                            }
                        }
                    },
                    string: /[\s\S]+/
                }
            }
            if (t.exports && (t.exports = B),
            void 0 !== e && (e.Prism = B),
            B.languages.markup = {
                comment: /<!--[\s\S]*?-->/,
                prolog: /<\?[\s\S]+?\?>/,
                doctype: /<!DOCTYPE[\s\S]+?>/i,
                cdata: /<!\[CDATA\[[\s\S]*?]]>/i,
                tag: {
                    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i,
                    greedy: !0,
                    inside: {
                        tag: {
                            pattern: /^<\/?[^\s>\/]+/i,
                            inside: {
                                punctuation: /^<\/?/,
                                namespace: /^[^\s>\/:]+:/
                            }
                        },
                        "special-attr": [],
                        "attr-value": {
                            pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i,
                            inside: {
                                punctuation: [/^=/, {
                                    pattern: /(^|[^\\])["']/,
                                    lookbehind: !0
                                }]
                            }
                        },
                        punctuation: /\/?>/,
                        "attr-name": {
                            pattern: /[^\s>\/]+/,
                            inside: {
                                namespace: /^[^\s>\/:]+:/
                            }
                        }
                    }
                },
                entity: /&#?[\da-z]{1,8};/i
            },
            B.languages.markup.tag.inside["attr-value"].inside.entity = B.languages.markup.entity,
            B.hooks.add("wrap", function(t) {
                "entity" === t.type && (t.attributes.title = t.content.replace(/&amp;/, "&"))
            }),
            B.languages.xml = B.languages.markup,
            B.languages.html = B.languages.markup,
            B.languages.mathml = B.languages.markup,
            B.languages.svg = B.languages.markup,
            B.languages.css = {
                comment: /\/\*[\s\S]*?\*\//,
                atrule: {
                    pattern: /@[\w-]+?.*?(?:;|(?=\s*\{))/i,
                    inside: {
                        rule: /@[\w-]+/
                    }
                },
                url: /url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
                selector: /[^{}\s][^{};]*?(?=\s*\{)/,
                string: {
                    pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
                    greedy: !0
                },
                property: /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,
                important: /\B!important\b/i,
                function: /[-a-z0-9]+(?=\()/i,
                punctuation: /[(){};:]/
            },
            B.languages.css.atrule.inside.rest = B.languages.css,
            B.languages.markup && (B.languages.insertBefore("markup", "tag", {
                style: {
                    pattern: /(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i,
                    lookbehind: !0,
                    inside: B.languages.css,
                    alias: "language-css",
                    greedy: !0
                }
            }),
            B.languages.insertBefore("inside", "attr-value", {
                "style-attr": {
                    pattern: /\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,
                    inside: {
                        "attr-name": {
                            pattern: /^\s*style/i,
                            inside: B.languages.markup.tag.inside
                        },
                        punctuation: /^\s*=\s*['"]|['"]\s*$/,
                        "attr-value": {
                            pattern: /.+/i,
                            inside: B.languages.css
                        }
                    },
                    alias: "language-css"
                }
            }, B.languages.markup.tag)),
            B.languages.clike = {
                comment: [{
                    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                    lookbehind: !0
                }, {
                    pattern: /(^|[^\\:])\/\/.*/,
                    lookbehind: !0,
                    greedy: !0
                }],
                string: {
                    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
                    greedy: !0
                },
                "class-name": {
                    pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
                    lookbehind: !0,
                    inside: {
                        punctuation: /[.\\]/
                    }
                },
                keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
                boolean: /\b(?:true|false)\b/,
                function: /[a-z0-9_]+(?=\()/i,
                number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
                operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
                punctuation: /[{}[\];(),.:]/
            },
            B.languages.javascript = B.languages.extend("clike", {
                "class-name": [B.languages.clike["class-name"], {
                    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
                    lookbehind: !0
                }],
                keyword: /\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
                number: /\b(?:0[xX][\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+|NaN|Infinity)\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,
                function: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*\()/i,
                operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
            }),
            B.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/,
            B.languages.insertBefore("javascript", "keyword", {
                regex: {
                    pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[[^\]\r\n]+]|\\.|[^/\\\[\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})\]]))/,
                    lookbehind: !0,
                    greedy: !0,
                    inside: {
                        "regex-source": {
                            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                            lookbehind: !0,
                            alias: "language-regex",
                            inside: B.languages.regex
                        },
                        "regex-delimiter": /^\/|\/$/,
                        "regex-flags": /^[a-z]+$/
                    }
                },
                "function-variable": {
                    pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=\s*(?:function\b|(?:\([^()]*\)|[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/i,
                    alias: "function"
                },
                constant: /\b[A-Z][A-Z\d_]*\b/
            }),
            B.languages.insertBefore("javascript", "string", {
                hashbang: {
                    pattern: /^#!.*/,
                    greedy: !0,
                    alias: "comment"
                },
                "string-property": {
                    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
                    lookbehind: !0,
                    greedy: !0,
                    alias: "property"
                },
                "template-string": {
                    pattern: /`(?:\\[\s\S]|\${[^}]+}|[^\\`])*`/,
                    greedy: !0,
                    inside: {
                        interpolation: {
                            pattern: /\${[^}]+}/,
                            inside: {
                                "interpolation-punctuation": {
                                    pattern: /^\${|}$/,
                                    alias: "punctuation"
                                },
                                rest: null
                            }
                        },
                        string: /[\s\S]+/
                    }
                }
            }),
            B.languages.insertBefore("javascript", "operator", {
                "literal-property": {
                    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
                    lookbehind: !0,
                    alias: "property"
                }
            }),
            B.languages.javascript["template-string"].inside.interpolation.inside.rest = B.languages.javascript,
            Object.defineProperty(B.languages.markup.tag, "addInlined", {
                value: function(t, e) {
                    var i;
                    (e = ((i = ((i = {})["language-" + e] = {
                        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
                        lookbehind: !0,
                        inside: B.languages[e]
                    },
                    i.cdata = /^<!\[CDATA\[|\]\]>$/i,
                    {
                        "included-cdata": {
                            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                            inside: i
                        }
                    }))["language-" + e] = {
                        pattern: /[\s\S]+/,
                        inside: B.languages[e]
                    },
                    {}))[t] = {
                        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
                            return t
                        }), "i"),
                        lookbehind: !0,
                        greedy: !0,
                        inside: i
                    },
                    B.languages.insertBefore("markup", "cdata", e)
                }
            }),
            Object.defineProperty(B.languages.markup.tag, "addAttribute", {
                value: function(t, e) {
                    B.languages.markup.tag.inside["special-attr"].push({
                        pattern: RegExp(/(^|["'\s])/.source + "(?:" + t + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
                        lookbehind: !0,
                        inside: {
                            "attr-name": /^[^\s=]+/,
                            "attr-value": {
                                pattern: /=[\s\S]+/,
                                inside: {
                                    value: {
                                        pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                                        lookbehind: !0,
                                        alias: [e, "language-" + e],
                                        inside: B.languages[e]
                                    },
                                    punctuation: [{
                                        pattern: /^=/,
                                        alias: "attr-equals"
                                    }, /"|'/]
                                }
                            }
                        }
                    })
                }
            }),
            B.languages.markup && (B.languages.insertBefore("markup", "tag", {
                script: {
                    pattern: /(<script[\s\S]*?>)[\s\S]*?(?=<\/script>)/i,
                    lookbehind: !0,
                    inside: B.languages.javascript,
                    alias: "language-javascript",
                    greedy: !0
                }
            }),
            B.languages.markup.tag.addInlined("script", "javascript"),
            B.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript")),
            B.languages.js = B.languages.javascript,
            B.languages["markup-templating"] = {},
            Object.defineProperties(B.languages["markup-templating"], {
                buildPlaceholders: {
                    value: function(t, e, i, n) {
                        t.language === e && (t.tokenStack = [],
                        t.code = t.code.replace(i, function(i) {
                            if ("function" == typeof n && !n(i))
                                return i;
                            for (var s = t.tokenStack.length; -1 !== t.code.indexOf("___" + e.toUpperCase() + s + "___"); )
                                ++s;
                            return t.tokenStack[s] = i,
                            "___" + e.toUpperCase() + s + "___"
                        }),
                        t.grammar = B.languages.markup)
                    }
                },
                tokenizePlaceholders: {
                    value: function(t, e) {
                        var i, n, s;
                        t.language === e && t.tokenStack && (t.grammar = B.languages[e],
                        i = 0,
                        n = Object.keys(t.tokenStack),
                        (s = function(o) {
                            if (!(i >= n.length))
                                for (var a = 0; a < o.length; a++) {
                                    var r = o[a];
                                    if ("string" == typeof r || r.content && "string" == typeof r.content) {
                                        var l = n[i]
                                          , h = t.tokenStack[l]
                                          , c = (p = "string" == typeof r ? r : r.content).indexOf("___" + e.toUpperCase() + l + "___");
                                        if (-1 < c) {
                                            ++i;
                                            var d, u = p.substring(0, c), p = (h = new B.Token(e,B.tokenize(h, t.grammar, e),"language-" + e,h),
                                            p.substring(c + ("___" + e.toUpperCase() + l + "___").length));
                                            if (u || p ? (d = [u, h, p].filter(function(t) {
                                                return !!t
                                            }),
                                            s(d)) : d = h,
                                            "string" == typeof r ? Array.prototype.splice.apply(o, [a, 1].concat(d)) : r.content = d,
                                            i >= n.length)
                                                break
                                        }
                                    } else
                                        r.content && "string" != typeof r.content && s(r.content)
                                }
                        }
                        )(t.tokens))
                    }
                }
            }),
            B.languages.json = {
                property: /"(?:\\.|[^\\"\r\n])*"(?=\s*:)/i,
                string: {
                    pattern: /"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
                    greedy: !0
                },
                number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,
                punctuation: /[{}[\]);,]/,
                operator: /:/g,
                boolean: /\b(?:true|false)\b/i,
                null: /\bnull\b/i
            },
            B.languages.jsonp = B.languages.json,
            l = (r = B).util.clone(r.languages.javascript),
            h = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source,
            c = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source,
            d = H(d = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source).source,
            r.languages.jsx = r.languages.extend("markup", l),
            r.languages.jsx.tag.pattern = H(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source),
            r.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/,
            r.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/,
            r.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/,
            r.languages.jsx.tag.inside.comment = l.comment,
            r.languages.insertBefore("inside", "attr-name", {
                spread: {
                    pattern: H(/<SPREAD>/.source),
                    inside: r.languages.jsx
                }
            }, r.languages.jsx.tag),
            r.languages.insertBefore("inside", "special-attr", {
                script: {
                    pattern: H(/=<BRACES>/.source),
                    alias: "language-javascript",
                    inside: {
                        "script-punctuation": {
                            pattern: /^=(?=\{)/,
                            alias: "punctuation"
                        },
                        rest: r.languages.jsx
                    }
                }
            }, r.languages.jsx.tag),
            u = function(t) {
                return t ? "string" == typeof t ? t : "string" == typeof t.content ? t.content : t.content.map(u).join("") : ""
            }
            ,
            r.hooks.add("after-tokenize", function(t) {
                "jsx" !== t.language && "tsx" !== t.language || F(t.tokens)
            }),
            p = B,
            e = "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
            D = "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
            R = "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield",
            w = V(k = "class enum interface record struct"),
            f = RegExp(V(e + " " + k + " " + D + " " + R)),
            D = V(k + " " + D + " " + R),
            e = V(e + " " + k + " " + R),
            k = W(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2),
            R = W(/\((?:[^()]|<<self>>)*\)/.source, 2),
            g = z(/<<0>>(?:\s*<<1>>)?/.source, [x = /@?\b[A-Za-z_]\w*\b/.source, k]),
            D = z(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [D, g]),
            P = z(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [D, v = /\[\s*(?:,\s*)*\]/.source]),
            m = z(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [k, R, v]),
            m = z(/\(<<0>>+(?:,<<0>>+)+\)/.source, [m]),
            m = z(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [m, D, v]),
            v = {
                keyword: f,
                punctuation: /[<>()?,.:[\]]/
            },
            _ = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source,
            y = /"(?:\\.|[^\\"\r\n])*"/.source,
            p.languages.csharp = p.languages.extend("clike", {
                string: [{
                    pattern: j(/(^|[^$\\])<<0>>/.source, [/@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source]),
                    lookbehind: !0,
                    greedy: !0
                }, {
                    pattern: j(/(^|[^@$\\])<<0>>/.source, [y]),
                    lookbehind: !0,
                    greedy: !0
                }],
                "class-name": [{
                    pattern: j(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [D]),
                    lookbehind: !0,
                    inside: v
                }, {
                    pattern: j(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [x, m]),
                    lookbehind: !0,
                    inside: v
                }, {
                    pattern: j(/(\busing\s+)<<0>>(?=\s*=)/.source, [x]),
                    lookbehind: !0
                }, {
                    pattern: j(/(\b<<0>>\s+)<<1>>/.source, [w, g]),
                    lookbehind: !0,
                    inside: v
                }, {
                    pattern: j(/(\bcatch\s*\(\s*)<<0>>/.source, [D]),
                    lookbehind: !0,
                    inside: v
                }, {
                    pattern: j(/(\bwhere\s+)<<0>>/.source, [x]),
                    lookbehind: !0
                }, {
                    pattern: j(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [P]),
                    lookbehind: !0,
                    inside: v
                }, {
                    pattern: j(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [m, e, x]),
                    inside: v
                }],
                keyword: f,
                number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
                operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
                punctuation: /\?\.?|::|[{}[\];(),.:]/
            }),
            p.languages.insertBefore("csharp", "number", {
                range: {
                    pattern: /\.\./,
                    alias: "operator"
                }
            }),
            p.languages.insertBefore("csharp", "punctuation", {
                "named-parameter": {
                    pattern: j(/([(,]\s*)<<0>>(?=\s*:)/.source, [x]),
                    lookbehind: !0,
                    alias: "punctuation"
                }
            }),
            p.languages.insertBefore("csharp", "class-name", {
                namespace: {
                    pattern: j(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [x]),
                    lookbehind: !0,
                    inside: {
                        punctuation: /\./
                    }
                },
                "type-expression": {
                    pattern: j(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [R]),
                    lookbehind: !0,
                    alias: "class-name",
                    inside: v
                },
                "return-type": {
                    pattern: j(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [m, D]),
                    inside: v,
                    alias: "class-name"
                },
                "constructor-invocation": {
                    pattern: j(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [m]),
                    lookbehind: !0,
                    inside: v,
                    alias: "class-name"
                },
                "generic-method": {
                    pattern: j(/<<0>>\s*<<1>>(?=\s*\()/.source, [x, k]),
                    inside: {
                        function: j(/^<<0>>/.source, [x]),
                        generic: {
                            pattern: RegExp(k),
                            alias: "class-name",
                            inside: v
                        }
                    }
                },
                "type-list": {
                    pattern: j(/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source, [w, g, x, m, f.source, R, /\bnew\s*\(\s*\)/.source]),
                    lookbehind: !0,
                    inside: {
                        "record-arguments": {
                            pattern: j(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [g, R]),
                            lookbehind: !0,
                            greedy: !0,
                            inside: p.languages.csharp
                        },
                        keyword: f,
                        "class-name": {
                            pattern: RegExp(m),
                            greedy: !0,
                            inside: v
                        },
                        punctuation: /[,()]/
                    }
                },
                preprocessor: {
                    pattern: /(^[\t ]*)#.*/m,
                    lookbehind: !0,
                    alias: "property",
                    inside: {
                        directive: {
                            pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
                            lookbehind: !0,
                            alias: "keyword"
                        }
                    }
                }
            }),
            e = z(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [P = y + "|" + _]),
            k = W(z(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [e]), 2),
            w = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source,
            x = z(/<<0>>(?:\s*\(<<1>>*\))?/.source, [D, k]),
            p.languages.insertBefore("csharp", "class-name", {
                attribute: {
                    pattern: j(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [w, x]),
                    lookbehind: !0,
                    greedy: !0,
                    inside: {
                        target: {
                            pattern: j(/^<<0>>(?=\s*:)/.source, [w]),
                            alias: "keyword"
                        },
                        "attribute-arguments": {
                            pattern: j(/\(<<0>>*\)/.source, [k]),
                            inside: p.languages.csharp
                        },
                        "class-name": {
                            pattern: RegExp(D),
                            inside: {
                                punctuation: /\./
                            }
                        },
                        punctuation: /[:,]/
                    }
                }
            }),
            b = /:[^}\r\n]+/.source,
            g = W(z(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [e]), 2),
            R = z(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [g, b]),
            f = W(z(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [P]), 2),
            m = z(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [f, b]),
            p.languages.insertBefore("csharp", "string", {
                "interpolation-string": [{
                    pattern: j(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [R]),
                    lookbehind: !0,
                    greedy: !0,
                    inside: Y(R, g)
                }, {
                    pattern: j(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [m]),
                    lookbehind: !0,
                    greedy: !0,
                    inside: Y(m, f)
                }],
                char: {
                    pattern: RegExp(_),
                    greedy: !0
                }
            }),
            p.languages.dotnet = p.languages.cs = p.languages.csharp,
            B.languages.aspnet = B.languages.extend("markup", {
                "page-directive": {
                    pattern: /<%\s*@.*%>/,
                    alias: "tag",
                    inside: {
                        "page-directive": {
                            pattern: /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
                            alias: "tag"
                        },
                        rest: B.languages.markup.tag.inside
                    }
                },
                directive: {
                    pattern: /<%.*%>/,
                    alias: "tag",
                    inside: {
                        directive: {
                            pattern: /<%\s*?[$=%#:]{0,2}|%>/,
                            alias: "tag"
                        },
                        rest: B.languages.csharp
                    }
                }
            }),
            B.languages.aspnet.tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/,
            B.languages.insertBefore("inside", "punctuation", {
                directive: B.languages.aspnet.directive
            }, B.languages.aspnet.tag.inside["attr-value"]),
            B.languages.insertBefore("aspnet", "comment", {
                "asp-comment": {
                    pattern: /<%--[\s\S]*?--%>/,
                    alias: ["asp", "comment"]
                }
            }),
            B.languages.insertBefore("aspnet", B.languages.javascript ? "script" : "tag", {
                "asp-script": {
                    pattern: /(<script(?=.*runat=['"]?server\b)[^>]*>)[\s\S]*?(?=<\/script>)/i,
                    lookbehind: !0,
                    alias: ["asp", "script"],
                    inside: B.languages.csharp || {}
                }
            }),
            B.languages.python = {
                comment: {
                    pattern: /(^|[^\\])#.*/,
                    lookbehind: !0,
                    greedy: !0
                },
                "string-interpolation": {
                    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
                    greedy: !0,
                    inside: {
                        interpolation: {
                            pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
                            lookbehind: !0,
                            inside: {
                                "format-spec": {
                                    pattern: /(:)[^:(){}]+(?=\}$)/,
                                    lookbehind: !0
                                },
                                "conversion-option": {
                                    pattern: /![sra](?=[:}]$)/,
                                    alias: "punctuation"
                                },
                                rest: null
                            }
                        },
                        string: /[\s\S]+/
                    }
                },
                "triple-quoted-string": {
                    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
                    greedy: !0,
                    alias: "string"
                },
                string: {
                    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
                    greedy: !0
                },
                function: {
                    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
                    lookbehind: !0
                },
                "class-name": {
                    pattern: /(\bclass\s+)\w+/i,
                    lookbehind: !0
                },
                decorator: {
                    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
                    lookbehind: !0,
                    alias: ["annotation", "punctuation"],
                    inside: {
                        punctuation: /\./
                    }
                },
                keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
                builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
                boolean: /\b(?:False|None|True)\b/,
                number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
                operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
                punctuation: /[{}[\];(),.:]/
            },
            B.languages.python["string-interpolation"].inside.interpolation.inside.rest = B.languages.python,
            B.languages.py = B.languages.python,
            (v = B).languages.ruby = v.languages.extend("clike", {
                comment: {
                    pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
                    greedy: !0
                },
                "class-name": {
                    pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
                    lookbehind: !0,
                    inside: {
                        punctuation: /[.\\]/
                    }
                },
                keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
                operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
                punctuation: /[(){}[\].,;]/
            }),
            v.languages.insertBefore("ruby", "operator", {
                "double-colon": {
                    pattern: /::/,
                    alias: "punctuation"
                }
            }),
            y = {
                pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
                lookbehind: !0,
                inside: {
                    content: {
                        pattern: /^(#\{)[\s\S]+(?=\}$)/,
                        lookbehind: !0,
                        inside: v.languages.ruby
                    },
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "punctuation"
                    }
                }
            },
            delete v.languages.ruby.function,
            x = "(?:" + [/([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source, /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source, /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source, /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source, /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source].join("|") + ")",
            w = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source,
            v.languages.insertBefore("ruby", "keyword", {
                "regex-literal": [{
                    pattern: RegExp(/%r/.source + x + /[egimnosux]{0,6}/.source),
                    greedy: !0,
                    inside: {
                        interpolation: y,
                        regex: /[\s\S]+/
                    }
                }, {
                    pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
                    lookbehind: !0,
                    greedy: !0,
                    inside: {
                        interpolation: y,
                        regex: /[\s\S]+/
                    }
                }],
                variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
                symbol: [{
                    pattern: RegExp(/(^|[^:]):/.source + w),
                    lookbehind: !0,
                    greedy: !0
                }, {
                    pattern: RegExp(/([\r\n{(,][ \t]*)/.source + w + /(?=:(?!:))/.source),
                    lookbehind: !0,
                    greedy: !0
                }],
                "method-definition": {
                    pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
                    lookbehind: !0,
                    inside: {
                        function: /\b\w+$/,
                        keyword: /^self\b/,
                        "class-name": /^\w+/,
                        punctuation: /\./
                    }
                }
            }),
            v.languages.insertBefore("ruby", "string", {
                "string-literal": [{
                    pattern: RegExp(/%[qQiIwWs]?/.source + x),
                    greedy: !0,
                    inside: {
                        interpolation: y,
                        string: /[\s\S]+/
                    }
                }, {
                    pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
                    greedy: !0,
                    inside: {
                        interpolation: y,
                        string: /[\s\S]+/
                    }
                }, {
                    pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
                    alias: "heredoc-string",
                    greedy: !0,
                    inside: {
                        delimiter: {
                            pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
                            inside: {
                                symbol: /\b\w+/,
                                punctuation: /^<<[-~]?/
                            }
                        },
                        interpolation: y,
                        string: /[\s\S]+/
                    }
                }, {
                    pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
                    alias: "heredoc-string",
                    greedy: !0,
                    inside: {
                        delimiter: {
                            pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
                            inside: {
                                symbol: /\b\w+/,
                                punctuation: /^<<[-~]?'|'$/
                            }
                        },
                        string: /[\s\S]+/
                    }
                }],
                "command-literal": [{
                    pattern: RegExp(/%x/.source + x),
                    greedy: !0,
                    inside: {
                        interpolation: y,
                        command: {
                            pattern: /[\s\S]+/,
                            alias: "string"
                        }
                    }
                }, {
                    pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
                    greedy: !0,
                    inside: {
                        interpolation: y,
                        command: {
                            pattern: /[\s\S]+/,
                            alias: "string"
                        }
                    }
                }]
            }),
            delete v.languages.ruby.string,
            v.languages.insertBefore("ruby", "number", {
                builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
                constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
            }),
            v.languages.rb = v.languages.ruby,
            (C = B).languages.php = C.languages.extend("clike", {
                keyword: /\b(?:and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\b/i,
                constant: /\b[A-Z0-9_]{2,}\b/,
                comment: {
                    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
                    lookbehind: !0
                }
            }),
            C.languages.insertBefore("php", "string", {
                "shell-comment": {
                    pattern: /(^|[^\\])#.*/,
                    lookbehind: !0,
                    alias: "comment"
                }
            }),
            C.languages.insertBefore("php", "keyword", {
                delimiter: {
                    pattern: /\?>|<\?(?:php|=)?/i,
                    alias: "important"
                },
                variable: /\$+(?:\w+\b|(?={))/i,
                package: {
                    pattern: /(\\|namespace\s+|use\s+)[\w\\]+/,
                    lookbehind: !0,
                    inside: {
                        punctuation: /\\/
                    }
                }
            }),
            C.languages.insertBefore("php", "operator", {
                property: {
                    pattern: /(->)[\w]+/,
                    lookbehind: !0
                }
            }),
            C.languages.insertBefore("php", "string", {
                "nowdoc-string": {
                    pattern: /<<<'([^']+)'(?:\r\n?|\n)(?:.*(?:\r\n?|\n))*?\1;/,
                    greedy: !0,
                    alias: "string",
                    inside: {
                        delimiter: {
                            pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
                            alias: "symbol",
                            inside: {
                                punctuation: /^<<<'?|[';]$/
                            }
                        }
                    }
                },
                "heredoc-string": {
                    pattern: /<<<(?:"([^"]+)"(?:\r\n?|\n)(?:.*(?:\r\n?|\n))*?\1;|([a-z_]\w*)(?:\r\n?|\n)(?:.*(?:\r\n?|\n))*?\2;)/i,
                    greedy: !0,
                    alias: "string",
                    inside: {
                        delimiter: {
                            pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
                            alias: "symbol",
                            inside: {
                                punctuation: /^<<<"?|[";]$/
                            }
                        },
                        interpolation: null
                    }
                },
                "single-quoted-string": {
                    pattern: /'(?:\\[\s\S]|[^\\'])*'/,
                    greedy: !0,
                    alias: "string"
                },
                "double-quoted-string": {
                    pattern: /"(?:\\[\s\S]|[^\\"])*"/,
                    greedy: !0,
                    alias: "string",
                    inside: {
                        interpolation: null
                    }
                }
            }),
            delete C.languages.php.string,
            k = {
                pattern: /{\$(?:{(?:{[^{}]+}|[^{}]+)}|[^{}])+}|(^|[^\\{])\$+(?:\w+(?:\[.+?]|->\w+)*)/,
                lookbehind: !0,
                inside: {
                    rest: C.languages.php
                }
            },
            C.languages.php["heredoc-string"].inside.interpolation = k,
            C.languages.php["double-quoted-string"].inside.interpolation = k,
            C.hooks.add("before-tokenize", function(t) {
                /(?:<\?php|<\?)/gi.test(t.code) && C.languages["markup-templating"].buildPlaceholders(t, "php", /(?:<\?php|<\?)[\s\S]*?(?:\?>|$)/gi)
            }),
            C.hooks.add("after-tokenize", function(t) {
                C.languages["markup-templating"].tokenizePlaceholders(t, "php")
            }),
            B.languages.typescript = B.languages.extend("javascript", {
                keyword: /\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield|module|declare|constructor|namespace|abstract|require|type)\b/,
                builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console)\b/
            }),
            B.languages.ts = B.languages.typescript,
            B.languages.scss = B.languages.extend("css", {
                comment: {
                    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
                    lookbehind: !0
                },
                atrule: {
                    pattern: /@[\w-]+(?:\([^()]+\)|[^(])*?(?=\s+[{;])/,
                    inside: {
                        rule: /@[\w-]+/
                    }
                },
                url: /(?:[-a-z]+-)*url(?=\()/i,
                selector: {
                    pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()]|&|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}]+[:{][^}]+))/m,
                    inside: {
                        parent: {
                            pattern: /&/,
                            alias: "important"
                        },
                        placeholder: /%[-\w]+/,
                        variable: /\$[-\w]+|#\{\$[-\w]+\}/
                    }
                }
            }),
            B.languages.insertBefore("scss", "atrule", {
                keyword: [/@(?:if|else(?: if)?|for|each|while|import|extend|debug|warn|mixin|include|function|return|content)/i, {
                    pattern: /( +)(?:from|through)(?= )/,
                    lookbehind: !0
                }]
            }),
            B.languages.scss.property = {
                pattern: /(?:[\w-]|\$[-\w]+|#\{\$[-\w]+\})+(?=\s*:)/i,
                inside: {
                    variable: /\$[-\w]+|#\{\$[-\w]+\}/
                }
            },
            B.languages.insertBefore("scss", "important", {
                variable: /\$[-\w]+|#\{\$[-\w]+\}/
            }),
            B.languages.insertBefore("scss", "function", {
                placeholder: {
                    pattern: /%[-\w]+/,
                    alias: "selector"
                },
                statement: {
                    pattern: /\B!(?:default|optional)\b/i,
                    alias: "keyword"
                },
                boolean: /\b(?:true|false)\b/,
                null: /\bnull\b/,
                operator: {
                    pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|or|not)(?=\s)/,
                    lookbehind: !0
                }
            }),
            B.languages.scss.atrule.inside.rest = B.languages.scss,
            "undefined" != typeof self && self.Prism && self.document && (S = "line-numbers",
            T = /\n(?!$)/g,
            A = function(t) {
                var e, i, n = ((n = t) ? window.getComputedStyle ? getComputedStyle(n) : n.currentStyle || null : null)["white-space"];
                "pre-wrap" !== n && "pre-line" !== n || (n = t.querySelector("code"),
                e = t.querySelector(".line-numbers-rows"),
                i = t.querySelector(".line-numbers-sizer"),
                t = n.textContent.split(T),
                i || ((i = document.createElement("span")).className = "line-numbers-sizer",
                n.appendChild(i)),
                i.style.display = "block",
                t.forEach(function(t, n) {
                    i.textContent = t || "\n",
                    t = i.getBoundingClientRect().height,
                    e.children[n].style.height = t + "px"
                }),
                i.textContent = "",
                i.style.display = "none")
            }
            ,
            window.addEventListener("resize", function() {
                Array.prototype.forEach.call(document.querySelectorAll("pre." + S), A)
            }),
            B.hooks.add("complete", function(t) {
                var e, i, n;
                t.code && (i = /\s*\bline-numbers\b\s*/,
                e = t.element.parentNode) && /pre/i.test(e.nodeName) && (i.test(e.className) || i.test(t.element.className)) && (t.element.querySelector(".line-numbers-rows") || (i.test(t.element.className) && (t.element.className = t.element.className.replace(i, " ")),
                i.test(e.className) || (e.className += " line-numbers"),
                i = (i = t.code.match(T)) ? i.length + 1 : 1,
                i = (i = new Array(i + 1)).join("<span></span>"),
                (n = document.createElement("span")).setAttribute("aria-hidden", "true"),
                n.className = "line-numbers-rows",
                n.innerHTML = i,
                e.hasAttribute("data-start") && (e.style.counterReset = "linenumber " + (parseInt(e.getAttribute("data-start"), 10) - 1)),
                t.element.appendChild(n),
                A(e),
                B.hooks.run("line-numbers", t)))
            }),
            B.hooks.add("line-numbers", function(t) {
                t.plugins = t.plugins || {},
                t.plugins.lineNumbers = !0
            }),
            B.plugins.lineNumbers = {
                getLine: function(t, e) {
                    var i, n;
                    if ("PRE" === t.tagName && t.classList.contains(S))
                        return i = t.querySelector(".line-numbers-rows"),
                        n = (e = (n = (t = parseInt(t.getAttribute("data-start"), 10) || 1) + (i.children.length - 1)) < (e = e < t ? t : e) ? n : e) - t,
                        i.children[n]
                }
            }),
            "undefined" != typeof self && self.Prism && self.document && (E = [],
            M = {},
            O = function() {}
            ,
            B.plugins.toolbar = {},
            D = B.plugins.toolbar.registerButton = function(t, e) {
                var i = "function" == typeof e ? e : function(t) {
                    var i;
                    return "function" == typeof e.onClick ? ((i = document.createElement("button")).type = "button",
                    i.addEventListener("click", function() {
                        e.onClick.call(this, t)
                    })) : "string" == typeof e.url ? (i = document.createElement("a")).href = e.url : i = document.createElement("span"),
                    i.textContent = e.text,
                    i
                }
                ;
                E.push(M[t] = i)
            }
            ,
            e = B.plugins.toolbar.hook = function(t) {
                var e, i, n = t.element.parentNode;
                n && /pre/i.test(n.nodeName) && (n.parentNode.classList.contains("code-toolbar") || ((e = document.createElement("div")).classList.add("code-toolbar"),
                n.parentNode.insertBefore(e, n),
                e.appendChild(n),
                (i = document.createElement("div")).classList.add("toolbar"),
                (E = document.body.hasAttribute("data-toolbar-order") ? document.body.getAttribute("data-toolbar-order").split(",").map(function(t) {
                    return M[t] || O
                }) : E).forEach(function(e) {
                    var n;
                    (e = e(t)) && ((n = document.createElement("div")).classList.add("toolbar-item"),
                    n.appendChild(e),
                    i.appendChild(n))
                }),
                e.appendChild(i)))
            }
            ,
            D("label", function(t) {
                if ((t = t.element.parentNode) && /pre/i.test(t.nodeName) && t.hasAttribute("data-label")) {
                    var e, i, n = t.getAttribute("data-label");
                    try {
                        i = document.querySelector("template#" + n)
                    } catch (s) {}
                    return i ? e = i.content : (t.hasAttribute("data-url") ? (e = document.createElement("a")).href = t.getAttribute("data-url") : e = document.createElement("span"),
                    e.textContent = n),
                    e
                }
            }),
            B.hooks.add("complete", e)),
            ("undefined" == typeof self || self.Prism) && self.document && Function.prototype.bind) {
                var X, K, U = {
                    gradient: {
                        create: (X = {},
                        function() {
                            new B.plugins.Previewer("gradient",function(t) {
                                return this.firstChild.style.backgroundImage = "",
                                this.firstChild.style.backgroundImage = function(t) {
                                    var e, i, n, s, o, a, r, l;
                                    return X[t] || (o = (e = t.match(/^(\b|\B-[a-z]{1,10}-)((?:repeating-)?(?:linear|radial)-gradient)/)) && e[1],
                                    e = e && e[2],
                                    i = t.replace(/^(?:\b|\B-[a-z]{1,10}-)(?:repeating-)?(?:linear|radial)-gradient\(|\)$/g, "").split(/\s*,\s*/),
                                    0 <= e.indexOf("linear") ? X[t] = (a = e,
                                    l = "180deg",
                                    /^(?:-?\d*\.?\d+(?:deg|rad)|to\b|top|right|bottom|left)/.test((r = i)[0]) && (l = r.shift()).indexOf("to ") < 0 && (0 <= l.indexOf("top") ? l = 0 <= l.indexOf("left") ? "to bottom right" : 0 <= l.indexOf("right") ? "to bottom left" : "to bottom" : 0 <= l.indexOf("bottom") ? l = 0 <= l.indexOf("left") ? "to top right" : 0 <= l.indexOf("right") ? "to top left" : "to top" : 0 <= l.indexOf("left") ? l = "to right" : 0 <= l.indexOf("right") ? l = "to left" : o && (0 <= l.indexOf("deg") ? l = 90 - parseFloat(l) + "deg" : 0 <= l.indexOf("rad") && (l = Math.PI / 2 - parseFloat(l) + "rad"))),
                                    a + "(" + l + "," + r.join(",") + ")") : 0 <= e.indexOf("radial") ? X[t] = (o = e,
                                    (a = i)[0].indexOf("at") < 0 ? (l = "center",
                                    r = "ellipse",
                                    n = "farthest-corner",
                                    /\bcenter|top|right|bottom|left\b|^\d+/.test(a[0]) && (l = a.shift().replace(/\s*-?\d+(?:rad|deg)\s*/, "")),
                                    /\bcircle|ellipse|closest|farthest|contain|cover\b/.test(a[0]) && (!(s = a.shift().split(/\s+/))[0] || "circle" !== s[0] && "ellipse" !== s[0] || (r = s.shift()),
                                    "cover" === (n = s[0] ? s.shift() : n) ? n = "farthest-corner" : "contain" === n && (n = "clothest-side")),
                                    o + "(" + r + " " + n + " at " + l + "," + a.join(",") + ")") : o + "(" + a.join(",") + ")") : X[t] = e + "(" + i.join(",") + ")")
                                }(t),
                                !!this.firstChild.style.backgroundImage
                            }
                            ,"*",function() {
                                this._elt.innerHTML = "<div></div>"
                            }
                            )
                        }
                        ),
                        tokens: {
                            gradient: {
                                pattern: /(?:\b|\B-[a-z]{1,10}-)(?:repeating-)?(?:linear|radial)-gradient\((?:(?:rgb|hsl)a?\(.+?\)|[^\)])+\)/gi,
                                inside: {
                                    function: /[\w-]+(?=\()/,
                                    punctuation: /[(),]/
                                }
                            }
                        },
                        languages: {
                            css: !0,
                            less: !0,
                            sass: [{
                                lang: "sass",
                                before: "punctuation",
                                inside: "inside",
                                root: B.languages.sass && B.languages.sass["variable-line"]
                            }, {
                                lang: "sass",
                                before: "punctuation",
                                inside: "inside",
                                root: B.languages.sass && B.languages.sass["property-line"]
                            }],
                            scss: !0,
                            stylus: [{
                                lang: "stylus",
                                before: "func",
                                inside: "rest",
                                root: B.languages.stylus && B.languages.stylus["property-declaration"].inside
                            }, {
                                lang: "stylus",
                                before: "func",
                                inside: "rest",
                                root: B.languages.stylus && B.languages.stylus["variable-declaration"].inside
                            }]
                        }
                    },
                    angle: {
                        create: function() {
                            new B.plugins.Previewer("angle",function(t) {
                                var e, i = parseFloat(t);
                                t = t.match(/[a-z]+$/i);
                                if (!i || !t)
                                    return !1;
                                switch (t[0]) {
                                case "deg":
                                    e = 360;
                                    break;
                                case "grad":
                                    e = 400;
                                    break;
                                case "rad":
                                    e = 2 * Math.PI;
                                    break;
                                case "turn":
                                    e = 1
                                }
                                return t = 100 * i / e,
                                t %= 100,
                                this[(i < 0 ? "set" : "remove") + "Attribute"]("data-negative", ""),
                                this.querySelector("circle").style.strokeDasharray = Math.abs(t) + ",500",
                                !0
                            }
                            ,"*",function() {
                                this._elt.innerHTML = '<svg viewBox="0 0 64 64"><circle r="16" cy="32" cx="32"></circle></svg>'
                            }
                            )
                        },
                        tokens: {
                            angle: /(?:\b|\B-|(?=\B\.))\d*\.?\d+(?:deg|g?rad|turn)\b/i
                        },
                        languages: {
                            css: !0,
                            less: !0,
                            markup: {
                                lang: "markup",
                                before: "punctuation",
                                inside: "inside",
                                root: B.languages.markup && B.languages.markup.tag.inside["attr-value"]
                            },
                            sass: [{
                                lang: "sass",
                                inside: "inside",
                                root: B.languages.sass && B.languages.sass["property-line"]
                            }, {
                                lang: "sass",
                                before: "operator",
                                inside: "inside",
                                root: B.languages.sass && B.languages.sass["variable-line"]
                            }],
                            scss: !0,
                            stylus: [{
                                lang: "stylus",
                                before: "func",
                                inside: "rest",
                                root: B.languages.stylus && B.languages.stylus["property-declaration"].inside
                            }, {
                                lang: "stylus",
                                before: "func",
                                inside: "rest",
                                root: B.languages.stylus && B.languages.stylus["variable-declaration"].inside
                            }]
                        }
                    },
                    color: {
                        create: function() {
                            new B.plugins.Previewer("color",function(t) {
                                return this.style.backgroundColor = "",
                                this.style.backgroundColor = t,
                                !!this.style.backgroundColor
                            }
                            )
                        },
                        tokens: {
                            color: {
                                pattern: /\B#(?:[0-9a-f]{3}){1,2}\b|\b(?:rgb|hsl)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:rgb|hsl)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B|\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGray|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGray|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGray|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gray|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGray|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGray|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGray|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i,
                                inside: {
                                    function: /[\w-]+(?=\()/,
                                    punctuation: /[(),]/
                                }
                            }
                        },
                        languages: {
                            css: !0,
                            less: !0,
                            markup: {
                                lang: "markup",
                                before: "punctuation",
                                inside: "inside",
                                root: B.languages.markup && B.languages.markup.tag.inside["attr-value"]
                            },
                            sass: [{
                                lang: "sass",
                                before: "punctuation",
                                inside: "inside",
                                root: B.languages.sass && B.languages.sass["variable-line"]
                            }, {
                                lang: "sass",
                                inside: "inside",
                                root: B.languages.sass && B.languages.sass["property-line"]
                            }],
                            scss: !0,
                            stylus: [{
                                lang: "stylus",
                                before: "hexcode",
                                inside: "rest",
                                root: B.languages.stylus && B.languages.stylus["property-declaration"].inside
                            }, {
                                lang: "stylus",
                                before: "hexcode",
                                inside: "rest",
                                root: B.languages.stylus && B.languages.stylus["variable-declaration"].inside
                            }]
                        }
                    },
                    easing: {
                        create: function() {
                            new B.plugins.Previewer("easing",function(t) {
                                var e;
                                return 4 === (t = (t = {
                                    linear: "0,0,1,1",
                                    ease: ".25,.1,.25,1",
                                    "ease-in": ".42,0,1,1",
                                    "ease-out": "0,0,.58,1",
                                    "ease-in-out": ".42,0,.58,1"
                                }[t] || t).match(/-?\d*\.?\d+/g)).length && (t = t.map(function(t, e) {
                                    return 100 * (e % 2 ? 1 - t : t)
                                }),
                                this.querySelector("path").setAttribute("d", "M0,100 C" + t[0] + "," + t[1] + ", " + t[2] + "," + t[3] + ", 100,0"),
                                (e = this.querySelectorAll("line"))[0].setAttribute("x2", t[0]),
                                e[0].setAttribute("y2", t[1]),
                                e[1].setAttribute("x2", t[2]),
                                e[1].setAttribute("y2", t[3]),
                                !0)
                            }
                            ,"*",function() {
                                this._elt.innerHTML = '<svg viewBox="-20 -20 140 140" width="100" height="100"><defs><marker id="prism-previewer-easing-marker" viewBox="0 0 4 4" refX="2" refY="2" markerUnits="strokeWidth"><circle cx="2" cy="2" r="1.5" /></marker></defs><path d="M0,100 C20,50, 40,30, 100,0" /><line x1="0" y1="100" x2="20" y2="50" marker-start="url(' + location.href + '#prism-previewer-easing-marker)" marker-end="url(' + location.href + '#prism-previewer-easing-marker)" /><line x1="100" y1="0" x2="40" y2="30" marker-start="url(' + location.href + '#prism-previewer-easing-marker)" marker-end="url(' + location.href + '#prism-previewer-easing-marker)" /></svg>'
                            }
                            )
                        },
                        tokens: {
                            easing: {
                                pattern: /\bcubic-bezier\((?:-?\d*\.?\d+,\s*){3}-?\d*\.?\d+\)\B|\b(?:linear|ease(?:-in)?(?:-out)?)(?=\s|[;}]|$)/i,
                                inside: {
                                    function: /[\w-]+(?=\()/,
                                    punctuation: /[(),]/
                                }
                            }
                        },
                        languages: {
                            css: !0,
                            less: !0,
                            sass: [{
                                lang: "sass",
                                inside: "inside",
                                before: "punctuation",
                                root: B.languages.sass && B.languages.sass["variable-line"]
                            }, {
                                lang: "sass",
                                inside: "inside",
                                root: B.languages.sass && B.languages.sass["property-line"]
                            }],
                            scss: !0,
                            stylus: [{
                                lang: "stylus",
                                before: "hexcode",
                                inside: "rest",
                                root: B.languages.stylus && B.languages.stylus["property-declaration"].inside
                            }, {
                                lang: "stylus",
                                before: "hexcode",
                                inside: "rest",
                                root: B.languages.stylus && B.languages.stylus["variable-declaration"].inside
                            }]
                        }
                    },
                    time: {
                        create: function() {
                            new B.plugins.Previewer("time",function(t) {
                                var e = parseFloat(t);
                                t = t.match(/[a-z]+$/i);
                                return !(!e || !t || (t = t[0],
                                this.querySelector("circle").style.animationDuration = 2 * e + t,
                                0))
                            }
                            ,"*",function() {
                                this._elt.innerHTML = '<svg viewBox="0 0 64 64"><circle r="16" cy="32" cx="32"></circle></svg>'
                            }
                            )
                        },
                        tokens: {
                            time: /(?:\b|\B-|(?=\B\.))\d*\.?\d+m?s\b/i
                        },
                        languages: {
                            css: !0,
                            less: !0,
                            markup: {
                                lang: "markup",
                                before: "punctuation",
                                inside: "inside",
                                root: B.languages.markup && B.languages.markup.tag.inside["attr-value"]
                            },
                            sass: [{
                                lang: "sass",
                                inside: "inside",
                                root: B.languages.sass && B.languages.sass["property-line"]
                            }, {
                                lang: "sass",
                                before: "operator",
                                inside: "inside",
                                root: B.languages.sass && B.languages.sass["variable-line"]
                            }],
                            scss: !0,
                            stylus: [{
                                lang: "stylus",
                                before: "hexcode",
                                inside: "rest",
                                root: B.languages.stylus && B.languages.stylus["property-declaration"].inside
                            }, {
                                lang: "stylus",
                                before: "hexcode",
                                inside: "rest",
                                root: B.languages.stylus && B.languages.stylus["variable-declaration"].inside
                            }]
                        }
                    }
                }, q = /(?:^|\s)token(?=$|\s)/, Z = /(?:^|\s)active(?=$|\s)/g, G = /(?:^|\s)flipped(?=$|\s)/g, Q = function(t, e, i, n) {
                    this._elt = null,
                    this._type = t,
                    this._clsRegexp = RegExp("(?:^|\\s)" + t + "(?=$|\\s)"),
                    this._token = null,
                    this.updater = e,
                    this._mouseout = this.mouseout.bind(this),
                    this.initializer = n;
                    var s = this;
                    (i = "Array" !== B.util.type(i = i || ["*"]) ? [i] : i).forEach(function(t) {
                        "string" != typeof t && (t = t.lang),
                        Q.byLanguages[t] || (Q.byLanguages[t] = []),
                        Q.byLanguages[t].indexOf(s) < 0 && Q.byLanguages[t].push(s)
                    }),
                    Q.byType[t] = this
                };
                for (K in Q.prototype.init = function() {
                    this._elt || (this._elt = document.createElement("div"),
                    this._elt.className = "prism-previewer prism-previewer-" + this._type,
                    document.body.appendChild(this._elt),
                    this.initializer && this.initializer())
                }
                ,
                Q.prototype.isDisabled = function(t) {
                    do {
                        if (t.hasAttribute && t.hasAttribute("data-previewers"))
                            return -1 === (t.getAttribute("data-previewers") || "").split(/\s+/).indexOf(this._type)
                    } while (t = t.parentNode);
                    return !1
                }
                ,
                Q.prototype.check = function(t) {
                    if (!q.test(t.className) || !this.isDisabled(t)) {
                        do {
                            if (q.test(t.className) && this._clsRegexp.test(t.className))
                                break
                        } while (t = t.parentNode);
                        t && t !== this._token && (this._token = t,
                        this.show())
                    }
                }
                ,
                Q.prototype.mouseout = function() {
                    this._token.removeEventListener("mouseout", this._mouseout, !1),
                    this._token = null,
                    this.hide()
                }
                ,
                Q.prototype.show = function() {
                    var t;
                    this._elt || this.init(),
                    this._token && (this.updater.call(this._elt, this._token.textContent) ? (this._token.addEventListener("mouseout", this._mouseout, !1),
                    t = function(t) {
                        var e = 0
                          , i = 0
                          , n = t;
                        if (n.parentNode) {
                            for (; e += n.offsetLeft,
                            i += n.offsetTop,
                            (n = n.offsetParent) && n.nodeType < 9; )
                                ;
                            for (n = t; e -= n.scrollLeft,
                            i -= n.scrollTop,
                            (n = n.parentNode) && !/body/i.test(n.nodeName); )
                                ;
                        }
                        return {
                            top: i,
                            right: innerWidth - e - t.offsetWidth,
                            bottom: innerHeight - i - t.offsetHeight,
                            left: e
                        }
                    }(this._token),
                    this._elt.className += " active",
                    0 < t.top - this._elt.offsetHeight ? (this._elt.className = this._elt.className.replace(G, ""),
                    this._elt.style.top = t.top + "px",
                    this._elt.style.bottom = "") : (this._elt.className += " flipped",
                    this._elt.style.bottom = t.bottom + "px",
                    this._elt.style.top = ""),
                    this._elt.style.left = t.left + Math.min(200, this._token.offsetWidth / 2) + "px") : this.hide())
                }
                ,
                Q.prototype.hide = function() {
                    this._elt.className = this._elt.className.replace(Z, "")
                }
                ,
                Q.byLanguages = {},
                Q.byType = {},
                Q.initEvents = function(t, e) {
                    var i = [];
                    Q.byLanguages[e] && (i = i.concat(Q.byLanguages[e])),
                    Q.byLanguages["*"] && (i = i.concat(Q.byLanguages["*"])),
                    t.addEventListener("mouseover", function(t) {
                        var e = t.target;
                        i.forEach(function(t) {
                            t.check(e)
                        })
                    }, !1)
                }
                ,
                B.plugins.Previewer = Q,
                B.hooks.add("before-highlight", function(t) {
                    for (var e in U) {
                        var i, n = U[e].languages;
                        t.language && n[t.language] && !n[t.language].initialized && (i = n[t.language],
                        (i = "Array" !== B.util.type(i) ? [i] : i).forEach(function(i) {
                            var s, o, a, r;
                            !0 === i ? (s = "important",
                            o = t.language) : (s = i.before || "important",
                            o = i.inside || i.lang,
                            a = i.root || B.languages,
                            r = i.skip),
                            i = t.language,
                            !r && B.languages[i] && (B.languages.insertBefore(o, s, U[e].tokens, a),
                            t.grammar = B.languages[i],
                            n[t.language] = {
                                initialized: !0
                            })
                        }))
                    }
                }),
                B.hooks.add("after-highlight", function(t) {
                    (Q.byLanguages["*"] || Q.byLanguages[t.language]) && Q.initEvents(t.element, t.language)
                }),
                U)
                    U[K].create()
            }
            function J(t) {
                this.defaults = $({}, t)
            }
            function tt(t) {
                for (var e = 0, i = 0; i < t.length; ++i)
                    t.charCodeAt(i) == "\t".charCodeAt(0) && (e += 3);
                return t.length + e
            }
            $ = Object.assign || function(t, e) {
                for (var i in e)
                    e.hasOwnProperty(i) && (t[i] = e[i]);
                return t
            }
            ,
            J.prototype = {
                setDefaults: function(t) {
                    this.defaults = $(this.defaults, t)
                },
                normalize: function(t, e) {
                    for (var i in e = $(this.defaults, e)) {
                        var n = i.replace(/-(\w)/g, function(t, e) {
                            return e.toUpperCase()
                        });
                        "normalize" !== i && "setDefaults" !== n && e[i] && this[n] && (t = this[n].call(this, t, e[i]))
                    }
                    return t
                },
                leftTrim: function(t) {
                    return t.replace(/^\s+/, "")
                },
                rightTrim: function(t) {
                    return t.replace(/\s+$/, "")
                },
                tabsToSpaces: function(t, e) {
                    return e = 0 | e || 4,
                    t.replace(/\t/g, new Array(++e).join(" "))
                },
                spacesToTabs: function(t, e) {
                    return e = 0 | e || 4,
                    t.replace(new RegExp(" {" + e + "}","g"), "\t")
                },
                removeTrailing: function(t) {
                    return t.replace(/\s*?$/gm, "")
                },
                removeInitialLineFeed: function(t) {
                    return t.replace(/^(?:\r?\n|\r)/, "")
                },
                removeIndent: function(t) {
                    var e = t.match(/^[^\S\n\r]*(?=\S)/gm);
                    return e && e[0].length && (e.sort(function(t, e) {
                        return t.length - e.length
                    }),
                    e[0].length) ? t.replace(new RegExp("^" + e[0],"gm"), "") : t
                },
                indent: function(t, e) {
                    return t.replace(/^[^\S\n\r]*(?=\S)/gm, new Array(++e).join("\t") + "$&")
                },
                breakLines: function(t, e) {
                    e = !0 !== e && 0 | e || 80;
                    for (var i = t.split("\n"), n = 0; n < i.length; ++n)
                        if (!(tt(i[n]) <= e)) {
                            for (var s = i[n].split(/(\s+)/g), o = 0, a = 0; a < s.length; ++a) {
                                var r = tt(s[a]);
                                e < (o += r) && (s[a] = "\n" + s[a],
                                o = r)
                            }
                            i[n] = s.join("")
                        }
                    return i.join("\n")
                }
            },
            t.exports && (t.exports = J),
            void 0 !== B && (B.plugins.NormalizeWhitespace = new J({
                "remove-trailing": !0,
                "remove-indent": !0,
                "left-trim": !0,
                "right-trim": !0
            }),
            B.hooks.add("before-sanity-check", function(t) {
                var e = B.plugins.NormalizeWhitespace;
                if (!t.settings || !1 !== t.settings["whitespace-normalization"])
                    if (t.element && t.element.parentNode || !t.code) {
                        var i = t.element.parentNode
                          , n = /\bno-whitespace-normalization\b/;
                        if (t.code && i && "pre" === i.nodeName.toLowerCase() && !n.test(i.className) && !n.test(t.element.className)) {
                            for (var s = i.childNodes, o = "", a = "", r = !1, l = 0; l < s.length; ++l) {
                                var h = s[l];
                                h == t.element ? r = !0 : "#text" === h.nodeName && (r ? a += h.nodeValue : o += h.nodeValue,
                                i.removeChild(h),
                                --l)
                            }
                            t.element.children.length && B.plugins.KeepMarkup ? (n = o + t.element.innerHTML + a,
                            t.element.innerHTML = e.normalize(n, t.settings),
                            t.code = t.element.textContent) : (t.code = o + t.code + a,
                            t.code = e.normalize(t.code, t.settings))
                        }
                    } else
                        t.code = e.normalize(t.code, t.settings)
            })),
            "undefined" != typeof self && self.Prism && self.document && (B.plugins.toolbar ? (I = (I = window.ClipboardJS || void 0) || i(117),
            L = [],
            I || (P = document.createElement("script"),
            R = document.querySelector("head"),
            P.onload = function() {
                if (I = window.ClipboardJS)
                    for (; L.length; )
                        L.pop()()
            }
            ,
            P.src = "https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js",
            R.appendChild(P)),
            B.plugins.toolbar.registerButton("copy-to-clipboard", function(t) {
                var e = document.createElement("button");
                return e.innerHTML = "Copy",
                e.classList = "btn-copy-code btn btn-sm",
                e.setAttribute("data-mdb-ripple-color", "dark"),
                e.setAttribute("data-mdb-ripple-unbound", "true"),
                I ? i() : L.push(i),
                e;
                function i() {
                    var i = new I(e,{
                        text: function() {
                            return t.code
                        }
                    });
                    i.on("success", function() {
                        e.textContent = "Copied!",
                        n()
                    }),
                    i.on("error", function() {
                        e.textContent = "Press Ctrl+C to copy",
                        n()
                    })
                }
                function n() {
                    setTimeout(function() {
                        e.innerHTML = "Copy"
                    }, 5e3)
                }
            })) : console.warn("Copy to Clipboard plugin loaded before Toolbar plugin."))
        }
        .call(this, i(69)(t), i(36))
    }
    , function(t, e) {
        t.exports = function(t) {
            var e;
            return t.webpackPolyfill || ((e = Object.create(t)).children || (e.children = []),
            Object.defineProperty(e, "loaded", {
                enumerable: !0,
                get: function() {
                    return e.l
                }
            }),
            Object.defineProperty(e, "id", {
                enumerable: !0,
                get: function() {
                    return e.i
                }
            }),
            Object.defineProperty(e, "exports", {
                enumerable: !0
            }),
            e.webpackPolyfill = 1),
            e
        }
    }
    , function(t, e, i) {
        var n = {}.propertyIsEnumerable
          , s = Object.getOwnPropertyDescriptor
          , o = s && !n.call({
            1: 2
        }, 1);
        e.f = o ? function(t) {
            return !!(t = s(this, t)) && t.enumerable
        }
        : n
    }
    , function(t, e, i) {
        var n = i(1)
          , s = i(0)
          , o = i(12)
          , a = Object
          , r = n("".split);
        t.exports = s(function() {
            return !a("z").propertyIsEnumerable(0)
        }) ? function(t) {
            return "String" == o(t) ? r(t, "") : a(t)
        }
        : a
    }
    , function(t, e, i) {
        var n = i(8)
          , s = i(9)
          , o = i(40)
          , a = i(44)
          , r = i(73)
          , l = (i = i(6),
        TypeError)
          , h = i("toPrimitive");
        t.exports = function(t, e) {
            if (!s(t) || o(t))
                return t;
            var i = a(t, h);
            if (i) {
                if (i = n(i, t, e = void 0 === e ? "default" : e),
                !s(i) || o(i))
                    return i;
                throw l("Can't convert object to primitive value")
            }
            return r(t, e = void 0 === e ? "number" : e)
        }
    }
    , function(t, e, i) {
        var n = i(8)
          , s = i(2)
          , o = i(9)
          , a = TypeError;
        t.exports = function(t, e) {
            var i, r;
            if ("string" === e && s(i = t.toString) && !o(r = n(i, t)))
                return r;
            if (s(i = t.valueOf) && !o(r = n(i, t)))
                return r;
            if ("string" !== e && s(i = t.toString) && !o(r = n(i, t)))
                return r;
            throw a("Can't convert object to primitive value")
        }
    }
    , function(t, e) {
        t.exports = !1
    }
    , function(t, e, i) {
        var n = i(0)
          , s = i(2)
          , o = i(5)
          , a = i(4)
          , r = i(51).CONFIGURABLE
          , l = i(76)
          , h = (i = i(31)).enforce
          , c = i.get
          , d = Object.defineProperty
          , u = a && !n(function() {
            return 8 !== d(function() {}, "length", {
                value: 8
            }).length
        })
          , p = String(String).split("String");
        i = t.exports = function(t, e, i) {
            "Symbol(" === String(e).slice(0, 7) && (e = "[" + String(e).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"),
            i && i.getter && (e = "get " + e),
            i && i.setter && (e = "set " + e),
            (!o(t, "name") || r && t.name !== e) && (a ? d(t, "name", {
                value: e,
                configurable: !0
            }) : t.name = e),
            u && i && o(i, "arity") && t.length !== i.arity && d(t, "length", {
                value: i.arity
            });
            try {
                i && o(i, "constructor") && i.constructor ? a && d(t, "prototype", {
                    writable: !1
                }) : t.prototype && (t.prototype = void 0)
            } catch (n) {}
            return i = h(t),
            o(i, "source") || (i.source = p.join("string" == typeof e ? e : "")),
            t
        }
        ;
        Function.prototype.toString = i(function() {
            return s(this) && c(this).source || l(this)
        }, "toString")
    }
    , function(t, e, i) {
        var n = i(1)
          , s = i(2)
          , o = (i = i(27),
        n(Function.toString));
        s(i.inspectSource) || (i.inspectSource = function(t) {
            return o(t)
        }
        ),
        t.exports = i.inspectSource
    }
    , function(t, e, i) {
        var n = i(3);
        i = i(2),
        n = n.WeakMap;
        t.exports = i(n) && /native code/.test(String(n))
    }
    , function(t, e, i) {
        var n = i(5)
          , s = i(79)
          , o = i(38)
          , a = i(10);
        t.exports = function(t, e, i) {
            for (var r = s(e), l = a.f, h = o.f, c = 0; c < r.length; c++) {
                var d = r[c];
                n(t, d) || i && n(i, d) || l(t, d, h(e, d))
            }
        }
    }
    , function(t, e, i) {
        var n = i(14)
          , s = i(1)
          , o = i(53)
          , a = i(82)
          , r = i(7)
          , l = s([].concat);
        t.exports = n("Reflect", "ownKeys") || function(t) {
            var e = o.f(r(t))
              , i = a.f;
            return i ? l(e, i(t)) : e
        }
    }
    , function(t, e, i) {
        function n(t) {
            return function(e, i, n) {
                var r, l = s(e), h = a(l), c = o(n, h);
                if (t && i != i) {
                    for (; c < h; )
                        if ((r = l[c++]) != r)
                            return !0
                } else
                    for (; c < h; c++)
                        if ((t || c in l) && l[c] === i)
                            return t || c || 0;
                return !t && -1
            }
        }
        var s = i(15)
          , o = i(55)
          , a = i(33);
        t.exports = {
            includes: n(!0),
            indexOf: n(!1)
        }
    }
    , function(t, e) {
        var i = Math.ceil
          , n = Math.floor;
        t.exports = Math.trunc || function(t) {
            return (0 < (t = +t) ? n : i)(t)
        }
    }
    , function(t, e) {
        e.f = Object.getOwnPropertySymbols
    }
    , function(t, e, i) {
        var n = i(84)
          , s = i(2)
          , o = i(12)
          , a = i(6)("toStringTag")
          , r = Object
          , l = "Arguments" == o(function() {
            return arguments
        }());
        t.exports = n ? o : function(t) {
            var e;
            return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (e = function(t, e) {
                try {
                    return t[e]
                } catch (i) {}
            }(t = r(t), a)) ? e : l ? o(t) : "Object" == (e = o(t)) && s(t.callee) ? "Arguments" : e
        }
    }
    , function(t, e, i) {
        var n = {};
        n[i(6)("toStringTag")] = "z",
        t.exports = "[object z]" === String(n)
    }
    , function(t, e, i) {
        function n() {}
        var s, o = i(7), a = i(86), r = i(34), l = i(32), h = i(88), c = i(49), d = (i = i(52),
        "prototype"), u = "script", p = i("IE_PROTO"), f = function(t) {
            return "<" + u + ">" + t + "</" + u + ">"
        }, g = function() {
            try {
                s = new ActiveXObject("htmlfile")
            } catch (n) {}
            g = "undefined" == typeof document || document.domain && s ? function(t) {
                t.write(f("")),
                t.close();
                var e = t.parentWindow.Object;
                return t = null,
                e
            }(s) : (t = c("iframe"),
            e = "java" + u + ":",
            t.style.display = "none",
            h.appendChild(t),
            t.src = String(e),
            (e = t.contentWindow.document).open(),
            e.write(f("document.F=Object")),
            e.close(),
            e.F);
            for (var t, e, i = r.length; i--; )
                delete g[d][r[i]];
            return g()
        };
        l[p] = !0,
        t.exports = Object.create || function(t, e) {
            var i;
            return null !== t ? (n[d] = o(t),
            i = new n,
            n[d] = null,
            i[p] = t) : i = g(),
            void 0 === e ? i : a.f(i, e)
        }
    }
    , function(t, e, i) {
        var n = i(4)
          , s = i(50)
          , o = i(10)
          , a = i(7)
          , r = i(15)
          , l = i(87);
        e.f = n && !s ? Object.defineProperties : function(t, e) {
            a(t);
            for (var i, n = r(e), s = l(e), h = s.length, c = 0; c < h; )
                o.f(t, i = s[c++], n[i]);
            return t
        }
    }
    , function(t, e, i) {
        var n = i(54)
          , s = i(34);
        t.exports = Object.keys || function(t) {
            return n(t, s)
        }
    }
    , function(t, e, i) {
        i = i(14),
        t.exports = i("document", "documentElement")
    }
    , function(t, e, i) {
        var n = i(90)
          , s = i(8)
          , o = i(1)
          , a = i(91)
          , r = i(0)
          , l = i(7)
          , h = i(2)
          , c = i(23)
          , d = i(18)
          , u = i(56)
          , p = i(11)
          , f = i(13)
          , g = i(93)
          , m = i(44)
          , _ = i(95)
          , b = i(96)
          , v = i(6)("replace")
          , y = Math.max
          , x = Math.min
          , w = o([].concat)
          , C = o([].push)
          , k = o("".indexOf)
          , S = o("".slice)
          , T = (i = "$0" === "a".replace(/./, "$0"),
        !!/./[v] && "" === /./[v]("a", "$0"));
        a("replace", function(t, e, i) {
            var o = T ? "$" : "$0";
            return [function(t, i) {
                var n = f(this)
                  , o = c(t) ? void 0 : m(t, v);
                return o ? s(o, t, n, i) : s(e, p(n), t, i)
            }
            , function(t, s) {
                var a = l(this)
                  , r = p(t);
                if ("string" == typeof s && -1 === k(s, o) && -1 === k(s, "$<") && (t = i(e, a, r, s)).done)
                    return t.value;
                for (var c, f = h(s), m = (f || (s = p(s)),
                a.global), v = (m && (c = a.unicode,
                a.lastIndex = 0),
                []); null !== (O = b(a, r)) && (C(v, O),
                m); )
                    "" === p(O[0]) && (a.lastIndex = g(r, u(a.lastIndex), c));
                for (var T, A = "", E = 0, M = 0; M < v.length; M++) {
                    for (var O, D = p((O = v[M])[0]), $ = y(x(d(O.index), r.length), 0), I = [], L = 1; L < O.length; L++)
                        C(I, void 0 === (T = O[L]) ? T : String(T));
                    var P = O.groups
                      , R = f ? (R = w([D], I, $, r),
                    void 0 !== P && C(R, P),
                    p(n(s, void 0, R))) : _(D, r, $, I, P, s);
                    E <= $ && (A += S(r, E, $) + R,
                    E = $ + D.length)
                }
                return A + S(r, E)
            }
            ]
        }, !!r(function() {
            var t = /./;
            return t.exec = function() {
                var t = [];
                return t.groups = {
                    a: "7"
                },
                t
            }
            ,
            "7" !== "".replace(t, "$<a>")
        }) || !i || T)
    }
    , function(t, e, i) {
        i = i(21);
        var n = Function.prototype
          , s = n.apply
          , o = n.call;
        t.exports = "object" == typeof Reflect && Reflect.apply || (i ? o.bind(s) : function() {
            return o.apply(s, arguments)
        }
        )
    }
    , function(t, e, i) {
        i(37);
        var n = i(92)
          , s = i(30)
          , o = i(35)
          , a = i(0)
          , r = i(6)
          , l = i(17)
          , h = r("species")
          , c = RegExp.prototype;
        t.exports = function(t, e, i, d) {
            var u, p = r(t), f = !a(function() {
                var e = {};
                return e[p] = function() {
                    return 7
                }
                ,
                7 != ""[t](e)
            }), g = f && !a(function() {
                var e = !1
                  , i = /a/;
                return "split" === t && ((i = {
                    constructor: {}
                }).constructor[h] = function() {
                    return i
                }
                ,
                i.flags = "",
                i[p] = /./[p]),
                i.exec = function() {
                    return e = !0,
                    null
                }
                ,
                i[p](""),
                !e
            });
            f && g && !i || (u = n(/./[p]),
            g = e(p, ""[t], function(t, e, i, s, a) {
                t = n(t);
                var r = e.exec;
                return r === o || r === c.exec ? f && !a ? {
                    done: !0,
                    value: u(e, i, s)
                } : {
                    done: !0,
                    value: t(i, e, s)
                } : {
                    done: !1
                }
            }),
            s(String.prototype, t, g[0]),
            s(c, p, g[1])),
            d && l(c[p], "sham", !0)
        }
    }
    , function(t, e, i) {
        var n = i(12)
          , s = i(1);
        t.exports = function(t) {
            if ("Function" === n(t))
                return s(t)
        }
    }
    , function(t, e, i) {
        var n = i(94).charAt;
        t.exports = function(t, e, i) {
            return e + (i ? n(t, e).length : 1)
        }
    }
    , function(t, e, i) {
        function n(t) {
            return function(e, i) {
                e = a(r(e)),
                i = o(i);
                var n, s = e.length;
                return i < 0 || s <= i ? t ? "" : void 0 : (n = h(e, i)) < 55296 || 56319 < n || i + 1 === s || (s = h(e, i + 1)) < 56320 || 57343 < s ? t ? l(e, i) : n : t ? c(e, i, i + 2) : s - 56320 + (n - 55296 << 10) + 65536
            }
        }
        var s = i(1)
          , o = i(18)
          , a = i(11)
          , r = i(13)
          , l = s("".charAt)
          , h = s("".charCodeAt)
          , c = s("".slice);
        t.exports = {
            codeAt: n(!1),
            charAt: n(!0)
        }
    }
    , function(t, e, i) {
        var n = i(1)
          , s = i(29)
          , o = Math.floor
          , a = n("".charAt)
          , r = n("".replace)
          , l = n("".slice)
          , h = /\$([$&'`]|\d{1,2}|<[^>]*>)/g
          , c = /\$([$&'`]|\d{1,2})/g;
        t.exports = function(t, e, i, n, d, u) {
            var p = i + t.length
              , f = n.length
              , g = c;
            return void 0 !== d && (d = s(d),
            g = h),
            r(u, g, function(s, r) {
                var h;
                switch (a(r, 0)) {
                case "$":
                    return "$";
                case "&":
                    return t;
                case "`":
                    return l(e, 0, i);
                case "'":
                    return l(e, p);
                case "<":
                    h = d[l(r, 1, -1)];
                    break;
                default:
                    var c, u = +r;
                    if (0 == u)
                        return s;
                    if (f < u)
                        return 0 !== (c = o(u / 10)) && c <= f ? void 0 === n[c - 1] ? a(r, 1) : n[c - 1] + a(r, 1) : s;
                    h = n[u - 1]
                }
                return void 0 === h ? "" : h
            })
        }
    }
    , function(t, e, i) {
        var n = i(8)
          , s = i(7)
          , o = i(2)
          , a = i(12)
          , r = i(35)
          , l = TypeError;
        t.exports = function(t, e) {
            var i = t.exec;
            if (o(i))
                return null !== (i = n(i, t, e)) && s(i),
                i;
            if ("RegExp" === a(t))
                return n(r, t, e);
            throw l("RegExp#exec called on incompatible receiver")
        }
    }
    , function(t, e, i) {
        var n = i(4)
          , s = i(3)
          , o = i(1)
          , a = i(57)
          , r = i(98)
          , l = i(17)
          , h = i(53).f
          , c = i(25)
          , d = i(101)
          , u = i(11)
          , p = i(102)
          , f = i(59)
          , g = i(103)
          , m = i(30)
          , _ = i(0)
          , b = i(5)
          , v = i(31).enforce
          , y = i(104)
          , x = i(6)
          , w = i(60)
          , C = i(61)
          , k = x("match")
          , S = s.RegExp
          , T = S.prototype
          , A = s.SyntaxError
          , E = o(T.exec)
          , M = o("".charAt)
          , O = o("".replace)
          , D = o("".indexOf)
          , $ = o("".slice)
          , I = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/
          , L = /a/g
          , P = /a/g
          , R = (i = new S(L) !== L,
        f.MISSED_STICKY)
          , N = f.UNSUPPORTED_Y;
        if (a("RegExp", x = n && (!i || R || w || C || _(function() {
            return P[k] = !1,
            S(L) != L || S(P) == P || "/a/i" != S(L, "i")
        })))) {
            let t = function(e, i) {
                var n, s, o = c(T, this), a = d(e), h = void 0 === i, f = [], g = e;
                if (!o && a && h && e.constructor === t)
                    return e;
                if ((a || c(T, e)) && (e = e.source,
                h) && (i = p(g)),
                e = void 0 === e ? "" : u(e),
                i = void 0 === i ? "" : u(i),
                g = e,
                a = i = w && "dotAll"in L && (n = !!i && -1 < D(i, "s")) ? O(i, /s/g, "") : i,
                R && "sticky"in L && (s = !!i && -1 < D(i, "y")) && N && (i = O(i, /y/g, "")),
                C && (e = (h = function(t) {
                    for (var e, i = t.length, n = 0, s = "", o = [], a = {}, r = !1, l = !1, h = 0, c = ""; n <= i; n++) {
                        if ("\\" === (e = M(t, n)))
                            e += M(t, ++n);
                        else if ("]" === e)
                            r = !1;
                        else if (!r)
                            switch (!0) {
                            case "[" === e:
                                r = !0;
                                break;
                            case "(" === e:
                                E(I, $(t, n + 1)) && (n += 2,
                                l = !0),
                                s += e,
                                h++;
                                continue;
                            case ">" === e && l:
                                if ("" === c || b(a, c))
                                    throw new A("Invalid capture group name");
                                a[c] = !0,
                                l = !(o[o.length] = [c, h]),
                                c = "";
                                continue
                            }
                        l ? c += e : s += e
                    }
                    return [s, o]
                }(e))[0],
                f = h[1]),
                h = r(S(e, i), o ? this : T, t),
                (n || s || f.length) && (i = v(h),
                n && (i.dotAll = !0,
                i.raw = t(function(t) {
                    for (var e, i = t.length, n = 0, s = "", o = !1; n <= i; n++)
                        "\\" === (e = M(t, n)) ? s += e + M(t, ++n) : o || "." !== e ? ("[" === e ? o = !0 : "]" === e && (o = !1),
                        s += e) : s += "[\\s\\S]";
                    return s
                }(e), a)),
                s && (i.sticky = !0),
                f.length) && (i.groups = f),
                e !== g)
                    try {
                        l(h, "source", "" === g ? "(?:)" : g)
                    } catch (m) {}
                return h
            };
            for (var B = h(S), H = 0; B.length > H; )
                g(t, S, B[H++]);
            (T.constructor = t).prototype = T,
            m(s, "RegExp", t, {
                constructor: !0
            })
        }
        y("RegExp")
    }
    , function(t, e, i) {
        var n = i(2)
          , s = i(9)
          , o = i(99);
        t.exports = function(t, e, i) {
            return o && n(e = e.constructor) && e !== i && s(e = e.prototype) && e !== i.prototype && o(t, e),
            t
        }
    }
    , function(t, e, i) {
        var n = i(1)
          , s = i(7)
          , o = i(100);
        t.exports = Object.setPrototypeOf || ("__proto__"in {} ? function() {
            var t, e = !1, i = {};
            try {
                (t = n(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(i, []),
                e = i instanceof Array
            } catch (a) {}
            return function(i, n) {
                return s(i),
                o(n),
                e ? t(i, n) : i.__proto__ = n,
                i
            }
        }() : void 0)
    }
    , function(t, e, i) {
        var n = i(2)
          , s = String
          , o = TypeError;
        t.exports = function(t) {
            if ("object" == typeof t || n(t))
                return t;
            throw o("Can't set " + s(t) + " as a prototype")
        }
    }
    , function(t, e, i) {
        var n = i(9)
          , s = i(12)
          , o = i(6)("match");
        t.exports = function(t) {
            var e;
            return n(t) && (void 0 !== (e = t[o]) ? !!e : "RegExp" == s(t))
        }
    }
    , function(t, e, i) {
        var n = i(8)
          , s = i(5)
          , o = i(25)
          , a = i(58)
          , r = RegExp.prototype;
        t.exports = function(t) {
            var e = t.flags;
            return void 0 !== e || "flags"in r || s(t, "flags") || !o(r, t) ? e : n(a, t)
        }
    }
    , function(t, e, i) {
        var n = i(10).f;
        t.exports = function(t, e, i) {
            i in t || n(t, i, {
                configurable: !0,
                get: function() {
                    return e[i]
                },
                set: function(t) {
                    e[i] = t
                }
            })
        }
    }
    , function(t, e, i) {
        var n = i(14)
          , s = i(10)
          , o = i(6)
          , a = i(4)
          , r = o("species");
        t.exports = function(t) {
            t = n(t);
            var e = s.f;
            a && t && !t[r] && e(t, r, {
                configurable: !0,
                get: function() {
                    return this
                }
            })
        }
    }
    , function(t, e, i) {
        var n = i(20)
          , s = i(106).trim;
        n({
            target: "String",
            proto: !0,
            forced: i(107)("trim")
        }, {
            trim: function() {
                return s(this)
            }
        })
    }
    , function(t, e, i) {
        function n(t) {
            return function(e) {
                return e = a(o(e)),
                1 & t && (e = r(e, l, "")),
                2 & t ? r(e, h, "") : e
            }
        }
        var s = i(1)
          , o = i(13)
          , a = i(11)
          , r = (i = i(62),
        s("".replace))
          , l = (s = "[" + i + "]",
        RegExp("^" + s + s + "*"))
          , h = RegExp(s + s + "*$");
        t.exports = {
            start: n(1),
            end: n(2),
            trim: n(3)
        }
    }
    , function(t, e, i) {
        var n = i(51).PROPER
          , s = i(0)
          , o = i(62);
        t.exports = function(t) {
            return s(function() {
                return !!o[t]() || "â€‹Â…á Ž" !== "â€‹Â…á Ž"[t]() || n && o[t].name !== t
            })
        }
    }
    , function(t, e, i) {
        var n = i(20)
          , s = i(1)
          , o = i(45)
          , a = i(29)
          , r = i(33)
          , l = i(109)
          , h = i(11)
          , c = i(0)
          , d = i(110)
          , u = i(113)
          , p = i(114)
          , f = i(115)
          , g = i(43)
          , m = i(116)
          , _ = []
          , b = s(_.sort)
          , v = s(_.push)
          , y = (i = c(function() {
            _.sort(void 0)
        }),
        s = c(function() {
            _.sort(null)
        }),
        u = u("sort"),
        !c(function() {
            if (g)
                return g < 70;
            if (!(p && 3 < p)) {
                if (f)
                    return !0;
                if (m)
                    return m < 603;
                for (var t, e, i, n = "", s = 65; s < 76; s++) {
                    switch (t = String.fromCharCode(s),
                    s) {
                    case 66:
                    case 69:
                    case 70:
                    case 72:
                        e = 3;
                        break;
                    case 68:
                    case 71:
                        e = 4;
                        break;
                    default:
                        e = 2
                    }
                    for (i = 0; i < 47; i++)
                        _.push({
                            k: t + i,
                            v: e
                        })
                }
                for (_.sort(function(t, e) {
                    return e.v - t.v
                }),
                i = 0; i < _.length; i++)
                    t = _[i].k.charAt(0),
                    n.charAt(n.length - 1) !== t && (n += t);
                return "DGBEFHACIJK" !== n
            }
        }));
        n({
            target: "Array",
            proto: !0,
            forced: i || !s || !u || !y
        }, {
            sort: function(t) {
                void 0 !== t && o(t);
                var e = a(this);
                if (y)
                    return void 0 === t ? b(e) : b(e, t);
                for (var i, n, s = [], c = r(e), u = 0; u < c; u++)
                    u in e && v(s, e[u]);
                for (d(s, (n = t,
                function(t, e) {
                    return void 0 === e ? -1 : void 0 === t ? 1 : void 0 !== n ? +n(t, e) || 0 : h(t) > h(e) ? 1 : -1
                }
                )),
                i = r(s),
                u = 0; u < i; )
                    e[u] = s[u++];
                for (; u < c; )
                    l(e, u++);
                return e
            }
        })
    }
    , function(t, e, i) {
        var n = i(46)
          , s = TypeError;
        t.exports = function(t, e) {
            if (!delete t[e])
                throw s("Cannot delete property " + n(e) + " of " + n(t))
        }
    }
    , function(t, e, i) {
        var n = i(111)
          , s = Math.floor;
        t.exports = function t(e, i) {
            var o = e.length
              , a = s(o / 2);
            if (o < 8) {
                for (var r, l, h = e, c = i, d = h.length, u = 1; u < d; ) {
                    for (r = h[l = u]; l && 0 < c(h[l - 1], r); )
                        h[l] = h[--l];
                    l !== u++ && (h[l] = r)
                }
                return h
            }
            for (var p = e, f = t(n(e, 0, a), i), g = t(n(e, a), i), m = i, _ = f.length, b = g.length, v = 0, y = 0; v < _ || y < b; )
                p[v + y] = v < _ && y < b ? m(f[v], g[y]) <= 0 ? f[v++] : g[y++] : v < _ ? f[v++] : g[y++];
            return p
        }
    }
    , function(t, e, i) {
        var n = i(55)
          , s = i(33)
          , o = i(112)
          , a = Array
          , r = Math.max;
        t.exports = function(t, e, i) {
            for (var l = s(t), h = n(e, l), c = n(void 0 === i ? l : i, l), d = a(r(c - h, 0)), u = 0; h < c; h++,
            u++)
                o(d, u, t[h]);
            return d.length = u,
            d
        }
    }
    , function(t, e, i) {
        var n = i(24)
          , s = i(10)
          , o = i(22);
        t.exports = function(t, e, i) {
            (e = n(e))in t ? s.f(t, e, o(0, i)) : t[e] = i
        }
    }
    , function(t, e, i) {
        var n = i(0);
        t.exports = function(t, e) {
            var i = [][t];
            return !!i && n(function() {
                i.call(null, e || function() {
                    return 1
                }
                , 1)
            })
        }
    }
    , function(t, e, i) {
        i = i(16).match(/firefox\/(\d+)/i),
        t.exports = !!i && +i[1]
    }
    , function(t, e, i) {
        i = i(16),
        t.exports = /MSIE|Trident/.test(i)
    }
    , function(t, e, i) {
        i = i(16).match(/AppleWebKit\/(\d+)\./),
        t.exports = !!i && +i[1]
    }
    , function(t, e, i) {
        /*!
       * clipboard.js v2.0.11
       * https://clipboardjs.com/
       *
       * Licensed MIT Â© Zeno Rocha
       */
        var n;
        n = function() {
            return e = {
                686: function(t, e, i) {
                    i.d(e, {
                        default: function() {
                            return m
                        }
                    });
                    e = i(279),
                    e = i.n(e);
                    var n = i(370)
                      , s = i.n(n)
                      , o = (n = i(817),
                    i.n(n));
                    function a(t) {
                        try {
                            document.execCommand(t)
                        } catch (e) {}
                    }
                    var r = function(t) {
                        return t = o()(t),
                        a("cut"),
                        t
                    };
                    function l(t, e) {
                        n = "rtl" === document.documentElement.getAttribute("dir"),
                        (i = document.createElement("textarea")).style.fontSize = "12pt",
                        i.style.border = "0",
                        i.style.padding = "0",
                        i.style.margin = "0",
                        i.style.position = "absolute",
                        i.style[n ? "right" : "left"] = "-9999px",
                        n = window.pageYOffset || document.documentElement.scrollTop,
                        i.style.top = "".concat(n, "px"),
                        i.setAttribute("readonly", ""),
                        i.value = t;
                        var i, n = i;
                        e.container.appendChild(n),
                        t = o()(n);
                        return a("copy"),
                        n.remove(),
                        t
                    }
                    var h = function(t) {
                        var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {
                            container: document.body
                        }
                          , i = "";
                        return "string" == typeof t ? i = l(t, e) : t instanceof HTMLInputElement && !["text", "search", "url", "tel", "password"].includes(null == t ? void 0 : t.type) ? i = l(t.value, e) : (i = o()(t),
                        a("copy")),
                        i
                    };
                    function c(t) {
                        return (c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                            return typeof t
                        }
                        : function(t) {
                            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                        }
                        )(t)
                    }
                    function d(t) {
                        return (d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                            return typeof t
                        }
                        : function(t) {
                            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                        }
                        )(t)
                    }
                    function u(t, e) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1,
                            n.configurable = !0,
                            "value"in n && (n.writable = !0),
                            Object.defineProperty(t, n.key, n)
                        }
                    }
                    function p(t, e) {
                        return (p = Object.setPrototypeOf || function(t, e) {
                            return t.__proto__ = e,
                            t
                        }
                        )(t, e)
                    }
                    function f(t) {
                        return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                            return t.__proto__ || Object.getPrototypeOf(t)
                        }
                        )(t)
                    }
                    function g(t, e) {
                        if (t = "data-clipboard-".concat(t),
                        e.hasAttribute(t))
                            return e.getAttribute(t)
                    }
                    var m = function(t) {
                        var e = o;
                        if ("function" != typeof t && null !== t)
                            throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }),
                        t && p(e, t);
                        var i, n = function(e) {
                            var i = function() {
                                if ("undefined" == typeof Reflect || !Reflect.construct)
                                    return !1;
                                if (Reflect.construct.sham)
                                    return !1;
                                if ("function" == typeof Proxy)
                                    return !0;
                                try {
                                    return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})),
                                    !0
                                } catch (t) {
                                    return !1
                                }
                            }();
                            return function() {
                                var t, n = f(e);
                                if (t = i ? (t = f(this).constructor,
                                Reflect.construct(n, arguments, t)) : n.apply(this, arguments),
                                n = this,
                                !t || "object" !== d(t) && "function" != typeof t) {
                                    if (void 0 !== n)
                                        return n;
                                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
                                }
                                return t
                            }
                        }(o);
                        function o(t, e) {
                            var i;
                            if (this instanceof o)
                                return (i = n.call(this)).resolveOptions(e),
                                i.listenClick(t),
                                i;
                            throw new TypeError("Cannot call a class as a function")
                        }
                        return e = o,
                        t = [{
                            key: "copy",
                            value: function(t) {
                                var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {
                                    container: document.body
                                };
                                return h(t, e)
                            }
                        }, {
                            key: "cut",
                            value: function(t) {
                                return r(t)
                            }
                        }, {
                            key: "isSupported",
                            value: function() {
                                var t = "string" == typeof (t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : ["copy", "cut"]) ? [t] : t
                                  , e = !!document.queryCommandSupported;
                                return t.forEach(function(t) {
                                    e = e && !!document.queryCommandSupported(t)
                                }),
                                e
                            }
                        }],
                        (i = [{
                            key: "resolveOptions",
                            value: function() {
                                var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
                                this.action = "function" == typeof t.action ? t.action : this.defaultAction,
                                this.target = "function" == typeof t.target ? t.target : this.defaultTarget,
                                this.text = "function" == typeof t.text ? t.text : this.defaultText,
                                this.container = "object" === d(t.container) ? t.container : document.body
                            }
                        }, {
                            key: "listenClick",
                            value: function(t) {
                                var e = this;
                                this.listener = s()(t, "click", function(t) {
                                    return e.onClick(t)
                                })
                            }
                        }, {
                            key: "onClick",
                            value: function(t) {
                                var e = t.delegateTarget || t.currentTarget
                                  , i = function() {
                                    var t = void 0 === (t = (n = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}).action) ? "copy" : t
                                      , e = n.container
                                      , i = n.target
                                      , n = n.text;
                                    if ("copy" !== t && "cut" !== t)
                                        throw new Error('Invalid "action" value, use either "copy" or "cut"');
                                    if (void 0 !== i) {
                                        if (!i || "object" !== c(i) || 1 !== i.nodeType)
                                            throw new Error('Invalid "target" value, use a valid Element');
                                        if ("copy" === t && i.hasAttribute("disabled"))
                                            throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                                        if ("cut" === t && (i.hasAttribute("readonly") || i.hasAttribute("disabled")))
                                            throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes')
                                    }
                                    return n ? h(n, {
                                        container: e
                                    }) : i ? "cut" === t ? r(i) : h(i, {
                                        container: e
                                    }) : void 0
                                }({
                                    action: t = this.action(e) || "copy",
                                    container: this.container,
                                    target: this.target(e),
                                    text: this.text(e)
                                });
                                this.emit(i ? "success" : "error", {
                                    action: t,
                                    text: i,
                                    trigger: e,
                                    clearSelection: function() {
                                        e && e.focus(),
                                        window.getSelection().removeAllRanges()
                                    }
                                })
                            }
                        }, {
                            key: "defaultAction",
                            value: function(t) {
                                return g("action", t)
                            }
                        }, {
                            key: "defaultTarget",
                            value: function(t) {
                                if (t = g("target", t))
                                    return document.querySelector(t)
                            }
                        }, {
                            key: "defaultText",
                            value: function(t) {
                                return g("text", t)
                            }
                        }, {
                            key: "destroy",
                            value: function() {
                                this.listener.destroy()
                            }
                        }]) && u(e.prototype, i),
                        t && u(e, t),
                        o
                    }(e())
                },
                828: function(t) {
                    var e;
                    "undefined" == typeof Element || Element.prototype.matches || ((e = Element.prototype).matches = e.matchesSelector || e.mozMatchesSelector || e.msMatchesSelector || e.oMatchesSelector || e.webkitMatchesSelector),
                    t.exports = function(t, e) {
                        for (; t && 9 !== t.nodeType; ) {
                            if ("function" == typeof t.matches && t.matches(e))
                                return t;
                            t = t.parentNode
                        }
                    }
                },
                438: function(t, e, i) {
                    var n = i(828);
                    function s(t, e, i, s, o) {
                        var a = function(t, e, i, s) {
                            return function(i) {
                                i.delegateTarget = n(i.target, e),
                                i.delegateTarget && s.call(t, i)
                            }
                        }
                        .apply(this, arguments);
                        return t.addEventListener(i, a, o),
                        {
                            destroy: function() {
                                t.removeEventListener(i, a, o)
                            }
                        }
                    }
                    t.exports = function(t, e, i, n, o) {
                        return "function" == typeof t.addEventListener ? s.apply(null, arguments) : "function" == typeof i ? s.bind(null, document).apply(null, arguments) : ("string" == typeof t && (t = document.querySelectorAll(t)),
                        Array.prototype.map.call(t, function(t) {
                            return s(t, e, i, n, o)
                        }))
                    }
                },
                879: function(t, e) {
                    e.node = function(t) {
                        return void 0 !== t && t instanceof HTMLElement && 1 === t.nodeType
                    }
                    ,
                    e.nodeList = function(t) {
                        var i = Object.prototype.toString.call(t);
                        return void 0 !== t && ("[object NodeList]" === i || "[object HTMLCollection]" === i) && "length"in t && (0 === t.length || e.node(t[0]))
                    }
                    ,
                    e.string = function(t) {
                        return "string" == typeof t || t instanceof String
                    }
                    ,
                    e.fn = function(t) {
                        return "[object Function]" === Object.prototype.toString.call(t)
                    }
                },
                370: function(t, e, i) {
                    var n = i(879)
                      , s = i(438);
                    t.exports = function(t, e, i) {
                        if (!t && !e && !i)
                            throw new Error("Missing required arguments");
                        if (!n.string(e))
                            throw new TypeError("Second argument must be a String");
                        if (!n.fn(i))
                            throw new TypeError("Third argument must be a Function");
                        if (n.node(t))
                            return h = e,
                            c = i,
                            (l = t).addEventListener(h, c),
                            {
                                destroy: function() {
                                    l.removeEventListener(h, c)
                                }
                            };
                        if (n.nodeList(t))
                            return o = t,
                            a = e,
                            r = i,
                            Array.prototype.forEach.call(o, function(t) {
                                t.addEventListener(a, r)
                            }),
                            {
                                destroy: function() {
                                    Array.prototype.forEach.call(o, function(t) {
                                        t.removeEventListener(a, r)
                                    })
                                }
                            };
                        if (n.string(t))
                            return s(document.body, t, e, i);
                        throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
                        var o, a, r, l, h, c
                    }
                },
                817: function(t) {
                    t.exports = function(t) {
                        var e, i;
                        return "SELECT" === t.nodeName ? (t.focus(),
                        t.value) : "INPUT" === t.nodeName || "TEXTAREA" === t.nodeName ? ((e = t.hasAttribute("readonly")) || t.setAttribute("readonly", ""),
                        t.select(),
                        t.setSelectionRange(0, t.value.length),
                        e || t.removeAttribute("readonly"),
                        t.value) : (t.hasAttribute("contenteditable") && t.focus(),
                        e = window.getSelection(),
                        (i = document.createRange()).selectNodeContents(t),
                        e.removeAllRanges(),
                        e.addRange(i),
                        e.toString())
                    }
                },
                279: function(t) {
                    function e() {}
                    e.prototype = {
                        on: function(t, e, i) {
                            var n = this.e || (this.e = {});
                            return (n[t] || (n[t] = [])).push({
                                fn: e,
                                ctx: i
                            }),
                            this
                        },
                        once: function(t, e, i) {
                            var n = this;
                            function s() {
                                n.off(t, s),
                                e.apply(i, arguments)
                            }
                            return s._ = e,
                            this.on(t, s, i)
                        },
                        emit: function(t) {
                            for (var e = [].slice.call(arguments, 1), i = ((this.e || (this.e = {}))[t] || []).slice(), n = 0, s = i.length; n < s; n++)
                                i[n].fn.apply(i[n].ctx, e);
                            return this
                        },
                        off: function(t, e) {
                            var i = this.e || (this.e = {})
                              , n = i[t]
                              , s = [];
                            if (n && e)
                                for (var o = 0, a = n.length; o < a; o++)
                                    n[o].fn !== e && n[o].fn._ !== e && s.push(n[o]);
                            return s.length ? i[t] = s : delete i[t],
                            this
                        }
                    },
                    t.exports = e,
                    t.exports.TinyEmitter = e
                }
            },
            i = {},
            t.n = function(e) {
                var i = e && e.__esModule ? function() {
                    return e.default
                }
                : function() {
                    return e
                }
                ;
                return t.d(i, {
                    a: i
                }),
                i
            }
            ,
            t.d = function(e, i) {
                for (var n in i)
                    t.o(i, n) && !t.o(e, n) && Object.defineProperty(e, n, {
                        enumerable: !0,
                        get: i[n]
                    })
            }
            ,
            t.o = function(t, e) {
                return Object.prototype.hasOwnProperty.call(t, e)
            }
            ,
            t(686).default;
            function t(n) {
                var s;
                return (i[n] || (s = i[n] = {
                    exports: {}
                },
                e[n](s, s.exports, t),
                s)).exports
            }
            var e, i
        }
        ,
        t.exports = n()
    }
    ]),
    true;
    const n = ( () => {
        const t = {};
        let e = 1;
        return {
            set(i, n, s) {
                void 0 === i[n] && (i[n] = {
                    key: n,
                    id: e
                },
                e++),
                t[i[n].id] = s
            },
            get(e, i) {
                if (!e || void 0 === e[i])
                    return null;
                const n = e[i];
                return n.key === i ? t[n.id] : null
            },
            delete(e, i) {
                if (void 0 === e[i])
                    return;
                const n = e[i];
                n.key === i && (delete t[n.id],
                delete e[i])
            }
        }
    }
    )()
      , s = {
        setData(t, e, i) {
            n.set(t, e, i)
        },
        getData: (t, e) => n.get(t, e),
        removeData(t, e) {
            n.delete(t, e)
        }
    }
      , o = t => {
        do {
            t += Math.floor(1e6 * Math.random())
        } while (document.getElementById(t));
        return t
    }
      , a = t => {
        let e = t.getAttribute("data-mdb-target");
        if (!e || "#" === e) {
            const i = t.getAttribute("href");
            e = i && "#" !== i ? i.trim() : null
        }
        return e
    }
      , r = t => {
        const e = a(t);
        return e && document.querySelector(e) ? e : null
    }
      , l = t => {
        const e = a(t);
        return e ? document.querySelector(e) : null
    }
      , h = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]),
    void 0 !== t.nodeType)
      , c = t => h(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(t) : null
      , d = (t, e, i) => {
        Object.keys(i).forEach(n => {
            const s = i[n]
              , o = e[n]
              , a = o && h(o) ? "element" : null == (r = o) ? `${r}` : {}.toString.call(r).match(/\s([a-z]+)/i)[1].toLowerCase();
            var r;
            if (!new RegExp(s).test(a))
                throw new Error(`${t.toUpperCase()}: Option "${n}" provided type "${a}" but expected type "${s}".`)
        }
        )
    }
      , u = t => {
        if (!t)
            return !1;
        if (t.style && t.parentNode && t.parentNode.style) {
            const e = getComputedStyle(t)
              , i = getComputedStyle(t.parentNode);
            return "none" !== e.display && "none" !== i.display && "hidden" !== e.visibility
        }
        return !1
    }
      , p = t => !t || t.nodeType !== Node.ELEMENT_NODE || (!!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")))
      , f = () => {
        const {jQuery: t} = window;
        return t && !document.body.hasAttribute("data-mdb-no-jquery") ? t : null
    }
      , g = t => {
        "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", t) : t()
    }
      , m = "rtl" === document.documentElement.dir
      , _ = t => document.createElement(t)
      , b = t => {
        g( () => {
            const e = f();
            if (e) {
                const i = t.NAME
                  , n = e.fn[i];
                e.fn[i] = t.jQueryInterface,
                e.fn[i].Constructor = t,
                e.fn[i].noConflict = () => (e.fn[i] = n,
                t.jQueryInterface)
            }
        }
        )
    }
      , v = f()
      , y = /[^.]*(?=\..*)\.|.*/
      , x = /\..*/
      , w = /::\d+$/
      , C = {};
    let k = 1;
    const S = {
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }
      , T = ["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"];
    function A(t, e) {
        return e && `${e}::${k++}` || t.uidEvent || k++
    }
    function E(t) {
        const e = A(t);
        return t.uidEvent = e,
        C[e] = C[e] || {},
        C[e]
    }
    function M(t, e, i=null) {
        const n = Object.keys(t);
        for (let s = 0, o = n.length; s < o; s++) {
            const o = t[n[s]];
            if (o.originalHandler === e && o.delegationSelector === i)
                return o
        }
        return null
    }
    function O(t, e, i) {
        const n = "string" == typeof e
          , s = n ? i : e;
        let o = t.replace(x, "");
        const a = S[o];
        a && (o = a);
        return T.indexOf(o) > -1 || (o = t),
        [n, s, o]
    }
    function D(t, e, i, n, s) {
        if ("string" != typeof e || !t)
            return;
        i || (i = n,
        n = null);
        const [o,a,r] = O(e, i, n)
          , l = E(t)
          , h = l[r] || (l[r] = {})
          , c = M(h, a, o ? i : null);
        if (c)
            return void (c.oneOff = c.oneOff && s);
        const d = A(a, e.replace(y, ""))
          , u = o ? function(t, e, i) {
            return function n(s) {
                const o = t.querySelectorAll(e);
                for (let {target: e} = s; e && e !== this; e = e.parentNode)
                    for (let a = o.length; a--; "")
                        if (o[a] === e)
                            return s.delegateTarget = e,
                            n.oneOff && I.off(t, s.type, i),
                            i.apply(e, [s]);
                return null
            }
        }(t, i, n) : function(t, e) {
            return function i(n) {
                return n.delegateTarget = t,
                i.oneOff && I.off(t, n.type, e),
                e.apply(t, [n])
            }
        }(t, i);
        u.delegationSelector = o ? i : null,
        u.originalHandler = a,
        u.oneOff = s,
        u.uidEvent = d,
        h[d] = u,
        t.addEventListener(r, u, o)
    }
    function $(t, e, i, n, s) {
        const o = M(e[i], n, s);
        o && (t.removeEventListener(i, o, Boolean(s)),
        delete e[i][o.uidEvent])
    }
    const I = {
        on(t, e, i, n) {
            D(t, e, i, n, !1)
        },
        one(t, e, i, n) {
            D(t, e, i, n, !0)
        },
        extend(t, e, i) {
            e.forEach(e => {
                I.on(t, `${e.name}.bs.${i}`, n => {
                    const s = {};
                    e.parametersToCopy && e.parametersToCopy.forEach(t => {
                        s[t] = n[t]
                    }
                    );
                    I.trigger(t, `${e.name}.mdb.${i}`, s).defaultPrevented && n.preventDefault()
                }
                )
            }
            )
        },
        off(t, e, i, n) {
            if ("string" != typeof e || !t)
                return;
            const [s,o,a] = O(e, i, n)
              , r = a !== e
              , l = E(t)
              , h = "." === e.charAt(0);
            if (void 0 !== o) {
                if (!l || !l[a])
                    return;
                return void $(t, l, a, o, s ? i : null)
            }
            h && Object.keys(l).forEach(i => {
                !function(t, e, i, n) {
                    const s = e[i] || {};
                    Object.keys(s).forEach(o => {
                        if (o.indexOf(n) > -1) {
                            const n = s[o];
                            $(t, e, i, n.originalHandler, n.delegationSelector)
                        }
                    }
                    )
                }(t, l, i, e.slice(1))
            }
            );
            const c = l[a] || {};
            Object.keys(c).forEach(i => {
                const n = i.replace(w, "");
                if (!r || e.indexOf(n) > -1) {
                    const e = c[i];
                    $(t, l, a, e.originalHandler, e.delegationSelector)
                }
            }
            )
        },
        trigger(t, e, i) {
            if ("string" != typeof e || !t)
                return null;
            const n = e.replace(x, "")
              , s = e !== n
              , o = T.indexOf(n) > -1;
            let a, r = !0, l = !0, h = !1, c = null;
            return s && v && (a = v.Event(e, i),
            v(t).trigger(a),
            r = !a.isPropagationStopped(),
            l = !a.isImmediatePropagationStopped(),
            h = a.isDefaultPrevented()),
            o ? (c = document.createEvent("HTMLEvents"),
            c.initEvent(n, r, !0)) : c = new CustomEvent(e,{
                bubbles: r,
                cancelable: !0
            }),
            void 0 !== i && Object.keys(i).forEach(t => {
                Object.defineProperty(c, t, {
                    get: () => i[t]
                })
            }
            ),
            h && c.preventDefault(),
            l && t.dispatchEvent(c),
            c.defaultPrevented && void 0 !== a && a.preventDefault(),
            c
        }
    }
      , L = {
        on(t, e, i, n) {
            const s = e.split(" ");
            for (let o = 0; o < s.length; o++)
                I.on(t, s[o], i, n)
        },
        off(t, e, i, n) {
            const s = e.split(" ");
            for (let o = 0; o < s.length; o++)
                I.off(t, s[o], i, n)
        }
    };
    function P(t) {
        return "true" === t || "false" !== t && (t === Number(t).toString() ? Number(t) : "" === t || "null" === t ? null : t)
    }
    function R(t) {
        return t.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`)
    }
    const N = {
        setDataAttribute(t, e, i) {
            t.setAttribute(`data-mdb-${R(e)}`, i)
        },
        removeDataAttribute(t, e) {
            t.removeAttribute(`data-mdb-${R(e)}`)
        },
        getDataAttributes(t) {
            if (!t)
                return {};
            const e = {
                ...t.dataset
            };
            return Object.keys(e).filter(t => t.startsWith("mdb")).forEach(t => {
                let i = t.replace(/^mdb/, "");
                i = i.charAt(0).toLowerCase() + i.slice(1, i.length),
                e[i] = P(e[t])
            }
            ),
            e
        },
        getDataAttribute: (t, e) => P(t.getAttribute(`data-mdb-${R(e)}`)),
        offset(t) {
            const e = t.getBoundingClientRect();
            return {
                top: e.top + document.body.scrollTop,
                left: e.left + document.body.scrollLeft
            }
        },
        position: t => ({
            top: t.offsetTop,
            left: t.offsetLeft
        }),
        style(t, e) {
            Object.assign(t.style, e)
        },
        toggleClass(t, e) {
            t && (t.classList.contains(e) ? t.classList.remove(e) : t.classList.add(e))
        },
        addClass(t, e) {
            t.classList.contains(e) || t.classList.add(e)
        },
        addStyle(t, e) {
            Object.keys(e).forEach(i => {
                t.style[i] = e[i]
            }
            )
        },
        removeClass(t, e) {
            t.classList.contains(e) && t.classList.remove(e)
        },
        hasClass: (t, e) => t.classList.contains(e)
    }
      , B = {
        closest: (t, e) => t.closest(e),
        matches: (t, e) => t.matches(e),
        find: (t, e=document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),
        findOne: (t, e=document.documentElement) => Element.prototype.querySelector.call(e, t),
        children: (t, e) => [].concat(...t.children).filter(t => t.matches(e)),
        parents(t, e) {
            const i = [];
            let n = t.parentNode;
            for (; n && n.nodeType === Node.ELEMENT_NODE && 3 !== n.nodeType; )
                this.matches(n, e) && i.push(n),
                n = n.parentNode;
            return i
        },
        prev(t, e) {
            let i = t.previousElementSibling;
            for (; i; ) {
                if (i.matches(e))
                    return [i];
                i = i.previousElementSibling
            }
            return []
        },
        next(t, e) {
            let i = t.nextElementSibling;
            for (; i; ) {
                if (this.matches(i, e))
                    return [i];
                i = i.nextElementSibling
            }
            return []
        }
    }
      , H = new Map
      , F = {
        set(t, e, i) {
            H.has(t) || H.set(t, new Map);
            const n = H.get(t);
            n.has(e) || 0 === n.size ? n.set(e, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`)
        },
        get: (t, e) => H.has(t) && H.get(t).get(e) || null,
        remove(t, e) {
            if (!H.has(t))
                return;
            const i = H.get(t);
            i.delete(e),
            0 === i.size && H.delete(t)
        }
    }
      , z = "transitionend"
      , j = t => (t && window.CSS && window.CSS.escape && (t = t.replace(/#([^\s"#']+)/g, (t, e) => `#${CSS.escape(e)}`)),
    t)
      , W = t => null == t ? `${t}` : Object.prototype.toString.call(t).match(/\s([a-z]+)/i)[1].toLowerCase()
      , V = t => {
        t.dispatchEvent(new Event(z))
    }
      , Y = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]),
    void 0 !== t.nodeType)
      , X = t => Y(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(j(t)) : null
      , K = t => {
        if (!Y(t) || 0 === t.getClientRects().length)
            return !1;
        const e = "visible" === getComputedStyle(t).getPropertyValue("visibility")
          , i = t.closest("details:not([open])");
        if (!i)
            return e;
        if (i !== t) {
            const e = t.closest("summary");
            if (e && e.parentNode !== i)
                return !1;
            if (null === e)
                return !1
        }
        return e
    }
      , U = t => !t || t.nodeType !== Node.ELEMENT_NODE || (!!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")))
      , q = t => {
        if (!document.documentElement.attachShadow)
            return null;
        if ("function" == typeof t.getRootNode) {
            const e = t.getRootNode();
            return e instanceof ShadowRoot ? e : null
        }
        return t instanceof ShadowRoot ? t : t.parentNode ? q(t.parentNode) : null
    }
      , Z = () => {}
      , G = t => {
        t.offsetHeight
    }
      , Q = () => "rtl" === document.documentElement.dir
      , J = (t, e=[], i=t) => "function" == typeof t ? t(...e) : i
      , tt = (t, e, i=!0) => {
        if (!i)
            return void J(t);
        const n = (t => {
            if (!t)
                return 0;
            let {transitionDuration: e, transitionDelay: i} = window.getComputedStyle(t);
            const n = Number.parseFloat(e)
              , s = Number.parseFloat(i);
            return n || s ? (e = e.split(",")[0],
            i = i.split(",")[0],
            1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0
        }
        )(e) + 5;
        let s = !1;
        const o = ({target: i}) => {
            i === e && (s = !0,
            e.removeEventListener(z, o),
            J(t))
        }
        ;
        e.addEventListener(z, o),
        setTimeout( () => {
            s || V(e)
        }
        , n)
    }
      , et = (t, e, i, n) => {
        const s = t.length;
        let o = t.indexOf(e);
        return -1 === o ? !i && n ? t[s - 1] : t[0] : (o += i ? 1 : -1,
        n && (o = (o + s) % s),
        t[Math.max(0, Math.min(o, s - 1))])
    }
      , it = /[^.]*(?=\..*)\.|.*/
      , nt = /\..*/
      , st = /::\d+$/
      , ot = {};
    let at = 1;
    const rt = {
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }
      , lt = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
    function ht(t, e) {
        return e && `${e}::${at++}` || t.uidEvent || at++
    }
    function ct(t) {
        const e = ht(t);
        return t.uidEvent = e,
        ot[e] = ot[e] || {},
        ot[e]
    }
    function dt(t, e, i=null) {
        return Object.values(t).find(t => t.callable === e && t.delegationSelector === i)
    }
    function ut(t, e, i) {
        const n = "string" == typeof e
          , s = n ? i : e || i;
        let o = mt(t);
        return lt.has(o) || (o = t),
        [n, s, o]
    }
    function pt(t, e, i, n, s) {
        if ("string" != typeof e || !t)
            return;
        let[o,a,r] = ut(e, i, n);
        if (e in rt) {
            a = (t => function(e) {
                if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget))
                    return t.call(this, e)
            }
            )(a)
        }
        const l = ct(t)
          , h = l[r] || (l[r] = {})
          , c = dt(h, a, o ? i : null);
        if (c)
            return void (c.oneOff = c.oneOff && s);
        const d = ht(a, e.replace(it, ""))
          , u = o ? function(t, e, i) {
            return function n(s) {
                const o = t.querySelectorAll(e);
                for (let {target: a} = s; a && a !== this; a = a.parentNode)
                    for (const r of o)
                        if (r === a)
                            return bt(s, {
                                delegateTarget: a
                            }),
                            n.oneOff && _t.off(t, s.type, e, i),
                            i.apply(a, [s])
            }
        }(t, i, a) : function(t, e) {
            return function i(n) {
                return bt(n, {
                    delegateTarget: t
                }),
                i.oneOff && _t.off(t, n.type, e),
                e.apply(t, [n])
            }
        }(t, a);
        u.delegationSelector = o ? i : null,
        u.callable = a,
        u.oneOff = s,
        u.uidEvent = d,
        h[d] = u,
        t.addEventListener(r, u, o)
    }
    function ft(t, e, i, n, s) {
        const o = dt(e[i], n, s);
        o && (t.removeEventListener(i, o, Boolean(s)),
        delete e[i][o.uidEvent])
    }
    function gt(t, e, i, n) {
        const s = e[i] || {};
        for (const [o,a] of Object.entries(s))
            o.includes(n) && ft(t, e, i, a.callable, a.delegationSelector)
    }
    function mt(t) {
        return t = t.replace(nt, ""),
        rt[t] || t
    }
    const _t = {
        on(t, e, i, n) {
            pt(t, e, i, n, !1)
        },
        one(t, e, i, n) {
            pt(t, e, i, n, !0)
        },
        off(t, e, i, n) {
            if ("string" != typeof e || !t)
                return;
            const [s,o,a] = ut(e, i, n)
              , r = a !== e
              , l = ct(t)
              , h = l[a] || {}
              , c = e.startsWith(".");
            if (void 0 === o) {
                if (c)
                    for (const i of Object.keys(l))
                        gt(t, l, i, e.slice(1));
                for (const [i,n] of Object.entries(h)) {
                    const s = i.replace(st, "");
                    r && !e.includes(s) || ft(t, l, a, n.callable, n.delegationSelector)
                }
            } else {
                if (!Object.keys(h).length)
                    return;
                ft(t, l, a, o, s ? i : null)
            }
        },
        trigger(t, e, i) {
            if ("string" != typeof e || !t)
                return null;
            const n = window.jQuery && !document.body.hasAttribute("data-mdb-no-jquery") ? window.jQuery : null;
            let s = null
              , o = !0
              , a = !0
              , r = !1;
            e !== mt(e) && n && (s = n.Event(e, i),
            n(t).trigger(s),
            o = !s.isPropagationStopped(),
            a = !s.isImmediatePropagationStopped(),
            r = s.isDefaultPrevented());
            const l = bt(new Event(e,{
                bubbles: o,
                cancelable: !0
            }), i);
            return r && l.preventDefault(),
            a && t.dispatchEvent(l),
            l.defaultPrevented && s && s.preventDefault(),
            l
        }
    };
    function bt(t, e={}) {
        for (const [i,n] of Object.entries(e))
            try {
                t[i] = n
            } catch {
                Object.defineProperty(t, i, {
                    configurable: !0,
                    get: () => n
                })
            }
        return t
    }
    function vt(t) {
        if ("true" === t)
            return !0;
        if ("false" === t)
            return !1;
        if (t === Number(t).toString())
            return Number(t);
        if ("" === t || "null" === t)
            return null;
        if ("string" != typeof t)
            return t;
        try {
            return JSON.parse(decodeURIComponent(t))
        } catch {
            return t
        }
    }
    function yt(t) {
        return t.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`)
    }
    const xt = {
        setDataAttribute(t, e, i) {
            t.setAttribute(`data-mdb-${yt(e)}`, i)
        },
        removeDataAttribute(t, e) {
            t.removeAttribute(`data-mdb-${yt(e)}`)
        },
        getDataAttributes(t) {
            if (!t)
                return {};
            const e = {}
              , i = Object.keys(t.dataset).filter(t => t.startsWith("mdb") && !t.startsWith("mdbConfig"));
            for (const n of i) {
                let i = n.replace(/^mdb/, "");
                i = i.charAt(0).toLowerCase() + i.slice(1, i.length),
                e[i] = vt(t.dataset[n])
            }
            return e
        },
        getDataAttribute: (t, e) => vt(t.getAttribute(`data-mdb-${yt(e)}`))
    };
    let wt = class {
        static get Default() {
            return {}
        }
        static get DefaultType() {
            return {}
        }
        static get NAME() {
            throw new Error('You have to implement the static method "NAME", for each component!')
        }
        _getConfig(t) {
            return t = this._mergeConfigObj(t),
            t = this._configAfterMerge(t),
            this._typeCheckConfig(t),
            t
        }
        _configAfterMerge(t) {
            return t
        }
        _mergeConfigObj(t, e) {
            const i = Y(e) ? xt.getDataAttribute(e, "config") : {};
            return {
                ...this.constructor.Default,
                ..."object" == typeof i ? i : {},
                ...Y(e) ? xt.getDataAttributes(e) : {},
                ..."object" == typeof t ? t : {}
            }
        }
        _typeCheckConfig(t, e=this.constructor.DefaultType) {
            for (const [i,n] of Object.entries(e)) {
                const e = t[i]
                  , s = Y(e) ? "element" : W(e);
                if (!new RegExp(n).test(s))
                    throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${i}" provided type "${s}" but expected type "${n}".`)
            }
        }
    }
    ;
    let Ct = class extends wt {
        constructor(t, e) {
            super(),
            (t = X(t)) && (this._element = t,
            this._config = this._getConfig(e),
            F.set(this._element, this.constructor.DATA_KEY, this))
        }
        dispose() {
            F.remove(this._element, this.constructor.DATA_KEY),
            _t.off(this._element, this.constructor.EVENT_KEY);
            for (const t of Object.getOwnPropertyNames(this))
                this[t] = null
        }
        _queueCallback(t, e, i=!0) {
            tt(t, e, i)
        }
        _getConfig(t) {
            return t = this._mergeConfigObj(t, this._element),
            t = this._configAfterMerge(t),
            this._typeCheckConfig(t),
            t
        }
        static getInstance(t) {
            return F.get(X(t), this.DATA_KEY)
        }
        static getOrCreateInstance(t, e={}) {
            return this.getInstance(t) || new this(t,"object" == typeof e ? e : null)
        }
        static get VERSION() {
            return "5.3.3"
        }
        static get DATA_KEY() {
            return `bs.${this.NAME}`
        }
        static get EVENT_KEY() {
            return `.${this.DATA_KEY}`
        }
        static eventName(t) {
            return `${t}${this.EVENT_KEY}`
        }
    }
    ;
    let kt = class t extends Ct {
        static get NAME() {
            return "button"
        }
        toggle() {
            this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
        }
        static jQueryInterface(e) {
            return this.each(function() {
                const i = t.getOrCreateInstance(this);
                "toggle" === e && i[e]()
            })
        }
    }
    ;
    const St = ( () => {
        const t = [];
        return {
            set(e) {
                t.push(e)
            },
            get: e => t.includes(e)
        }
    }
    )()
      , Tt = {
        set(t) {
            St.set(t)
        },
        get: t => St.get(t)
    }
      , At = t => {
        if (e = t.NAME,
        !Tt.get(e)) {
            Et(t, !0)
        }
        var e
    }
      , Et = (t, e=!1) => {
        if (!t || Tt.get(t.NAME))
            return;
        e || Tt.set(t.NAME);
        const i = Mt[t.NAME] || null
          , n = (null == i ? void 0 : i.isToggler) || !1;
        b(t),
        (null == i ? void 0 : i.advanced) ? i.advanced(t, null == i ? void 0 : i.selector) : n ? i.callback(t, null == i ? void 0 : i.selector) : e || B.find(null == i ? void 0 : i.selector).forEach(e => {
            let n = t.getInstance(e);
            n || (n = new t(e),
            (null == i ? void 0 : i.onInit) && n[i.onInit]())
        }
        )
    }
    ;
    let Mt;
    const Ot = "button"
      , Dt = `mdb.${Ot}`
      , $t = `.${Dt}`
      , It = `click${$t}`
      , Lt = "transitionend"
      , Pt = "mouseenter"
      , Rt = "mouseleave"
      , Nt = `hide${$t}`
      , Bt = `hidden${$t}`
      , Ht = `show${$t}`
      , Ft = `shown${$t}`
      , zt = "active"
      , jt = "fixed-action-btn";
    class Wt extends kt {
        constructor(t) {
            super(t),
            this._fn = {},
            this._element && (s.setData(this._element, Dt, this),
            this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor))
        }
        static get NAME() {
            return Ot
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                let i = s.getData(this, Dt);
                const n = "object" == typeof t && t;
                if ((i || !/dispose/.test(t)) && (i || (i = new Wt(this,n)),
                "string" == typeof t)) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
        get _actionButton() {
            return B.findOne(".fixed-action-btn:not(.smooth-scroll) > .btn-floating", this._element)
        }
        get _buttonListElements() {
            return B.find("ul .btn", this._element)
        }
        get _buttonList() {
            return B.findOne("ul", this._element)
        }
        get _isTouchDevice() {
            return "ontouchstart"in document.documentElement
        }
        show() {
            N.hasClass(this._element, jt) && (I.off(this._buttonList, Lt),
            I.trigger(this._element, Ht),
            this._bindListOpenTransitionEnd(),
            N.addStyle(this._element, {
                height: `${this._fullContainerHeight}px`
            }),
            this._toggleVisibility(!0))
        }
        hide() {
            N.hasClass(this._element, jt) && (I.off(this._buttonList, Lt),
            I.trigger(this._element, Nt),
            this._bindListHideTransitionEnd(),
            this._toggleVisibility(!1))
        }
        dispose() {
            N.hasClass(this._element, jt) && (I.off(this._actionButton, It),
            this._actionButton.removeEventListener(Pt, this._fn.mouseenter),
            this._element.removeEventListener(Rt, this._fn.mouseleave)),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _init() {
            N.hasClass(this._element, jt) && (this._saveInitialHeights(),
            this._setInitialStyles(),
            this._bindInitialEvents())
        }
        _bindMouseEnter() {
            this._actionButton.addEventListener(Pt, this._fn.mouseenter = () => {
                this._isTouchDevice || this.show()
            }
            )
        }
        _bindMouseLeave() {
            this._element.addEventListener(Rt, this._fn.mouseleave = () => {
                this.hide()
            }
            )
        }
        _bindClick() {
            I.on(this._actionButton, It, () => {
                N.hasClass(this._element, zt) ? this.hide() : this.show()
            }
            )
        }
        _bindListHideTransitionEnd() {
            I.on(this._buttonList, Lt, t => {
                "transform" === t.propertyName && (I.off(this._buttonList, Lt),
                this._element.style.height = `${this._initialContainerHeight}px`,
                I.trigger(this._element, Bt))
            }
            )
        }
        _bindListOpenTransitionEnd() {
            I.on(this._buttonList, Lt, t => {
                "transform" === t.propertyName && (I.off(this._buttonList, Lt),
                I.trigger(this._element, Ft))
            }
            )
        }
        _toggleVisibility(t) {
            const e = t ? "addClass" : "removeClass"
              , i = t ? "translate(0)" : `translateY(${this._fullContainerHeight}px)`;
            N.addStyle(this._buttonList, {
                transform: i
            }),
            this._buttonListElements && this._buttonListElements.forEach(t => N[e](t, "shown")),
            N[e](this._element, zt)
        }
        _getHeight(t) {
            const e = window.getComputedStyle(t);
            return parseFloat(e.getPropertyValue("height"))
        }
        _saveInitialHeights() {
            this._initialContainerHeight = this._getHeight(this._element),
            this._initialListHeight = this._getHeight(this._buttonList),
            this._fullContainerHeight = this._initialContainerHeight + this._initialListHeight
        }
        _bindInitialEvents() {
            this._bindClick(),
            this._bindMouseEnter(),
            this._bindMouseLeave()
        }
        _setInitialStyles() {
            this._buttonList.style.marginBottom = `${this._initialContainerHeight}px`,
            this._buttonList.style.transform = `translateY(${this._fullContainerHeight}px)`,
            this._element.style.height = `${this._initialContainerHeight}px`
        }
    }
    const Vt = t => {
        let e = t.getAttribute("data-mdb-target");
        if (!e || "#" === e) {
            let i = t.getAttribute("href");
            if (!i || !i.includes("#") && !i.startsWith("."))
                return null;
            i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`),
            e = i && "#" !== i ? i.trim() : null
        }
        return e ? e.split(",").map(t => j(t)).join(",") : null
    }
      , Yt = {
        find: (t, e=document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),
        findOne: (t, e=document.documentElement) => Element.prototype.querySelector.call(e, t),
        children: (t, e) => [].concat(...t.children).filter(t => t.matches(e)),
        parents(t, e) {
            const i = [];
            let n = t.parentNode.closest(e);
            for (; n; )
                i.push(n),
                n = n.parentNode.closest(e);
            return i
        },
        prev(t, e) {
            let i = t.previousElementSibling;
            for (; i; ) {
                if (i.matches(e))
                    return [i];
                i = i.previousElementSibling
            }
            return []
        },
        next(t, e) {
            let i = t.nextElementSibling;
            for (; i; ) {
                if (i.matches(e))
                    return [i];
                i = i.nextElementSibling
            }
            return []
        },
        focusableChildren(t) {
            const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(t => `${t}:not([tabindex^="-"])`).join(",");
            return this.find(e, t).filter(t => !U(t) && K(t))
        },
        getSelectorFromElement(t) {
            const e = Vt(t);
            return e && Yt.findOne(e) ? e : null
        },
        getElementFromSelector(t) {
            const e = Vt(t);
            return e ? Yt.findOne(e) : null
        },
        getMultipleElementsFromSelector(t) {
            const e = Vt(t);
            return e ? Yt.find(e) : []
        }
    }
      , Xt = "backdrop"
      , Kt = "show"
      , Ut = `mousedown.bs.${Xt}`
      , qt = {
        className: "modal-backdrop",
        clickCallback: null,
        isAnimated: !1,
        isVisible: !0,
        rootElement: "body"
    }
      , Zt = {
        className: "string",
        clickCallback: "(function|null)",
        isAnimated: "boolean",
        isVisible: "boolean",
        rootElement: "(element|string)"
    };
    class Gt extends wt {
        constructor(t) {
            super(),
            this._config = this._getConfig(t),
            this._isAppended = !1,
            this._element = null
        }
        static get Default() {
            return qt
        }
        static get DefaultType() {
            return Zt
        }
        static get NAME() {
            return Xt
        }
        show(t) {
            if (!this._config.isVisible)
                return void J(t);
            this._append();
            const e = this._getElement();
            this._config.isAnimated && G(e),
            e.classList.add(Kt),
            this._emulateAnimation( () => {
                J(t)
            }
            )
        }
        hide(t) {
            this._config.isVisible ? (this._getElement().classList.remove(Kt),
            this._emulateAnimation( () => {
                this.dispose(),
                J(t)
            }
            )) : J(t)
        }
        dispose() {
            this._isAppended && (_t.off(this._element, Ut),
            this._element.remove(),
            this._isAppended = !1)
        }
        _getElement() {
            if (!this._element) {
                const t = document.createElement("div");
                t.className = this._config.className,
                this._config.isAnimated && t.classList.add("fade"),
                this._element = t
            }
            return this._element
        }
        _configAfterMerge(t) {
            return t.rootElement = X(t.rootElement),
            t
        }
        _append() {
            if (this._isAppended)
                return;
            const t = this._getElement();
            this._config.rootElement.append(t),
            _t.on(t, Ut, () => {
                J(this._config.clickCallback)
            }
            ),
            this._isAppended = !0
        }
        _emulateAnimation(t) {
            tt(t, this._getElement(), this._config.isAnimated)
        }
    }
    const Qt = (t, e="hide") => {
        const i = `click.dismiss${t.EVENT_KEY}`
          , n = t.NAME;
        _t.on(document, i, `[data-mdb-dismiss="${n}"]`, function(i) {
            if (["A", "AREA"].includes(this.tagName) && i.preventDefault(),
            U(this))
                return;
            const s = Yt.getElementFromSelector(this) || this.closest(`.${n}`);
            t.getOrCreateInstance(s)[e]()
        })
    }
      , Jt = ".bs.focustrap"
      , te = `focusin${Jt}`
      , ee = `keydown.tab${Jt}`
      , ie = "backward"
      , ne = {
        autofocus: !0,
        trapElement: null
    }
      , se = {
        autofocus: "boolean",
        trapElement: "element"
    };
    let oe = class extends wt {
        constructor(t) {
            super(),
            this._config = this._getConfig(t),
            this._isActive = !1,
            this._lastTabNavDirection = null
        }
        static get Default() {
            return ne
        }
        static get DefaultType() {
            return se
        }
        static get NAME() {
            return "focustrap"
        }
        activate() {
            this._isActive || (this._config.autofocus && this._config.trapElement.focus(),
            _t.off(document, Jt),
            _t.on(document, te, t => this._handleFocusin(t)),
            _t.on(document, ee, t => this._handleKeydown(t)),
            this._isActive = !0)
        }
        deactivate() {
            this._isActive && (this._isActive = !1,
            _t.off(document, Jt))
        }
        _handleFocusin(t) {
            const {trapElement: e} = this._config;
            if (t.target === document || t.target === e || e.contains(t.target))
                return;
            const i = Yt.focusableChildren(e);
            0 === i.length ? e.focus() : this._lastTabNavDirection === ie ? i[i.length - 1].focus() : i[0].focus()
        }
        _handleKeydown(t) {
            "Tab" === t.key && (this._lastTabNavDirection = t.shiftKey ? ie : "forward")
        }
    }
    ;
    const ae = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top"
      , re = ".sticky-top"
      , le = "padding-right"
      , he = "margin-right";
    class ce {
        constructor() {
            this._element = document.body
        }
        getWidth() {
            const t = document.documentElement.clientWidth;
            return Math.abs(window.innerWidth - t)
        }
        hide() {
            const t = this.getWidth();
            this._disableOverFlow(),
            this._setElementAttributes(this._element, le, e => e + t),
            this._setElementAttributes(ae, le, e => e + t),
            this._setElementAttributes(re, he, e => e - t)
        }
        reset() {
            this._resetElementAttributes(this._element, "overflow"),
            this._resetElementAttributes(this._element, le),
            this._resetElementAttributes(ae, le),
            this._resetElementAttributes(re, he)
        }
        isOverflowing() {
            return this.getWidth() > 0
        }
        _disableOverFlow() {
            this._saveInitialAttribute(this._element, "overflow"),
            this._element.style.overflow = "hidden"
        }
        _setElementAttributes(t, e, i) {
            const n = this.getWidth();
            this._applyManipulationCallback(t, t => {
                if (t !== this._element && window.innerWidth > t.clientWidth + n)
                    return;
                this._saveInitialAttribute(t, e);
                const s = window.getComputedStyle(t).getPropertyValue(e);
                t.style.setProperty(e, `${i(Number.parseFloat(s))}px`)
            }
            )
        }
        _saveInitialAttribute(t, e) {
            const i = t.style.getPropertyValue(e);
            i && xt.setDataAttribute(t, e, i)
        }
        _resetElementAttributes(t, e) {
            this._applyManipulationCallback(t, t => {
                const i = xt.getDataAttribute(t, e);
                null !== i ? (xt.removeDataAttribute(t, e),
                t.style.setProperty(e, i)) : t.style.removeProperty(e)
            }
            )
        }
        _applyManipulationCallback(t, e) {
            if (Y(t))
                e(t);
            else
                for (const i of Yt.find(t, this._element))
                    e(i)
        }
    }
    const de = ".bs.offcanvas"
      , ue = "show"
      , pe = "showing"
      , fe = "hiding"
      , ge = `show${de}`
      , me = `shown${de}`
      , _e = `hide${de}`
      , be = `hidePrevented${de}`
      , ve = `hidden${de}`
      , ye = `keydown.dismiss${de}`
      , xe = {
        backdrop: !0,
        keyboard: !0,
        scroll: !1
    }
      , we = {
        backdrop: "(boolean|string)",
        keyboard: "boolean",
        scroll: "boolean"
    };
    class Ce extends Ct {
        constructor(t, e) {
            super(t, e),
            this._isShown = !1,
            this._backdrop = this._initializeBackDrop(),
            this._focustrap = this._initializeFocusTrap(),
            this._addEventListeners()
        }
        static get Default() {
            return xe
        }
        static get DefaultType() {
            return we
        }
        static get NAME() {
            return "offcanvas"
        }
        toggle(t) {
            return this._isShown ? this.hide() : this.show(t)
        }
        show(t) {
            if (this._isShown)
                return;
            if (_t.trigger(this._element, ge, {
                relatedTarget: t
            }).defaultPrevented)
                return;
            this._isShown = !0,
            this._backdrop.show(),
            this._config.scroll || (new ce).hide(),
            this._element.setAttribute("aria-modal", !0),
            this._element.setAttribute("role", "dialog"),
            this._element.classList.add(pe);
            this._queueCallback( () => {
                this._config.scroll && !this._config.backdrop || this._focustrap.activate(),
                this._element.classList.add(ue),
                this._element.classList.remove(pe),
                _t.trigger(this._element, me, {
                    relatedTarget: t
                })
            }
            , this._element, !0)
        }
        hide() {
            if (!this._isShown)
                return;
            if (_t.trigger(this._element, _e).defaultPrevented)
                return;
            this._focustrap.deactivate(),
            this._element.blur(),
            this._isShown = !1,
            this._element.classList.add(fe),
            this._backdrop.hide();
            this._queueCallback( () => {
                this._element.classList.remove(ue, fe),
                this._element.removeAttribute("aria-modal"),
                this._element.removeAttribute("role"),
                this._config.scroll || (new ce).reset(),
                _t.trigger(this._element, ve)
            }
            , this._element, !0)
        }
        dispose() {
            this._backdrop.dispose(),
            this._focustrap.deactivate(),
            super.dispose()
        }
        _initializeBackDrop() {
            const t = Boolean(this._config.backdrop);
            return new Gt({
                className: "offcanvas-backdrop",
                isVisible: t,
                isAnimated: !0,
                rootElement: this._element.parentNode,
                clickCallback: t ? () => {
                    "static" !== this._config.backdrop ? this.hide() : _t.trigger(this._element, be)
                }
                : null
            })
        }
        _initializeFocusTrap() {
            return new oe({
                trapElement: this._element
            })
        }
        _addEventListeners() {
            _t.on(this._element, ye, t => {
                "Escape" === t.key && (this._config.keyboard ? this.hide() : _t.trigger(this._element, be))
            }
            )
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = Ce.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t)
                        throw new TypeError(`No method named "${t}"`);
                    e[t](this)
                }
            })
        }
    }
    const ke = ".bs.swipe"
      , Se = `touchstart${ke}`
      , Te = `touchmove${ke}`
      , Ae = `touchend${ke}`
      , Ee = `pointerdown${ke}`
      , Me = `pointerup${ke}`
      , Oe = {
        endCallback: null,
        leftCallback: null,
        rightCallback: null
    }
      , De = {
        endCallback: "(function|null)",
        leftCallback: "(function|null)",
        rightCallback: "(function|null)"
    };
    let $e = class t extends wt {
        constructor(e, i) {
            super(),
            this._element = e,
            e && t.isSupported() && (this._config = this._getConfig(i),
            this._deltaX = 0,
            this._supportPointerEvents = Boolean(window.PointerEvent),
            this._initEvents())
        }
        static get Default() {
            return Oe
        }
        static get DefaultType() {
            return De
        }
        static get NAME() {
            return "swipe"
        }
        dispose() {
            _t.off(this._element, ke)
        }
        _start(t) {
            this._supportPointerEvents ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) : this._deltaX = t.touches[0].clientX
        }
        _end(t) {
            this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX),
            this._handleSwipe(),
            J(this._config.endCallback)
        }
        _move(t) {
            this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX
        }
        _handleSwipe() {
            const t = Math.abs(this._deltaX);
            if (t <= 40)
                return;
            const e = t / this._deltaX;
            this._deltaX = 0,
            e && J(e > 0 ? this._config.rightCallback : this._config.leftCallback)
        }
        _initEvents() {
            this._supportPointerEvents ? (_t.on(this._element, Ee, t => this._start(t)),
            _t.on(this._element, Me, t => this._end(t)),
            this._element.classList.add("pointer-event")) : (_t.on(this._element, Se, t => this._start(t)),
            _t.on(this._element, Te, t => this._move(t)),
            _t.on(this._element, Ae, t => this._end(t)))
        }
        _eventIsPointerPenTouch(t) {
            return this._supportPointerEvents && ("pen" === t.pointerType || "touch" === t.pointerType)
        }
        static isSupported() {
            return "ontouchstart"in document.documentElement || navigator.maxTouchPoints > 0
        }
    }
    ;
    const Ie = ".bs.carousel"
      , Le = "ArrowLeft"
      , Pe = "ArrowRight"
      , Re = "next"
      , Ne = "prev"
      , Be = "left"
      , He = "right"
      , Fe = `slide${Ie}`
      , ze = `slid${Ie}`
      , je = `keydown${Ie}`
      , We = `mouseenter${Ie}`
      , Ve = `mouseleave${Ie}`
      , Ye = `dragstart${Ie}`
      , Xe = "active"
      , Ke = ".active"
      , Ue = ".carousel-item"
      , qe = Ke + Ue
      , Ze = {
        [Le]: He,
        [Pe]: Be
    }
      , Ge = {
        interval: 5e3,
        keyboard: !0,
        pause: "hover",
        ride: !1,
        touch: !0,
        wrap: !0
    }
      , Qe = {
        interval: "(number|boolean)",
        keyboard: "boolean",
        pause: "(string|boolean)",
        ride: "(boolean|string)",
        touch: "boolean",
        wrap: "boolean"
    };
    let Je = class t extends Ct {
        constructor(t, e) {
            super(t, e),
            this._interval = null,
            this._activeElement = null,
            this._isSliding = !1,
            this.touchTimeout = null,
            this._swipeHelper = null,
            this._indicatorsElement = Yt.findOne(".carousel-indicators", this._element),
            this._addEventListeners(),
            "carousel" === this._config.ride && this.cycle()
        }
        static get Default() {
            return Ge
        }
        static get DefaultType() {
            return Qe
        }
        static get NAME() {
            return "carousel"
        }
        next() {
            this._slide(Re)
        }
        nextWhenVisible() {
            !document.hidden && K(this._element) && this.next()
        }
        prev() {
            this._slide(Ne)
        }
        pause() {
            this._isSliding && V(this._element),
            this._clearInterval()
        }
        cycle() {
            this._clearInterval(),
            this._updateInterval(),
            this._interval = setInterval( () => this.nextWhenVisible(), this._config.interval)
        }
        _maybeEnableCycle() {
            this._config.ride && (this._isSliding ? _t.one(this._element, ze, () => this.cycle()) : this.cycle())
        }
        to(t) {
            const e = this._getItems();
            if (t > e.length - 1 || t < 0)
                return;
            if (this._isSliding)
                return void _t.one(this._element, ze, () => this.to(t));
            const i = this._getItemIndex(this._getActive());
            if (i === t)
                return;
            const n = t > i ? Re : Ne;
            this._slide(n, e[t])
        }
        dispose() {
            this._swipeHelper && this._swipeHelper.dispose(),
            super.dispose()
        }
        _configAfterMerge(t) {
            return t.defaultInterval = t.interval,
            t
        }
        _addEventListeners() {
            this._config.keyboard && _t.on(this._element, je, t => this._keydown(t)),
            "hover" === this._config.pause && (_t.on(this._element, We, () => this.pause()),
            _t.on(this._element, Ve, () => this._maybeEnableCycle())),
            this._config.touch && $e.isSupported() && this._addTouchEventListeners()
        }
        _addTouchEventListeners() {
            for (const e of Yt.find(".carousel-item img", this._element))
                _t.on(e, Ye, t => t.preventDefault());
            const t = {
                leftCallback: () => this._slide(this._directionToOrder(Be)),
                rightCallback: () => this._slide(this._directionToOrder(He)),
                endCallback: () => {
                    "hover" === this._config.pause && (this.pause(),
                    this.touchTimeout && clearTimeout(this.touchTimeout),
                    this.touchTimeout = setTimeout( () => this._maybeEnableCycle(), 500 + this._config.interval))
                }
            };
            this._swipeHelper = new $e(this._element,t)
        }
        _keydown(t) {
            if (/input|textarea/i.test(t.target.tagName))
                return;
            const e = Ze[t.key];
            e && (t.preventDefault(),
            this._slide(this._directionToOrder(e)))
        }
        _getItemIndex(t) {
            return this._getItems().indexOf(t)
        }
        _setActiveIndicatorElement(t) {
            if (!this._indicatorsElement)
                return;
            const e = Yt.findOne(Ke, this._indicatorsElement);
            e.classList.remove(Xe),
            e.removeAttribute("aria-current");
            const i = Yt.findOne(`[data-mdb-slide-to="${t}"]`, this._indicatorsElement);
            i && (i.classList.add(Xe),
            i.setAttribute("aria-current", "true"))
        }
        _updateInterval() {
            const t = this._activeElement || this._getActive();
            if (!t)
                return;
            const e = Number.parseInt(t.getAttribute("data-mdb-interval"), 10);
            this._config.interval = e || this._config.defaultInterval
        }
        _slide(t, e=null) {
            if (this._isSliding)
                return;
            const i = this._getActive()
              , n = t === Re
              , s = e || et(this._getItems(), i, n, this._config.wrap);
            if (s === i)
                return;
            const o = this._getItemIndex(s)
              , a = e => _t.trigger(this._element, e, {
                relatedTarget: s,
                direction: this._orderToDirection(t),
                from: this._getItemIndex(i),
                to: o
            });
            if (a(Fe).defaultPrevented)
                return;
            if (!i || !s)
                return;
            const r = Boolean(this._interval);
            this.pause(),
            this._isSliding = !0,
            this._setActiveIndicatorElement(o),
            this._activeElement = s;
            const l = n ? "carousel-item-start" : "carousel-item-end"
              , h = n ? "carousel-item-next" : "carousel-item-prev";
            s.classList.add(h),
            G(s),
            i.classList.add(l),
            s.classList.add(l);
            this._queueCallback( () => {
                s.classList.remove(l, h),
                s.classList.add(Xe),
                i.classList.remove(Xe, h, l),
                this._isSliding = !1,
                a(ze)
            }
            , i, this._isAnimated()),
            r && this.cycle()
        }
        _isAnimated() {
            return this._element.classList.contains("slide")
        }
        _getActive() {
            return Yt.findOne(qe, this._element)
        }
        _getItems() {
            return Yt.find(Ue, this._element)
        }
        _clearInterval() {
            this._interval && (clearInterval(this._interval),
            this._interval = null)
        }
        _directionToOrder(t) {
            return Q() ? t === Be ? Ne : Re : t === Be ? Re : Ne
        }
        _orderToDirection(t) {
            return Q() ? t === Ne ? Be : He : t === Ne ? He : Be
        }
        static jQueryInterface(e) {
            return this.each(function() {
                const i = t.getOrCreateInstance(this, e);
                if ("number" != typeof e) {
                    if ("string" == typeof e) {
                        if (void 0 === i[e] || e.startsWith("_") || "constructor" === e)
                            throw new TypeError(`No method named "${e}"`);
                        i[e]()
                    }
                } else
                    i.to(e)
            })
        }
    }
    ;
    const ti = "carousel"
      , ei = [{
        name: "slide",
        parametersToCopy: ["relatedTarget", "direction", "from", "to"]
    }, {
        name: "slid",
        parametersToCopy: ["relatedTarget", "direction", "from", "to"]
    }];
    class ii extends Je {
        constructor(t, e) {
            super(t, e),
            this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        dispose() {
            I.off(this._element, "slide.bs.carousel"),
            I.off(this._element, "slid.bs.carousel"),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        static get NAME() {
            return ti
        }
        _init() {
            this._bindMdbEvents()
        }
        _bindMdbEvents() {
            I.extend(this._element, ei, ti)
        }
    }
    var ni = "top"
      , si = "bottom"
      , oi = "right"
      , ai = "left"
      , ri = "auto"
      , li = [ni, si, oi, ai]
      , hi = "start"
      , ci = "end"
      , di = "clippingParents"
      , ui = "viewport"
      , pi = "popper"
      , fi = "reference"
      , gi = li.reduce(function(t, e) {
        return t.concat([e + "-" + hi, e + "-" + ci])
    }, [])
      , mi = [].concat(li, [ri]).reduce(function(t, e) {
        return t.concat([e, e + "-" + hi, e + "-" + ci])
    }, [])
      , _i = "beforeRead"
      , bi = "read"
      , vi = "afterRead"
      , yi = "beforeMain"
      , xi = "main"
      , wi = "afterMain"
      , Ci = "beforeWrite"
      , ki = "write"
      , Si = "afterWrite"
      , Ti = [_i, bi, vi, yi, xi, wi, Ci, ki, Si];
    function Ai(t) {
        return t ? (t.nodeName || "").toLowerCase() : null
    }
    function Ei(t) {
        if (null == t)
            return window;
        if ("[object Window]" !== t.toString()) {
            var e = t.ownerDocument;
            return e && e.defaultView || window
        }
        return t
    }
    function Mi(t) {
        return t instanceof Ei(t).Element || t instanceof Element
    }
    function Oi(t) {
        return t instanceof Ei(t).HTMLElement || t instanceof HTMLElement
    }
    function Di(t) {
        return "undefined" != typeof ShadowRoot && (t instanceof Ei(t).ShadowRoot || t instanceof ShadowRoot)
    }
    const $i = {
        name: "applyStyles",
        enabled: !0,
        phase: "write",
        fn: function(t) {
            var e = t.state;
            Object.keys(e.elements).forEach(function(t) {
                var i = e.styles[t] || {}
                  , n = e.attributes[t] || {}
                  , s = e.elements[t];
                Oi(s) && Ai(s) && (Object.assign(s.style, i),
                Object.keys(n).forEach(function(t) {
                    var e = n[t];
                    !1 === e ? s.removeAttribute(t) : s.setAttribute(t, !0 === e ? "" : e)
                }))
            })
        },
        effect: function(t) {
            var e = t.state
              , i = {
                popper: {
                    position: e.options.strategy,
                    left: "0",
                    top: "0",
                    margin: "0"
                },
                arrow: {
                    position: "absolute"
                },
                reference: {}
            };
            return Object.assign(e.elements.popper.style, i.popper),
            e.styles = i,
            e.elements.arrow && Object.assign(e.elements.arrow.style, i.arrow),
            function() {
                Object.keys(e.elements).forEach(function(t) {
                    var n = e.elements[t]
                      , s = e.attributes[t] || {}
                      , o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : i[t]).reduce(function(t, e) {
                        return t[e] = "",
                        t
                    }, {});
                    Oi(n) && Ai(n) && (Object.assign(n.style, o),
                    Object.keys(s).forEach(function(t) {
                        n.removeAttribute(t)
                    }))
                })
            }
        },
        requires: ["computeStyles"]
    };
    function Ii(t) {
        return t.split("-")[0]
    }
    var Li = Math.max
      , Pi = Math.min
      , Ri = Math.round;
    function Ni() {
        var t = navigator.userAgentData;
        return null != t && t.brands && Array.isArray(t.brands) ? t.brands.map(function(t) {
            return t.brand + "/" + t.version
        }).join(" ") : navigator.userAgent
    }
    function Bi() {
        return !/^((?!chrome|android).)*safari/i.test(Ni())
    }
    function Hi(t, e, i) {
        void 0 === e && (e = !1),
        void 0 === i && (i = !1);
        var n = t.getBoundingClientRect()
          , s = 1
          , o = 1;
        e && Oi(t) && (s = t.offsetWidth > 0 && Ri(n.width) / t.offsetWidth || 1,
        o = t.offsetHeight > 0 && Ri(n.height) / t.offsetHeight || 1);
        var a = (Mi(t) ? Ei(t) : window).visualViewport
          , r = !Bi() && i
          , l = (n.left + (r && a ? a.offsetLeft : 0)) / s
          , h = (n.top + (r && a ? a.offsetTop : 0)) / o
          , c = n.width / s
          , d = n.height / o;
        return {
            width: c,
            height: d,
            top: h,
            right: l + c,
            bottom: h + d,
            left: l,
            x: l,
            y: h
        }
    }
    function Fi(t) {
        var e = Hi(t)
          , i = t.offsetWidth
          , n = t.offsetHeight;
        return Math.abs(e.width - i) <= 1 && (i = e.width),
        Math.abs(e.height - n) <= 1 && (n = e.height),
        {
            x: t.offsetLeft,
            y: t.offsetTop,
            width: i,
            height: n
        }
    }
    function zi(t, e) {
        var i = e.getRootNode && e.getRootNode();
        if (t.contains(e))
            return !0;
        if (i && Di(i)) {
            var n = e;
            do {
                if (n && t.isSameNode(n))
                    return !0;
                n = n.parentNode || n.host
            } while (n)
        }
        return !1
    }
    function ji(t) {
        return Ei(t).getComputedStyle(t)
    }
    function Wi(t) {
        return ["table", "td", "th"].indexOf(Ai(t)) >= 0
    }
    function Vi(t) {
        return ((Mi(t) ? t.ownerDocument : t.document) || window.document).documentElement
    }
    function Yi(t) {
        return "html" === Ai(t) ? t : t.assignedSlot || t.parentNode || (Di(t) ? t.host : null) || Vi(t)
    }
    function Xi(t) {
        return Oi(t) && "fixed" !== ji(t).position ? t.offsetParent : null
    }
    function Ki(t) {
        for (var e = Ei(t), i = Xi(t); i && Wi(i) && "static" === ji(i).position; )
            i = Xi(i);
        return i && ("html" === Ai(i) || "body" === Ai(i) && "static" === ji(i).position) ? e : i || function(t) {
            var e = /firefox/i.test(Ni());
            if (/Trident/i.test(Ni()) && Oi(t) && "fixed" === ji(t).position)
                return null;
            var i = Yi(t);
            for (Di(i) && (i = i.host); Oi(i) && ["html", "body"].indexOf(Ai(i)) < 0; ) {
                var n = ji(i);
                if ("none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || -1 !== ["transform", "perspective"].indexOf(n.willChange) || e && "filter" === n.willChange || e && n.filter && "none" !== n.filter)
                    return i;
                i = i.parentNode
            }
            return null
        }(t) || e
    }
    function Ui(t) {
        return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
    }
    function qi(t, e, i) {
        return Li(t, Pi(e, i))
    }
    function Zi(t) {
        return Object.assign({}, {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, t)
    }
    function Gi(t, e) {
        return e.reduce(function(e, i) {
            return e[i] = t,
            e
        }, {})
    }
    const Qi = {
        name: "arrow",
        enabled: !0,
        phase: "main",
        fn: function(t) {
            var e, i = t.state, n = t.name, s = t.options, o = i.elements.arrow, a = i.modifiersData.popperOffsets, r = Ii(i.placement), l = Ui(r), h = [ai, oi].indexOf(r) >= 0 ? "height" : "width";
            if (o && a) {
                var c = function(t, e) {
                    return Zi("number" != typeof (t = "function" == typeof t ? t(Object.assign({}, e.rects, {
                        placement: e.placement
                    })) : t) ? t : Gi(t, li))
                }(s.padding, i)
                  , d = Fi(o)
                  , u = "y" === l ? ni : ai
                  , p = "y" === l ? si : oi
                  , f = i.rects.reference[h] + i.rects.reference[l] - a[l] - i.rects.popper[h]
                  , g = a[l] - i.rects.reference[l]
                  , m = Ki(o)
                  , _ = m ? "y" === l ? m.clientHeight || 0 : m.clientWidth || 0 : 0
                  , b = f / 2 - g / 2
                  , v = c[u]
                  , y = _ - d[h] - c[p]
                  , x = _ / 2 - d[h] / 2 + b
                  , w = qi(v, x, y)
                  , C = l;
                i.modifiersData[n] = ((e = {})[C] = w,
                e.centerOffset = w - x,
                e)
            }
        },
        effect: function(t) {
            var e = t.state
              , i = t.options.element
              , n = void 0 === i ? "[data-popper-arrow]" : i;
            null != n && ("string" != typeof n || (n = e.elements.popper.querySelector(n))) && zi(e.elements.popper, n) && (e.elements.arrow = n)
        },
        requires: ["popperOffsets"],
        requiresIfExists: ["preventOverflow"]
    };
    function Ji(t) {
        return t.split("-")[1]
    }
    var tn = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
    };
    function en(t) {
        var e, i = t.popper, n = t.popperRect, s = t.placement, o = t.variation, a = t.offsets, r = t.position, l = t.gpuAcceleration, h = t.adaptive, c = t.roundOffsets, d = t.isFixed, u = a.x, p = void 0 === u ? 0 : u, f = a.y, g = void 0 === f ? 0 : f, m = "function" == typeof c ? c({
            x: p,
            y: g
        }) : {
            x: p,
            y: g
        };
        p = m.x,
        g = m.y;
        var _ = a.hasOwnProperty("x")
          , b = a.hasOwnProperty("y")
          , v = ai
          , y = ni
          , x = window;
        if (h) {
            var w = Ki(i)
              , C = "clientHeight"
              , k = "clientWidth";
            if (w === Ei(i) && "static" !== ji(w = Vi(i)).position && "absolute" === r && (C = "scrollHeight",
            k = "scrollWidth"),
            s === ni || (s === ai || s === oi) && o === ci)
                y = si,
                g -= (d && w === x && x.visualViewport ? x.visualViewport.height : w[C]) - n.height,
                g *= l ? 1 : -1;
            if (s === ai || (s === ni || s === si) && o === ci)
                v = oi,
                p -= (d && w === x && x.visualViewport ? x.visualViewport.width : w[k]) - n.width,
                p *= l ? 1 : -1
        }
        var S, T = Object.assign({
            position: r
        }, h && tn), A = !0 === c ? function(t, e) {
            var i = t.x
              , n = t.y
              , s = e.devicePixelRatio || 1;
            return {
                x: Ri(i * s) / s || 0,
                y: Ri(n * s) / s || 0
            }
        }({
            x: p,
            y: g
        }, Ei(i)) : {
            x: p,
            y: g
        };
        return p = A.x,
        g = A.y,
        l ? Object.assign({}, T, ((S = {})[y] = b ? "0" : "",
        S[v] = _ ? "0" : "",
        S.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + g + "px)" : "translate3d(" + p + "px, " + g + "px, 0)",
        S)) : Object.assign({}, T, ((e = {})[y] = b ? g + "px" : "",
        e[v] = _ ? p + "px" : "",
        e.transform = "",
        e))
    }
    const nn = {
        name: "computeStyles",
        enabled: !0,
        phase: "beforeWrite",
        fn: function(t) {
            var e = t.state
              , i = t.options
              , n = i.gpuAcceleration
              , s = void 0 === n || n
              , o = i.adaptive
              , a = void 0 === o || o
              , r = i.roundOffsets
              , l = void 0 === r || r
              , h = {
                placement: Ii(e.placement),
                variation: Ji(e.placement),
                popper: e.elements.popper,
                popperRect: e.rects.popper,
                gpuAcceleration: s,
                isFixed: "fixed" === e.options.strategy
            };
            null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, en(Object.assign({}, h, {
                offsets: e.modifiersData.popperOffsets,
                position: e.options.strategy,
                adaptive: a,
                roundOffsets: l
            })))),
            null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, en(Object.assign({}, h, {
                offsets: e.modifiersData.arrow,
                position: "absolute",
                adaptive: !1,
                roundOffsets: l
            })))),
            e.attributes.popper = Object.assign({}, e.attributes.popper, {
                "data-popper-placement": e.placement
            })
        },
        data: {}
    };
    var sn = {
        passive: !0
    };
    const on = {
        name: "eventListeners",
        enabled: !0,
        phase: "write",
        fn: function() {},
        effect: function(t) {
            var e = t.state
              , i = t.instance
              , n = t.options
              , s = n.scroll
              , o = void 0 === s || s
              , a = n.resize
              , r = void 0 === a || a
              , l = Ei(e.elements.popper)
              , h = [].concat(e.scrollParents.reference, e.scrollParents.popper);
            return o && h.forEach(function(t) {
                t.addEventListener("scroll", i.update, sn)
            }),
            r && l.addEventListener("resize", i.update, sn),
            function() {
                o && h.forEach(function(t) {
                    t.removeEventListener("scroll", i.update, sn)
                }),
                r && l.removeEventListener("resize", i.update, sn)
            }
        },
        data: {}
    };
    var an = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
    };
    function rn(t) {
        return t.replace(/left|right|bottom|top/g, function(t) {
            return an[t]
        })
    }
    var ln = {
        start: "end",
        end: "start"
    };
    function hn(t) {
        return t.replace(/start|end/g, function(t) {
            return ln[t]
        })
    }
    function cn(t) {
        var e = Ei(t);
        return {
            scrollLeft: e.pageXOffset,
            scrollTop: e.pageYOffset
        }
    }
    function dn(t) {
        return Hi(Vi(t)).left + cn(t).scrollLeft
    }
    function un(t) {
        var e = ji(t)
          , i = e.overflow
          , n = e.overflowX
          , s = e.overflowY;
        return /auto|scroll|overlay|hidden/.test(i + s + n)
    }
    function pn(t) {
        return ["html", "body", "#document"].indexOf(Ai(t)) >= 0 ? t.ownerDocument.body : Oi(t) && un(t) ? t : pn(Yi(t))
    }
    function fn(t, e) {
        var i;
        void 0 === e && (e = []);
        var n = pn(t)
          , s = n === (null == (i = t.ownerDocument) ? void 0 : i.body)
          , o = Ei(n)
          , a = s ? [o].concat(o.visualViewport || [], un(n) ? n : []) : n
          , r = e.concat(a);
        return s ? r : r.concat(fn(Yi(a)))
    }
    function gn(t) {
        return Object.assign({}, t, {
            left: t.x,
            top: t.y,
            right: t.x + t.width,
            bottom: t.y + t.height
        })
    }
    function mn(t, e, i) {
        return e === ui ? gn(function(t, e) {
            var i = Ei(t)
              , n = Vi(t)
              , s = i.visualViewport
              , o = n.clientWidth
              , a = n.clientHeight
              , r = 0
              , l = 0;
            if (s) {
                o = s.width,
                a = s.height;
                var h = Bi();
                (h || !h && "fixed" === e) && (r = s.offsetLeft,
                l = s.offsetTop)
            }
            return {
                width: o,
                height: a,
                x: r + dn(t),
                y: l
            }
        }(t, i)) : Mi(e) ? function(t, e) {
            var i = Hi(t, !1, "fixed" === e);
            return i.top = i.top + t.clientTop,
            i.left = i.left + t.clientLeft,
            i.bottom = i.top + t.clientHeight,
            i.right = i.left + t.clientWidth,
            i.width = t.clientWidth,
            i.height = t.clientHeight,
            i.x = i.left,
            i.y = i.top,
            i
        }(e, i) : gn(function(t) {
            var e, i = Vi(t), n = cn(t), s = null == (e = t.ownerDocument) ? void 0 : e.body, o = Li(i.scrollWidth, i.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0), a = Li(i.scrollHeight, i.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0), r = -n.scrollLeft + dn(t), l = -n.scrollTop;
            return "rtl" === ji(s || i).direction && (r += Li(i.clientWidth, s ? s.clientWidth : 0) - o),
            {
                width: o,
                height: a,
                x: r,
                y: l
            }
        }(Vi(t)))
    }
    function _n(t, e, i, n) {
        var s = "clippingParents" === e ? function(t) {
            var e = fn(Yi(t))
              , i = ["absolute", "fixed"].indexOf(ji(t).position) >= 0 && Oi(t) ? Ki(t) : t;
            return Mi(i) ? e.filter(function(t) {
                return Mi(t) && zi(t, i) && "body" !== Ai(t)
            }) : []
        }(t) : [].concat(e)
          , o = [].concat(s, [i])
          , a = o[0]
          , r = o.reduce(function(e, i) {
            var s = mn(t, i, n);
            return e.top = Li(s.top, e.top),
            e.right = Pi(s.right, e.right),
            e.bottom = Pi(s.bottom, e.bottom),
            e.left = Li(s.left, e.left),
            e
        }, mn(t, a, n));
        return r.width = r.right - r.left,
        r.height = r.bottom - r.top,
        r.x = r.left,
        r.y = r.top,
        r
    }
    function bn(t) {
        var e, i = t.reference, n = t.element, s = t.placement, o = s ? Ii(s) : null, a = s ? Ji(s) : null, r = i.x + i.width / 2 - n.width / 2, l = i.y + i.height / 2 - n.height / 2;
        switch (o) {
        case ni:
            e = {
                x: r,
                y: i.y - n.height
            };
            break;
        case si:
            e = {
                x: r,
                y: i.y + i.height
            };
            break;
        case oi:
            e = {
                x: i.x + i.width,
                y: l
            };
            break;
        case ai:
            e = {
                x: i.x - n.width,
                y: l
            };
            break;
        default:
            e = {
                x: i.x,
                y: i.y
            }
        }
        var h = o ? Ui(o) : null;
        if (null != h) {
            var c = "y" === h ? "height" : "width";
            switch (a) {
            case hi:
                e[h] = e[h] - (i[c] / 2 - n[c] / 2);
                break;
            case ci:
                e[h] = e[h] + (i[c] / 2 - n[c] / 2)
            }
        }
        return e
    }
    function vn(t, e) {
        void 0 === e && (e = {});
        var i = e
          , n = i.placement
          , s = void 0 === n ? t.placement : n
          , o = i.strategy
          , a = void 0 === o ? t.strategy : o
          , r = i.boundary
          , l = void 0 === r ? di : r
          , h = i.rootBoundary
          , c = void 0 === h ? ui : h
          , d = i.elementContext
          , u = void 0 === d ? pi : d
          , p = i.altBoundary
          , f = void 0 !== p && p
          , g = i.padding
          , m = void 0 === g ? 0 : g
          , _ = Zi("number" != typeof m ? m : Gi(m, li))
          , b = u === pi ? fi : pi
          , v = t.rects.popper
          , y = t.elements[f ? b : u]
          , x = _n(Mi(y) ? y : y.contextElement || Vi(t.elements.popper), l, c, a)
          , w = Hi(t.elements.reference)
          , C = bn({
            reference: w,
            element: v,
            strategy: "absolute",
            placement: s
        })
          , k = gn(Object.assign({}, v, C))
          , S = u === pi ? k : w
          , T = {
            top: x.top - S.top + _.top,
            bottom: S.bottom - x.bottom + _.bottom,
            left: x.left - S.left + _.left,
            right: S.right - x.right + _.right
        }
          , A = t.modifiersData.offset;
        if (u === pi && A) {
            var E = A[s];
            Object.keys(T).forEach(function(t) {
                var e = [oi, si].indexOf(t) >= 0 ? 1 : -1
                  , i = [ni, si].indexOf(t) >= 0 ? "y" : "x";
                T[t] += E[i] * e
            })
        }
        return T
    }
    const yn = {
        name: "flip",
        enabled: !0,
        phase: "main",
        fn: function(t) {
            var e = t.state
              , i = t.options
              , n = t.name;
            if (!e.modifiersData[n]._skip) {
                for (var s = i.mainAxis, o = void 0 === s || s, a = i.altAxis, r = void 0 === a || a, l = i.fallbackPlacements, h = i.padding, c = i.boundary, d = i.rootBoundary, u = i.altBoundary, p = i.flipVariations, f = void 0 === p || p, g = i.allowedAutoPlacements, m = e.options.placement, _ = Ii(m), b = l || (_ === m || !f ? [rn(m)] : function(t) {
                    if (Ii(t) === ri)
                        return [];
                    var e = rn(t);
                    return [hn(t), e, hn(e)]
                }(m)), v = [m].concat(b).reduce(function(t, i) {
                    return t.concat(Ii(i) === ri ? function(t, e) {
                        void 0 === e && (e = {});
                        var i = e
                          , n = i.placement
                          , s = i.boundary
                          , o = i.rootBoundary
                          , a = i.padding
                          , r = i.flipVariations
                          , l = i.allowedAutoPlacements
                          , h = void 0 === l ? mi : l
                          , c = Ji(n)
                          , d = c ? r ? gi : gi.filter(function(t) {
                            return Ji(t) === c
                        }) : li
                          , u = d.filter(function(t) {
                            return h.indexOf(t) >= 0
                        });
                        0 === u.length && (u = d);
                        var p = u.reduce(function(e, i) {
                            return e[i] = vn(t, {
                                placement: i,
                                boundary: s,
                                rootBoundary: o,
                                padding: a
                            })[Ii(i)],
                            e
                        }, {});
                        return Object.keys(p).sort(function(t, e) {
                            return p[t] - p[e]
                        })
                    }(e, {
                        placement: i,
                        boundary: c,
                        rootBoundary: d,
                        padding: h,
                        flipVariations: f,
                        allowedAutoPlacements: g
                    }) : i)
                }, []), y = e.rects.reference, x = e.rects.popper, w = new Map, C = !0, k = v[0], S = 0; S < v.length; S++) {
                    var T = v[S]
                      , A = Ii(T)
                      , E = Ji(T) === hi
                      , M = [ni, si].indexOf(A) >= 0
                      , O = M ? "width" : "height"
                      , D = vn(e, {
                        placement: T,
                        boundary: c,
                        rootBoundary: d,
                        altBoundary: u,
                        padding: h
                    })
                      , $ = M ? E ? oi : ai : E ? si : ni;
                    y[O] > x[O] && ($ = rn($));
                    var I = rn($)
                      , L = [];
                    if (o && L.push(D[A] <= 0),
                    r && L.push(D[$] <= 0, D[I] <= 0),
                    L.every(function(t) {
                        return t
                    })) {
                        k = T,
                        C = !1;
                        break
                    }
                    w.set(T, L)
                }
                if (C)
                    for (var P = function(t) {
                        var e = v.find(function(e) {
                            var i = w.get(e);
                            if (i)
                                return i.slice(0, t).every(function(t) {
                                    return t
                                })
                        });
                        if (e)
                            return k = e,
                            "break"
                    }, R = f ? 3 : 1; R > 0; R--) {
                        if ("break" === P(R))
                            break
                    }
                e.placement !== k && (e.modifiersData[n]._skip = !0,
                e.placement = k,
                e.reset = !0)
            }
        },
        requiresIfExists: ["offset"],
        data: {
            _skip: !1
        }
    };
    function xn(t, e, i) {
        return void 0 === i && (i = {
            x: 0,
            y: 0
        }),
        {
            top: t.top - e.height - i.y,
            right: t.right - e.width + i.x,
            bottom: t.bottom - e.height + i.y,
            left: t.left - e.width - i.x
        }
    }
    function wn(t) {
        return [ni, oi, si, ai].some(function(e) {
            return t[e] >= 0
        })
    }
    const Cn = {
        name: "hide",
        enabled: !0,
        phase: "main",
        requiresIfExists: ["preventOverflow"],
        fn: function(t) {
            var e = t.state
              , i = t.name
              , n = e.rects.reference
              , s = e.rects.popper
              , o = e.modifiersData.preventOverflow
              , a = vn(e, {
                elementContext: "reference"
            })
              , r = vn(e, {
                altBoundary: !0
            })
              , l = xn(a, n)
              , h = xn(r, s, o)
              , c = wn(l)
              , d = wn(h);
            e.modifiersData[i] = {
                referenceClippingOffsets: l,
                popperEscapeOffsets: h,
                isReferenceHidden: c,
                hasPopperEscaped: d
            },
            e.attributes.popper = Object.assign({}, e.attributes.popper, {
                "data-popper-reference-hidden": c,
                "data-popper-escaped": d
            })
        }
    };
    const kn = {
        name: "offset",
        enabled: !0,
        phase: "main",
        requires: ["popperOffsets"],
        fn: function(t) {
            var e = t.state
              , i = t.options
              , n = t.name
              , s = i.offset
              , o = void 0 === s ? [0, 0] : s
              , a = mi.reduce(function(t, i) {
                return t[i] = function(t, e, i) {
                    var n = Ii(t)
                      , s = [ai, ni].indexOf(n) >= 0 ? -1 : 1
                      , o = "function" == typeof i ? i(Object.assign({}, e, {
                        placement: t
                    })) : i
                      , a = o[0]
                      , r = o[1];
                    return a = a || 0,
                    r = (r || 0) * s,
                    [ai, oi].indexOf(n) >= 0 ? {
                        x: r,
                        y: a
                    } : {
                        x: a,
                        y: r
                    }
                }(i, e.rects, o),
                t
            }, {})
              , r = a[e.placement]
              , l = r.x
              , h = r.y;
            null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += l,
            e.modifiersData.popperOffsets.y += h),
            e.modifiersData[n] = a
        }
    };
    const Sn = {
        name: "popperOffsets",
        enabled: !0,
        phase: "read",
        fn: function(t) {
            var e = t.state
              , i = t.name;
            e.modifiersData[i] = bn({
                reference: e.rects.reference,
                element: e.rects.popper,
                strategy: "absolute",
                placement: e.placement
            })
        },
        data: {}
    };
    const Tn = {
        name: "preventOverflow",
        enabled: !0,
        phase: "main",
        fn: function(t) {
            var e = t.state
              , i = t.options
              , n = t.name
              , s = i.mainAxis
              , o = void 0 === s || s
              , a = i.altAxis
              , r = void 0 !== a && a
              , l = i.boundary
              , h = i.rootBoundary
              , c = i.altBoundary
              , d = i.padding
              , u = i.tether
              , p = void 0 === u || u
              , f = i.tetherOffset
              , g = void 0 === f ? 0 : f
              , m = vn(e, {
                boundary: l,
                rootBoundary: h,
                padding: d,
                altBoundary: c
            })
              , _ = Ii(e.placement)
              , b = Ji(e.placement)
              , v = !b
              , y = Ui(_)
              , x = "x" === y ? "y" : "x"
              , w = e.modifiersData.popperOffsets
              , C = e.rects.reference
              , k = e.rects.popper
              , S = "function" == typeof g ? g(Object.assign({}, e.rects, {
                placement: e.placement
            })) : g
              , T = "number" == typeof S ? {
                mainAxis: S,
                altAxis: S
            } : Object.assign({
                mainAxis: 0,
                altAxis: 0
            }, S)
              , A = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null
              , E = {
                x: 0,
                y: 0
            };
            if (w) {
                if (o) {
                    var M, O = "y" === y ? ni : ai, D = "y" === y ? si : oi, $ = "y" === y ? "height" : "width", I = w[y], L = I + m[O], P = I - m[D], R = p ? -k[$] / 2 : 0, N = b === hi ? C[$] : k[$], B = b === hi ? -k[$] : -C[$], H = e.elements.arrow, F = p && H ? Fi(H) : {
                        width: 0,
                        height: 0
                    }, z = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }, j = z[O], W = z[D], V = qi(0, C[$], F[$]), Y = v ? C[$] / 2 - R - V - j - T.mainAxis : N - V - j - T.mainAxis, X = v ? -C[$] / 2 + R + V + W + T.mainAxis : B + V + W + T.mainAxis, K = e.elements.arrow && Ki(e.elements.arrow), U = K ? "y" === y ? K.clientTop || 0 : K.clientLeft || 0 : 0, q = null != (M = null == A ? void 0 : A[y]) ? M : 0, Z = I + X - q, G = qi(p ? Pi(L, I + Y - q - U) : L, I, p ? Li(P, Z) : P);
                    w[y] = G,
                    E[y] = G - I
                }
                if (r) {
                    var Q, J = "x" === y ? ni : ai, tt = "x" === y ? si : oi, et = w[x], it = "y" === x ? "height" : "width", nt = et + m[J], st = et - m[tt], ot = -1 !== [ni, ai].indexOf(_), at = null != (Q = null == A ? void 0 : A[x]) ? Q : 0, rt = ot ? nt : et - C[it] - k[it] - at + T.altAxis, lt = ot ? et + C[it] + k[it] - at - T.altAxis : st, ht = p && ot ? (dt = qi(rt, et, ct = lt)) > ct ? ct : dt : qi(p ? rt : nt, et, p ? lt : st);
                    w[x] = ht,
                    E[x] = ht - et
                }
                var ct, dt;
                e.modifiersData[n] = E
            }
        },
        requiresIfExists: ["offset"]
    };
    function An(t, e, i) {
        void 0 === i && (i = !1);
        var n, s, o = Oi(e), a = Oi(e) && function(t) {
            var e = t.getBoundingClientRect()
              , i = Ri(e.width) / t.offsetWidth || 1
              , n = Ri(e.height) / t.offsetHeight || 1;
            return 1 !== i || 1 !== n
        }(e), r = Vi(e), l = Hi(t, a, i), h = {
            scrollLeft: 0,
            scrollTop: 0
        }, c = {
            x: 0,
            y: 0
        };
        return (o || !o && !i) && (("body" !== Ai(e) || un(r)) && (h = (n = e) !== Ei(n) && Oi(n) ? {
            scrollLeft: (s = n).scrollLeft,
            scrollTop: s.scrollTop
        } : cn(n)),
        Oi(e) ? ((c = Hi(e, !0)).x += e.clientLeft,
        c.y += e.clientTop) : r && (c.x = dn(r))),
        {
            x: l.left + h.scrollLeft - c.x,
            y: l.top + h.scrollTop - c.y,
            width: l.width,
            height: l.height
        }
    }
    function En(t) {
        var e = new Map
          , i = new Set
          , n = [];
        function s(t) {
            i.add(t.name),
            [].concat(t.requires || [], t.requiresIfExists || []).forEach(function(t) {
                if (!i.has(t)) {
                    var n = e.get(t);
                    n && s(n)
                }
            }),
            n.push(t)
        }
        return t.forEach(function(t) {
            e.set(t.name, t)
        }),
        t.forEach(function(t) {
            i.has(t.name) || s(t)
        }),
        n
    }
    var Mn = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
    };
    function On() {
        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
            e[i] = arguments[i];
        return !e.some(function(t) {
            return !(t && "function" == typeof t.getBoundingClientRect)
        })
    }
    function Dn(t) {
        void 0 === t && (t = {});
        var e = t
          , i = e.defaultModifiers
          , n = void 0 === i ? [] : i
          , s = e.defaultOptions
          , o = void 0 === s ? Mn : s;
        return function(t, e, i) {
            void 0 === i && (i = o);
            var s, a, r = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, Mn, o),
                modifiersData: {},
                elements: {
                    reference: t,
                    popper: e
                },
                attributes: {},
                styles: {}
            }, l = [], h = !1, c = {
                state: r,
                setOptions: function(i) {
                    var s = "function" == typeof i ? i(r.options) : i;
                    d(),
                    r.options = Object.assign({}, o, r.options, s),
                    r.scrollParents = {
                        reference: Mi(t) ? fn(t) : t.contextElement ? fn(t.contextElement) : [],
                        popper: fn(e)
                    };
                    var a, h, u = function(t) {
                        var e = En(t);
                        return Ti.reduce(function(t, i) {
                            return t.concat(e.filter(function(t) {
                                return t.phase === i
                            }))
                        }, [])
                    }((a = [].concat(n, r.options.modifiers),
                    h = a.reduce(function(t, e) {
                        var i = t[e.name];
                        return t[e.name] = i ? Object.assign({}, i, e, {
                            options: Object.assign({}, i.options, e.options),
                            data: Object.assign({}, i.data, e.data)
                        }) : e,
                        t
                    }, {}),
                    Object.keys(h).map(function(t) {
                        return h[t]
                    })));
                    return r.orderedModifiers = u.filter(function(t) {
                        return t.enabled
                    }),
                    r.orderedModifiers.forEach(function(t) {
                        var e = t.name
                          , i = t.options
                          , n = void 0 === i ? {} : i
                          , s = t.effect;
                        if ("function" == typeof s) {
                            var o = s({
                                state: r,
                                name: e,
                                instance: c,
                                options: n
                            })
                              , a = function() {};
                            l.push(o || a)
                        }
                    }),
                    c.update()
                },
                forceUpdate: function() {
                    if (!h) {
                        var t = r.elements
                          , e = t.reference
                          , i = t.popper;
                        if (On(e, i)) {
                            r.rects = {
                                reference: An(e, Ki(i), "fixed" === r.options.strategy),
                                popper: Fi(i)
                            },
                            r.reset = !1,
                            r.placement = r.options.placement,
                            r.orderedModifiers.forEach(function(t) {
                                return r.modifiersData[t.name] = Object.assign({}, t.data)
                            });
                            for (var n = 0; n < r.orderedModifiers.length; n++)
                                if (!0 !== r.reset) {
                                    var s = r.orderedModifiers[n]
                                      , o = s.fn
                                      , a = s.options
                                      , l = void 0 === a ? {} : a
                                      , d = s.name;
                                    "function" == typeof o && (r = o({
                                        state: r,
                                        options: l,
                                        name: d,
                                        instance: c
                                    }) || r)
                                } else
                                    r.reset = !1,
                                    n = -1
                        }
                    }
                },
                update: (s = function() {
                    return new Promise(function(t) {
                        c.forceUpdate(),
                        t(r)
                    }
                    )
                }
                ,
                function() {
                    return a || (a = new Promise(function(t) {
                        Promise.resolve().then(function() {
                            a = void 0,
                            t(s())
                        })
                    }
                    )),
                    a
                }
                ),
                destroy: function() {
                    d(),
                    h = !0
                }
            };
            if (!On(t, e))
                return c;
            function d() {
                l.forEach(function(t) {
                    return t()
                }),
                l = []
            }
            return c.setOptions(i).then(function(t) {
                !h && i.onFirstUpdate && i.onFirstUpdate(t)
            }),
            c
        }
    }
    var $n = Dn()
      , In = Dn({
        defaultModifiers: [on, Sn, nn, $i]
    })
      , Ln = Dn({
        defaultModifiers: [on, Sn, nn, $i, kn, yn, Tn, Qi, Cn]
    });
    const Pn = Object.freeze(Object.defineProperty({
        __proto__: null,
        afterMain: wi,
        afterRead: vi,
        afterWrite: Si,
        applyStyles: $i,
        arrow: Qi,
        auto: ri,
        basePlacements: li,
        beforeMain: yi,
        beforeRead: _i,
        beforeWrite: Ci,
        bottom: si,
        clippingParents: di,
        computeStyles: nn,
        createPopper: Ln,
        createPopperBase: $n,
        createPopperLite: In,
        detectOverflow: vn,
        end: ci,
        eventListeners: on,
        flip: yn,
        hide: Cn,
        left: ai,
        main: xi,
        modifierPhases: Ti,
        offset: kn,
        placements: mi,
        popper: pi,
        popperGenerator: Dn,
        popperOffsets: Sn,
        preventOverflow: Tn,
        read: bi,
        reference: fi,
        right: oi,
        start: hi,
        top: ni,
        variationPlacements: gi,
        viewport: ui,
        write: ki
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Rn = {
        "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
        a: ["target", "href", "title", "rel"],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        dd: [],
        div: [],
        dl: [],
        dt: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ["src", "srcset", "alt", "title", "width", "height"],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
    }
      , Nn = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"])
      , Bn = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i
      , Hn = (t, e) => {
        const i = t.nodeName.toLowerCase();
        return e.includes(i) ? !Nn.has(i) || Boolean(Bn.test(t.nodeValue)) : e.filter(t => t instanceof RegExp).some(t => t.test(i))
    }
    ;
    const Fn = {
        allowList: Rn,
        content: {},
        extraClass: "",
        html: !1,
        sanitize: !0,
        sanitizeFn: null,
        template: "<div></div>"
    }
      , zn = {
        allowList: "object",
        content: "object",
        extraClass: "(string|function)",
        html: "boolean",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        template: "string"
    }
      , jn = {
        entry: "(string|element|function|null)",
        selector: "(string|element)"
    };
    class Wn extends wt {
        constructor(t) {
            super(),
            this._config = this._getConfig(t)
        }
        static get Default() {
            return Fn
        }
        static get DefaultType() {
            return zn
        }
        static get NAME() {
            return "TemplateFactory"
        }
        getContent() {
            return Object.values(this._config.content).map(t => this._resolvePossibleFunction(t)).filter(Boolean)
        }
        hasContent() {
            return this.getContent().length > 0
        }
        changeContent(t) {
            return this._checkContent(t),
            this._config.content = {
                ...this._config.content,
                ...t
            },
            this
        }
        toHtml() {
            const t = document.createElement("div");
            t.innerHTML = this._maybeSanitize(this._config.template);
            for (const [n,s] of Object.entries(this._config.content))
                this._setContent(t, s, n);
            const e = t.children[0]
              , i = this._resolvePossibleFunction(this._config.extraClass);
            return i && e.classList.add(...i.split(" ")),
            e
        }
        _typeCheckConfig(t) {
            super._typeCheckConfig(t),
            this._checkContent(t.content)
        }
        _checkContent(t) {
            for (const [e,i] of Object.entries(t))
                super._typeCheckConfig({
                    selector: e,
                    entry: i
                }, jn)
        }
        _setContent(t, e, i) {
            const n = Yt.findOne(i, t);
            n && ((e = this._resolvePossibleFunction(e)) ? Y(e) ? this._putElementInTemplate(X(e), n) : this._config.html ? n.innerHTML = this._maybeSanitize(e) : n.textContent = e : n.remove())
        }
        _maybeSanitize(t) {
            return this._config.sanitize ? function(t, e, i) {
                if (!t.length)
                    return t;
                if (i && "function" == typeof i)
                    return i(t);
                const n = (new window.DOMParser).parseFromString(t, "text/html")
                  , s = [].concat(...n.body.querySelectorAll("*"));
                for (const o of s) {
                    const t = o.nodeName.toLowerCase();
                    if (!Object.keys(e).includes(t)) {
                        o.remove();
                        continue
                    }
                    const i = [].concat(...o.attributes)
                      , n = [].concat(e["*"] || [], e[t] || []);
                    for (const e of i)
                        Hn(e, n) || o.removeAttribute(e.nodeName)
                }
                return n.body.innerHTML
            }(t, this._config.allowList, this._config.sanitizeFn) : t
        }
        _resolvePossibleFunction(t) {
            return J(t, [this])
        }
        _putElementInTemplate(t, e) {
            if (this._config.html)
                return e.innerHTML = "",
                void e.append(t);
            e.textContent = t.textContent
        }
    }
    const Vn = new Set(["sanitize", "allowList", "sanitizeFn"])
      , Yn = "fade"
      , Xn = "show"
      , Kn = ".tooltip-inner"
      , Un = ".modal"
      , qn = "hide.bs.modal"
      , Zn = "hover"
      , Gn = "focus"
      , Qn = {
        AUTO: "auto",
        TOP: "top",
        RIGHT: Q() ? "left" : "right",
        BOTTOM: "bottom",
        LEFT: Q() ? "right" : "left"
    }
      , Jn = {
        allowList: Rn,
        animation: !0,
        boundary: "clippingParents",
        container: !1,
        customClass: "",
        delay: 0,
        fallbackPlacements: ["top", "right", "bottom", "left"],
        html: !1,
        offset: [0, 6],
        placement: "top",
        popperConfig: null,
        sanitize: !0,
        sanitizeFn: null,
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        title: "",
        trigger: "hover focus"
    }
      , ts = {
        allowList: "object",
        animation: "boolean",
        boundary: "(string|element)",
        container: "(string|element|boolean)",
        customClass: "(string|function)",
        delay: "(number|object)",
        fallbackPlacements: "array",
        html: "boolean",
        offset: "(array|string|function)",
        placement: "(string|function)",
        popperConfig: "(null|object|function)",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        selector: "(string|boolean)",
        template: "string",
        title: "(string|element|function)",
        trigger: "string"
    };
    let es = class t extends Ct {
        constructor(t, e) {
            if (void 0 === Pn)
                throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
            super(t, e),
            this._isEnabled = !0,
            this._timeout = 0,
            this._isHovered = null,
            this._activeTrigger = {},
            this._popper = null,
            this._templateFactory = null,
            this._newContent = null,
            this.tip = null,
            this._setListeners(),
            this._config.selector || this._fixTitle()
        }
        static get Default() {
            return Jn
        }
        static get DefaultType() {
            return ts
        }
        static get NAME() {
            return "tooltip"
        }
        enable() {
            this._isEnabled = !0
        }
        disable() {
            this._isEnabled = !1
        }
        toggleEnabled() {
            this._isEnabled = !this._isEnabled
        }
        toggle() {
            this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click,
            this._isShown() ? this._leave() : this._enter())
        }
        dispose() {
            clearTimeout(this._timeout),
            _t.off(this._element.closest(Un), qn, this._hideModalHandler),
            this._element.getAttribute("data-mdb-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-mdb-original-title")),
            this._disposePopper(),
            super.dispose()
        }
        show() {
            if ("none" === this._element.style.display)
                throw new Error("Please use show on visible elements");
            if (!this._isWithContent() || !this._isEnabled)
                return;
            const t = _t.trigger(this._element, this.constructor.eventName("show"))
              , e = (q(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
            if (t.defaultPrevented || !e)
                return;
            this._disposePopper();
            const i = this._getTipElement();
            this._element.setAttribute("aria-describedby", i.getAttribute("id"));
            const {container: n} = this._config;
            if (this._element.ownerDocument.documentElement.contains(this.tip) || (n.append(i),
            _t.trigger(this._element, this.constructor.eventName("inserted"))),
            this._popper = this._createPopper(i),
            i.classList.add(Xn),
            "ontouchstart"in document.documentElement)
                for (const s of [].concat(...document.body.children))
                    _t.on(s, "mouseover", Z);
            this._queueCallback( () => {
                _t.trigger(this._element, this.constructor.eventName("shown")),
                !1 === this._isHovered && this._leave(),
                this._isHovered = !1
            }
            , this.tip, this._isAnimated())
        }
        hide() {
            if (!this._isShown())
                return;
            if (_t.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented)
                return;
            if (this._getTipElement().classList.remove(Xn),
            "ontouchstart"in document.documentElement)
                for (const t of [].concat(...document.body.children))
                    _t.off(t, "mouseover", Z);
            this._activeTrigger.click = !1,
            this._activeTrigger[Gn] = !1,
            this._activeTrigger[Zn] = !1,
            this._isHovered = null;
            this._queueCallback( () => {
                this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(),
                this._element.removeAttribute("aria-describedby"),
                _t.trigger(this._element, this.constructor.eventName("hidden")))
            }
            , this.tip, this._isAnimated())
        }
        update() {
            this._popper && this._popper.update()
        }
        _isWithContent() {
            return Boolean(this._getTitle())
        }
        _getTipElement() {
            return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())),
            this.tip
        }
        _createTipElement(t) {
            const e = this._getTemplateFactory(t).toHtml();
            if (!e)
                return null;
            e.classList.remove(Yn, Xn),
            e.classList.add(`bs-${this.constructor.NAME}-auto`);
            const i = (t => {
                do {
                    t += Math.floor(1e6 * Math.random())
                } while (document.getElementById(t));
                return t
            }
            )(this.constructor.NAME).toString();
            return e.setAttribute("id", i),
            this._isAnimated() && e.classList.add(Yn),
            e
        }
        setContent(t) {
            this._newContent = t,
            this._isShown() && (this._disposePopper(),
            this.show())
        }
        _getTemplateFactory(t) {
            return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new Wn({
                ...this._config,
                content: t,
                extraClass: this._resolvePossibleFunction(this._config.customClass)
            }),
            this._templateFactory
        }
        _getContentForTemplate() {
            return {
                [Kn]: this._getTitle()
            }
        }
        _getTitle() {
            return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-mdb-original-title")
        }
        _initializeOnDelegatedTarget(t) {
            return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig())
        }
        _isAnimated() {
            return this._config.animation || this.tip && this.tip.classList.contains(Yn)
        }
        _isShown() {
            return this.tip && this.tip.classList.contains(Xn)
        }
        _createPopper(t) {
            const e = J(this._config.placement, [this, t, this._element])
              , i = Qn[e.toUpperCase()];
            return Ln(this._element, t, this._getPopperConfig(i))
        }
        _getOffset() {
            const {offset: t} = this._config;
            return "string" == typeof t ? t.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof t ? e => t(e, this._element) : t
        }
        _resolvePossibleFunction(t) {
            return J(t, [this._element])
        }
        _getPopperConfig(t) {
            const e = {
                placement: t,
                modifiers: [{
                    name: "flip",
                    options: {
                        fallbackPlacements: this._config.fallbackPlacements
                    }
                }, {
                    name: "offset",
                    options: {
                        offset: this._getOffset()
                    }
                }, {
                    name: "preventOverflow",
                    options: {
                        boundary: this._config.boundary
                    }
                }, {
                    name: "arrow",
                    options: {
                        element: `.${this.constructor.NAME}-arrow`
                    }
                }, {
                    name: "preSetPlacement",
                    enabled: !0,
                    phase: "beforeMain",
                    fn: t => {
                        this._getTipElement().setAttribute("data-popper-placement", t.state.placement)
                    }
                }]
            };
            return {
                ...e,
                ...J(this._config.popperConfig, [e])
            }
        }
        _setListeners() {
            const t = this._config.trigger.split(" ");
            for (const e of t)
                if ("click" === e)
                    _t.on(this._element, this.constructor.eventName("click"), this._config.selector, t => {
                        this._initializeOnDelegatedTarget(t).toggle()
                    }
                    );
                else if ("manual" !== e) {
                    const t = e === Zn ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin")
                      , i = e === Zn ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
                    _t.on(this._element, t, this._config.selector, t => {
                        const e = this._initializeOnDelegatedTarget(t);
                        e._activeTrigger["focusin" === t.type ? Gn : Zn] = !0,
                        e._enter()
                    }
                    ),
                    _t.on(this._element, i, this._config.selector, t => {
                        const e = this._initializeOnDelegatedTarget(t);
                        e._activeTrigger["focusout" === t.type ? Gn : Zn] = e._element.contains(t.relatedTarget),
                        e._leave()
                    }
                    )
                }
            this._hideModalHandler = () => {
                this._element && this.hide()
            }
            ,
            _t.on(this._element.closest(Un), qn, this._hideModalHandler)
        }
        _fixTitle() {
            const t = this._element.getAttribute("title");
            t && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t),
            this._element.setAttribute("data-mdb-original-title", t),
            this._element.removeAttribute("title"))
        }
        _enter() {
            this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0,
            this._setTimeout( () => {
                this._isHovered && this.show()
            }
            , this._config.delay.show))
        }
        _leave() {
            this._isWithActiveTrigger() || (this._isHovered = !1,
            this._setTimeout( () => {
                this._isHovered || this.hide()
            }
            , this._config.delay.hide))
        }
        _setTimeout(t, e) {
            clearTimeout(this._timeout),
            this._timeout = setTimeout(t, e)
        }
        _isWithActiveTrigger() {
            return Object.values(this._activeTrigger).includes(!0)
        }
        _getConfig(t) {
            const e = xt.getDataAttributes(this._element);
            for (const i of Object.keys(e))
                Vn.has(i) && delete e[i];
            return t = {
                ...e,
                ..."object" == typeof t && t ? t : {}
            },
            t = this._mergeConfigObj(t),
            t = this._configAfterMerge(t),
            this._typeCheckConfig(t),
            t
        }
        _configAfterMerge(t) {
            return t.container = !1 === t.container ? document.body : X(t.container),
            "number" == typeof t.delay && (t.delay = {
                show: t.delay,
                hide: t.delay
            }),
            "number" == typeof t.title && (t.title = t.title.toString()),
            "number" == typeof t.content && (t.content = t.content.toString()),
            t
        }
        _getDelegateConfig() {
            const t = {};
            for (const [e,i] of Object.entries(this._config))
                this.constructor.Default[e] !== i && (t[e] = i);
            return t.selector = !1,
            t.trigger = "manual",
            t
        }
        _disposePopper() {
            this._popper && (this._popper.destroy(),
            this._popper = null),
            this.tip && (this.tip.remove(),
            this.tip = null)
        }
        static jQueryInterface(e) {
            return this.each(function() {
                const i = t.getOrCreateInstance(this, e);
                if ("string" == typeof e) {
                    if (void 0 === i[e])
                        throw new TypeError(`No method named "${e}"`);
                    i[e]()
                }
            })
        }
    }
    ;
    const is = ".popover-header"
      , ns = ".popover-body"
      , ss = {
        ...es.Default,
        content: "",
        offset: [0, 8],
        placement: "right",
        template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
        trigger: "click"
    }
      , os = {
        ...es.DefaultType,
        content: "(null|string|element|function)"
    };
    let as = class t extends es {
        static get Default() {
            return ss
        }
        static get DefaultType() {
            return os
        }
        static get NAME() {
            return "popover"
        }
        _isWithContent() {
            return this._getTitle() || this._getContent()
        }
        _getContentForTemplate() {
            return {
                [is]: this._getTitle(),
                [ns]: this._getContent()
            }
        }
        _getContent() {
            return this._resolvePossibleFunction(this._config.content)
        }
        static jQueryInterface(e) {
            return this.each(function() {
                const i = t.getOrCreateInstance(this, e);
                if ("string" == typeof e) {
                    if (void 0 === i[e])
                        throw new TypeError(`No method named "${e}"`);
                    i[e]()
                }
            })
        }
    }
    ;
    const rs = "popover"
      , ls = [{
        name: "show"
    }, {
        name: "shown"
    }, {
        name: "hide"
    }, {
        name: "hidden"
    }, {
        name: "inserted"
    }];
    class hs extends as {
        constructor(t, e) {
            super(t, e),
            this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        dispose() {
            I.off(this.element, "show.bs.popover"),
            I.off(this.element, "shown.bs.popover"),
            I.off(this.element, "hide.bs.popover"),
            I.off(this.element, "hidden.bs.popover"),
            I.off(this.element, "inserted.bs.popover"),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        static get NAME() {
            return rs
        }
        _init() {
            this._bindMdbEvents()
        }
        _bindMdbEvents() {
            I.extend(this._element, ls, rs)
        }
    }
    const cs = ".bs.scrollspy"
      , ds = `activate${cs}`
      , us = `click${cs}`
      , ps = "active"
      , fs = "[href]"
      , gs = ".nav-link"
      , ms = `${gs}, .nav-item > ${gs}, .list-group-item`
      , _s = {
        offset: null,
        rootMargin: "0px 0px -25%",
        smoothScroll: !1,
        target: null,
        threshold: [.1, .5, 1]
    }
      , bs = {
        offset: "(number|null)",
        rootMargin: "string",
        smoothScroll: "boolean",
        target: "element",
        threshold: "array"
    };
    let vs = class t extends Ct {
        constructor(t, e) {
            super(t, e),
            this._config.target && (this._targetLinks = new Map,
            this._observableSections = new Map,
            this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element,
            this._activeTarget = null,
            this._observer = null,
            this._previousScrollData = {
                visibleEntryTop: 0,
                parentScrollTop: 0
            },
            this.refresh())
        }
        static get Default() {
            return _s
        }
        static get DefaultType() {
            return bs
        }
        static get NAME() {
            return "scrollspy"
        }
        refresh() {
            this._initializeTargetsAndObservables(),
            this._maybeEnableSmoothScroll(),
            this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
            for (const t of this._observableSections.values())
                this._observer.observe(t)
        }
        dispose() {
            this._observer && this._observer.disconnect(),
            super.dispose()
        }
        _configAfterMerge(t) {
            return t.target = X(t.target) || document.body,
            t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin,
            "string" == typeof t.threshold && (t.threshold = t.threshold.split(",").map(t => Number.parseFloat(t))),
            t
        }
        _maybeEnableSmoothScroll() {
            this._config.smoothScroll && (_t.off(this._config.target, us),
            _t.on(this._config.target, us, fs, t => {
                const e = this._observableSections.get(t.target.hash);
                if (e) {
                    t.preventDefault();
                    const i = this._rootElement || window
                      , n = e.offsetTop - this._element.offsetTop;
                    if (i.scrollTo)
                        return void i.scrollTo({
                            top: n,
                            behavior: "smooth"
                        });
                    i.scrollTop = n
                }
            }
            ))
        }
        _getNewObserver() {
            const t = {
                root: this._rootElement,
                threshold: this._config.threshold,
                rootMargin: this._config.rootMargin
            };
            return new IntersectionObserver(t => this._observerCallback(t),t)
        }
        _observerCallback(t) {
            const e = t => this._targetLinks.get(`#${t.target.id}`)
              , i = t => {
                this._previousScrollData.visibleEntryTop = t.target.offsetTop,
                this._process(e(t))
            }
              , n = (this._rootElement || document.documentElement).scrollTop
              , s = n >= this._previousScrollData.parentScrollTop;
            this._previousScrollData.parentScrollTop = n;
            for (const o of t) {
                if (!o.isIntersecting) {
                    this._activeTarget = null,
                    this._clearActiveClass(e(o));
                    continue
                }
                const t = o.target.offsetTop >= this._previousScrollData.visibleEntryTop;
                if (s && t) {
                    if (i(o),
                    !n)
                        return
                } else
                    s || t || i(o)
            }
        }
        _initializeTargetsAndObservables() {
            this._targetLinks = new Map,
            this._observableSections = new Map;
            const t = Yt.find(fs, this._config.target);
            for (const e of t) {
                if (!e.hash || U(e))
                    continue;
                const t = Yt.findOne(decodeURI(e.hash), this._element);
                K(t) && (this._targetLinks.set(decodeURI(e.hash), e),
                this._observableSections.set(e.hash, t))
            }
        }
        _process(t) {
            this._activeTarget !== t && (this._clearActiveClass(this._config.target),
            this._activeTarget = t,
            t.classList.add(ps),
            this._activateParents(t),
            _t.trigger(this._element, ds, {
                relatedTarget: t
            }))
        }
        _activateParents(t) {
            if (t.classList.contains("dropdown-item"))
                Yt.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(ps);
            else
                for (const e of Yt.parents(t, ".nav, .list-group"))
                    for (const t of Yt.prev(e, ms))
                        t.classList.add(ps)
        }
        _clearActiveClass(t) {
            t.classList.remove(ps);
            const e = Yt.find(`${fs}.${ps}`, t);
            for (const i of e)
                i.classList.remove(ps)
        }
        static jQueryInterface(e) {
            return this.each(function() {
                const i = t.getOrCreateInstance(this, e);
                if ("string" == typeof e) {
                    if (void 0 === i[e] || e.startsWith("_") || "constructor" === e)
                        throw new TypeError(`No method named "${e}"`);
                    i[e]()
                }
            })
        }
    }
    ;
    const ys = "scrollspy"
      , xs = "activate.bs.scrollspy"
      , ws = `activate${`.${`mdb.${ys}`}`}`
      , Cs = "collapsible-scrollspy"
      , ks = "ul"
      , Ss = `.${Cs}`;
    class Ts extends vs {
        constructor(t, e) {
            super(t, e),
            this._collapsibles = [],
            this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        dispose() {
            I.off(this._scrollElement, xs),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        static get NAME() {
            return ys
        }
        _init() {
            this._bindActivateEvent(),
            this._getCollapsibles(),
            0 !== this._collapsibles.length && (this._showSubsection(),
            this._hideSubsection())
        }
        _getHeight(t) {
            return t.offsetHeight
        }
        _hide(t) {
            const e = B.findOne(ks, t.parentNode);
            e.style.overflow = "hidden",
            e.style.height = "0px"
        }
        _show(t, e) {
            t.style.height = e
        }
        _getCollapsibles() {
            const t = B.find(Ss);
            t && t.forEach(t => {
                const e = t.parentNode
                  , i = B.findOne(ks, e)
                  , n = i.offsetHeight;
                this._collapsibles.push({
                    element: i,
                    relatedTarget: t.getAttribute("href"),
                    height: `${n}px`
                })
            }
            )
        }
        _showSubsection() {
            B.find(".active").filter(t => N.hasClass(t, Cs)).forEach(t => {
                const e = B.findOne(ks, t.parentNode)
                  , i = this._collapsibles.find(e => e.relatedTarget = t.getAttribute("href")).height;
                this._show(e, i)
            }
            )
        }
        _hideSubsection() {
            B.find(Ss).filter(t => !1 === N.hasClass(t, "active")).forEach(t => {
                this._hide(t)
            }
            )
        }
        _bindActivateEvent() {
            I.on(this._element, xs, t => {
                this._showSubsection(),
                this._hideSubsection(),
                I.trigger(this._element, ws, {
                    relatedTarget: t.relatedTarget
                })
            }
            )
        }
    }
    const As = ".bs.tab"
      , Es = `hide${As}`
      , Ms = `hidden${As}`
      , Os = `show${As}`
      , Ds = `shown${As}`
      , $s = `keydown${As}`
      , Is = "ArrowLeft"
      , Ls = "ArrowRight"
      , Ps = "ArrowUp"
      , Rs = "ArrowDown"
      , Ns = "Home"
      , Bs = "End"
      , Hs = "active"
      , Fs = "fade"
      , zs = "show"
      , js = ".dropdown-toggle"
      , Ws = `:not(${js})`
      , Vs = `${`.nav-link${Ws}, .list-group-item${Ws}, [role="tab"]${Ws}`}, [data-mdb-tab-initialized]`;
    let Ys = class t extends Ct {
        constructor(t) {
            super(t),
            this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'),
            this._parent && (this._setInitialAttributes(this._parent, this._getChildren()),
            _t.on(this._element, $s, t => this._keydown(t)))
        }
        static get NAME() {
            return "tab"
        }
        show() {
            const t = this._element;
            if (this._elemIsActive(t))
                return;
            const e = this._getActiveElem()
              , i = e ? _t.trigger(e, Es, {
                relatedTarget: t
            }) : null;
            _t.trigger(t, Os, {
                relatedTarget: e
            }).defaultPrevented || i && i.defaultPrevented || (this._deactivate(e, t),
            this._activate(t, e))
        }
        _activate(t, e) {
            if (!t)
                return;
            t.classList.add(Hs),
            this._activate(Yt.getElementFromSelector(t));
            this._queueCallback( () => {
                "tab" === t.getAttribute("role") ? (t.removeAttribute("tabindex"),
                t.setAttribute("aria-selected", !0),
                this._toggleDropDown(t, !0),
                _t.trigger(t, Ds, {
                    relatedTarget: e
                })) : t.classList.add(zs)
            }
            , t, t.classList.contains(Fs))
        }
        _deactivate(t, e) {
            if (!t)
                return;
            t.classList.remove(Hs),
            t.blur(),
            this._deactivate(Yt.getElementFromSelector(t));
            this._queueCallback( () => {
                "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1),
                t.setAttribute("tabindex", "-1"),
                this._toggleDropDown(t, !1),
                _t.trigger(t, Ms, {
                    relatedTarget: e
                })) : t.classList.remove(zs)
            }
            , t, t.classList.contains(Fs))
        }
        _keydown(e) {
            if (![Is, Ls, Ps, Rs, Ns, Bs].includes(e.key))
                return;
            e.stopPropagation(),
            e.preventDefault();
            const i = this._getChildren().filter(t => !U(t));
            let n;
            if ([Ns, Bs].includes(e.key))
                n = i[e.key === Ns ? 0 : i.length - 1];
            else {
                const t = [Ls, Rs].includes(e.key);
                n = et(i, e.target, t, !0)
            }
            n && (n.focus({
                preventScroll: !0
            }),
            t.getOrCreateInstance(n).show())
        }
        _getChildren() {
            return Yt.find(Vs, this._parent)
        }
        _getActiveElem() {
            return this._getChildren().find(t => this._elemIsActive(t)) || null
        }
        _setInitialAttributes(t, e) {
            this._setAttributeIfNotExists(t, "role", "tablist");
            for (const i of e)
                this._setInitialAttributesOnChild(i)
        }
        _setInitialAttributesOnChild(t) {
            t = this._getInnerElement(t);
            const e = this._elemIsActive(t)
              , i = this._getOuterElement(t);
            t.setAttribute("aria-selected", e),
            i !== t && this._setAttributeIfNotExists(i, "role", "presentation"),
            e || t.setAttribute("tabindex", "-1"),
            this._setAttributeIfNotExists(t, "role", "tab"),
            this._setInitialAttributesOnTargetPanel(t)
        }
        _setInitialAttributesOnTargetPanel(t) {
            const e = Yt.getElementFromSelector(t);
            e && (this._setAttributeIfNotExists(e, "role", "tabpanel"),
            t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `${t.id}`))
        }
        _toggleDropDown(t, e) {
            const i = this._getOuterElement(t);
            if (!i.classList.contains("dropdown"))
                return;
            const n = (t, n) => {
                const s = Yt.findOne(t, i);
                s && s.classList.toggle(n, e)
            }
            ;
            n(js, Hs),
            n(".dropdown-menu", zs),
            i.setAttribute("aria-expanded", e)
        }
        _setAttributeIfNotExists(t, e, i) {
            t.hasAttribute(e) || t.setAttribute(e, i)
        }
        _elemIsActive(t) {
            return t.classList.contains(Hs)
        }
        _getInnerElement(t) {
            return t.matches(Vs) ? t : Yt.findOne(Vs, t)
        }
        _getOuterElement(t) {
            return t.closest(".nav-item, .list-group-item") || t
        }
        static jQueryInterface(e) {
            return this.each(function() {
                const i = t.getOrCreateInstance(this);
                if ("string" == typeof e) {
                    if (void 0 === i[e] || e.startsWith("_") || "constructor" === e)
                        throw new TypeError(`No method named "${e}"`);
                    i[e]()
                }
            })
        }
    }
    ;
    const Xs = ".mdb.tab"
      , Ks = "show.bs.tab"
      , Us = "shown.bs.tab"
      , qs = `show${Xs}`
      , Zs = `shown${Xs}`
      , Gs = `hide${Xs}`
      , Qs = `hidden${Xs}`
      , Js = "active"
      , to = "fade"
      , eo = "show";
    class io extends Ys {
        constructor(t) {
            super(t),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        dispose() {
            I.off(this._element, Ks),
            I.off(this._element, Us),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        static get NAME() {
            return "tab"
        }
        show() {
            const t = this._element;
            if (this._elemIsActive(t))
                return;
            const e = this._getActiveElem();
            let i = null
              , n = null;
            e && (i = I.trigger(e, "hide.bs.tab", {
                relatedTarget: t
            }),
            n = I.trigger(e, Gs, {
                relatedTarget: t
            }));
            const s = I.trigger(t, Ks, {
                relatedTarget: e
            })
              , o = I.trigger(t, qs, {
                relatedTarget: e
            });
            s.defaultPrevented || o.defaultPrevented || i && i.defaultPrevented || n && n.defaultPrevented || (this._deactivate(e, t),
            this._activate(t, e))
        }
        _activate(t, e) {
            if (!t)
                return;
            t.classList.add(Js),
            this._activate(l(t));
            this._queueCallback( () => {
                "tab" === t.getAttribute("role") ? (t.focus(),
                t.removeAttribute("tabindex"),
                t.setAttribute("aria-selected", !0),
                this._toggleDropDown(t, !0),
                I.trigger(t, Us, {
                    relatedTarget: e
                }),
                I.trigger(t, Zs, {
                    relatedTarget: e
                })) : t.classList.add(eo)
            }
            , t, t.classList.contains(to))
        }
        _deactivate(t, e) {
            if (!t)
                return;
            t.classList.remove(Js),
            t.blur(),
            this._deactivate(l(t));
            this._queueCallback( () => {
                "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1),
                t.setAttribute("tabindex", "-1"),
                this._toggleDropDown(t, !1),
                I.trigger(t, "hidden.bs.tab", {
                    relatedTarget: e
                }),
                I.trigger(t, Qs, {
                    relatedTarget: e
                })) : t.classList.remove(eo)
            }
            , t, t.classList.contains(to))
        }
    }
    const no = "tooltip"
      , so = [{
        name: "show"
    }, {
        name: "shown"
    }, {
        name: "hide"
    }, {
        name: "hidden"
    }, {
        name: "inserted"
    }];
    let oo = class extends es {
        constructor(t, e) {
            super(t, e),
            this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        dispose() {
            I.off(this._element, "show.bs.tooltip"),
            I.off(this._element, "shown.bs.tooltip"),
            I.off(this._element, "hide.bs.tooltip"),
            I.off(this._element, "hidden.bs.tooltip"),
            I.off(this._element, "inserted.bs.tooltip"),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        static get NAME() {
            return no
        }
        _init() {
            this._bindMdbEvents()
        }
        _bindMdbEvents() {
            I.extend(this._element, so, no)
        }
    }
    ;
    ( () => {
        var t = {
            454: (t, e, i) => {
                i.d(e, {
                    Z: () => o
                });
                var n = i(645)
                  , s = i.n(n)()(function(t) {
                    return t[1]
                });
                s.push([t.id, "INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}", ""]);
                const o = s
            }
            ,
            645: t => {
                t.exports = function(t) {
                    var e = [];
                    return e.toString = function() {
                        return this.map(function(e) {
                            var i = t(e);
                            return e[2] ? "@media ".concat(e[2], " {").concat(i, "}") : i
                        }).join("")
                    }
                    ,
                    e.i = function(t, i, n) {
                        "string" == typeof t && (t = [[null, t, ""]]);
                        var s = {};
                        if (n)
                            for (var o = 0; o < this.length; o++) {
                                var a = this[o][0];
                                null != a && (s[a] = !0)
                            }
                        for (var r = 0; r < t.length; r++) {
                            var l = [].concat(t[r]);
                            n && s[l[0]] || (i && (l[2] ? l[2] = "".concat(i, " and ").concat(l[2]) : l[2] = i),
                            e.push(l))
                        }
                    }
                    ,
                    e
                }
            }
            ,
            810: () => {
                !function() {
                    if ("undefined" != typeof window)
                        try {
                            var t = new window.CustomEvent("test",{
                                cancelable: !0
                            });
                            if (t.preventDefault(),
                            !0 !== t.defaultPrevented)
                                throw new Error("Could not prevent default")
                        } catch (i) {
                            var e = function(t, e) {
                                var i, n;
                                return (e = e || {}).bubbles = !!e.bubbles,
                                e.cancelable = !!e.cancelable,
                                (i = document.createEvent("CustomEvent")).initCustomEvent(t, e.bubbles, e.cancelable, e.detail),
                                n = i.preventDefault,
                                i.preventDefault = function() {
                                    n.call(this);
                                    try {
                                        Object.defineProperty(this, "defaultPrevented", {
                                            get: function() {
                                                return !0
                                            }
                                        })
                                    } catch (t) {
                                        this.defaultPrevented = !0
                                    }
                                }
                                ,
                                i
                            };
                            e.prototype = window.Event.prototype,
                            window.CustomEvent = e
                        }
                }()
            }
            ,
            379: (t, e, i) => {
                var n, s, o = (s = {},
                function(t) {
                    if (void 0 === s[t]) {
                        var e = document.querySelector(t);
                        if (window.HTMLIFrameElement && e instanceof window.HTMLIFrameElement)
                            try {
                                e = e.contentDocument.head
                            } catch (i) {
                                e = null
                            }
                        s[t] = e
                    }
                    return s[t]
                }
                ), a = [];
                function r(t) {
                    for (var e = -1, i = 0; i < a.length; i++)
                        if (a[i].identifier === t) {
                            e = i;
                            break
                        }
                    return e
                }
                function l(t, e) {
                    for (var i = {}, n = [], s = 0; s < t.length; s++) {
                        var o = t[s]
                          , l = e.base ? o[0] + e.base : o[0]
                          , h = i[l] || 0
                          , c = "".concat(l, " ").concat(h);
                        i[l] = h + 1;
                        var d = r(c)
                          , u = {
                            css: o[1],
                            media: o[2],
                            sourceMap: o[3]
                        };
                        -1 !== d ? (a[d].references++,
                        a[d].updater(u)) : a.push({
                            identifier: c,
                            updater: m(u, e),
                            references: 1
                        }),
                        n.push(c)
                    }
                    return n
                }
                function h(t) {
                    var e = document.createElement("style")
                      , n = t.attributes || {};
                    if (void 0 === n.nonce) {
                        var s = i.nc;
                        s && (n.nonce = s)
                    }
                    if (Object.keys(n).forEach(function(t) {
                        e.setAttribute(t, n[t])
                    }),
                    "function" == typeof t.insert)
                        t.insert(e);
                    else {
                        var a = o(t.insert || "head");
                        if (!a)
                            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                        a.appendChild(e)
                    }
                    return e
                }
                var c, d = (c = [],
                function(t, e) {
                    return c[t] = e,
                    c.filter(Boolean).join("\n")
                }
                );
                function u(t, e, i, n) {
                    var s = i ? "" : n.media ? "@media ".concat(n.media, " {").concat(n.css, "}") : n.css;
                    if (t.styleSheet)
                        t.styleSheet.cssText = d(e, s);
                    else {
                        var o = document.createTextNode(s)
                          , a = t.childNodes;
                        a[e] && t.removeChild(a[e]),
                        a.length ? t.insertBefore(o, a[e]) : t.appendChild(o)
                    }
                }
                function p(t, e, i) {
                    var n = i.css
                      , s = i.media
                      , o = i.sourceMap;
                    if (s ? t.setAttribute("media", s) : t.removeAttribute("media"),
                    o && "undefined" != typeof btoa && (n += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o)))), " */")),
                    t.styleSheet)
                        t.styleSheet.cssText = n;
                    else {
                        for (; t.firstChild; )
                            t.removeChild(t.firstChild);
                        t.appendChild(document.createTextNode(n))
                    }
                }
                var f = null
                  , g = 0;
                function m(t, e) {
                    var i, n, s;
                    if (e.singleton) {
                        var o = g++;
                        i = f || (f = h(e)),
                        n = u.bind(null, i, o, !1),
                        s = u.bind(null, i, o, !0)
                    } else
                        i = h(e),
                        n = p.bind(null, i, e),
                        s = function() {
                            !function(t) {
                                if (null === t.parentNode)
                                    return !1;
                                t.parentNode.removeChild(t)
                            }(i)
                        }
                        ;
                    return n(t),
                    function(e) {
                        if (e) {
                            if (e.css === t.css && e.media === t.media && e.sourceMap === t.sourceMap)
                                return;
                            n(t = e)
                        } else
                            s()
                    }
                }
                t.exports = function(t, e) {
                    (e = e || {}).singleton || "boolean" == typeof e.singleton || (e.singleton = (void 0 === n && (n = Boolean(window && document && document.all && !window.atob)),
                    n));
                    var i = l(t = t || [], e);
                    return function(t) {
                        if (t = t || [],
                        "[object Array]" === Object.prototype.toString.call(t)) {
                            for (var n = 0; n < i.length; n++) {
                                var s = r(i[n]);
                                a[s].references--
                            }
                            for (var o = l(t, e), h = 0; h < i.length; h++) {
                                var c = r(i[h]);
                                0 === a[c].references && (a[c].updater(),
                                a.splice(c, 1))
                            }
                            i = o
                        }
                    }
                }
            }
        }
          , e = {};
        function i(n) {
            var s = e[n];
            if (void 0 !== s)
                return s.exports;
            var o = e[n] = {
                id: n,
                exports: {}
            };
            return t[n](o, o.exports, i),
            o.exports
        }
        i.n = t => {
            var e = t && t.__esModule ? () => t.default : () => t;
            return i.d(e, {
                a: e
            }),
            e
        }
        ,
        i.d = (t, e) => {
            for (var n in e)
                i.o(e, n) && !i.o(t, n) && Object.defineProperty(t, n, {
                    enumerable: !0,
                    get: e[n]
                })
        }
        ,
        i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e),
        ( () => {
            var t = i(379)
              , e = i.n(t)
              , n = i(454);
            function s(t) {
                if (!t.hasAttribute("autocompleted")) {
                    t.setAttribute("autocompleted", "");
                    var e = new window.CustomEvent("onautocomplete",{
                        bubbles: !0,
                        cancelable: !0,
                        detail: null
                    });
                    t.dispatchEvent(e) || (t.value = "")
                }
            }
            function o(t) {
                t.hasAttribute("autocompleted") && (t.removeAttribute("autocompleted"),
                t.dispatchEvent(new window.CustomEvent("onautocomplete",{
                    bubbles: !0,
                    cancelable: !1,
                    detail: null
                })))
            }
            e()(n.Z, {
                insert: "head",
                singleton: !1
            }),
            n.Z.locals,
            i(810),
            document.addEventListener("animationstart", function(t) {
                "onautofillstart" === t.animationName ? s(t.target) : o(t.target)
            }, !0),
            document.addEventListener("input", function(t) {
                "insertReplacementText" !== t.inputType && "data"in t ? o(t.target) : s(t.target)
            }, !0)
        }
        )()
    }
    )();
    class ao {
        constructor(t) {
            (t = c(t)) && (this._element = t,
            s.setData(this._element, this.constructor.DATA_KEY, this))
        }
        dispose() {
            s.removeData(this._element, this.constructor.DATA_KEY),
            I.off(this._element, this.constructor.EVENT_KEY),
            Object.getOwnPropertyNames(this).forEach(t => {
                this[t] = null
            }
            )
        }
        static getInstance(t) {
            return s.getData(c(t), this.DATA_KEY)
        }
        static getOrCreateInstance(t, e={}) {
            return this.getInstance(t) || new this(t,"object" == typeof e ? e : null)
        }
        static get NAME() {
            throw new Error('You have to implement the static method "NAME", for each component!')
        }
        static get DATA_KEY() {
            return `mdb.${this.NAME}`
        }
        static get EVENT_KEY() {
            return `.${this.DATA_KEY}`
        }
    }
    const ro = "active"
      , lo = "form-notch"
      , ho = "form-notch-leading"
      , co = "form-notch-middle"
      , uo = `.${lo}`
      , po = `.${ho}`
      , fo = `.${co}`;
    class go extends ao {
        constructor(t) {
            super(t),
            this._label = null,
            this._labelWidth = 0,
            this._labelMarginLeft = 0,
            this._notchLeading = null,
            this._notchMiddle = null,
            this._notchTrailing = null,
            this._initiated = !1,
            this._helper = null,
            this._counter = !1,
            this._counterElement = null,
            this._maxLength = 0,
            this._leadingIcon = null,
            this._element && (this.init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor))
        }
        static get NAME() {
            return "input"
        }
        get input() {
            return B.findOne("input", this._element) || B.findOne("textarea", this._element)
        }
        init() {
            this._initiated || (this._getLabelData(),
            this._applyDivs(),
            this._applyNotch(),
            this._activate(),
            this._getHelper(),
            this._getCounter(),
            this._initiated = !0)
        }
        update() {
            this._getLabelData(),
            this._getNotchData(),
            this._applyNotch(),
            this._activate(),
            this._getHelper(),
            this._getCounter()
        }
        forceActive() {
            N.addClass(this.input, ro)
        }
        forceInactive() {
            N.removeClass(this.input, ro)
        }
        dispose() {
            this._removeBorder(),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _getLabelData() {
            this._label = B.findOne("label", this._element),
            null === this._label ? this._showPlaceholder() : (this._getLabelWidth(),
            this._getLabelPositionInInputGroup(),
            this._toggleDefaultDatePlaceholder())
        }
        _getHelper() {
            this._helper = B.findOne(".form-helper", this._element)
        }
        _getCounter() {
            this._counter = N.getDataAttribute(this.input, "showcounter"),
            this._counter && (this._maxLength = this.input.maxLength,
            this._showCounter())
        }
        _showCounter() {
            if (B.find(".form-counter", this._element).length > 0)
                return;
            this._counterElement = document.createElement("div"),
            N.addClass(this._counterElement, "form-counter");
            const t = this.input.value.length;
            this._counterElement.innerHTML = `${t} / ${this._maxLength}`,
            this._helper.appendChild(this._counterElement),
            this._bindCounter()
        }
        _bindCounter() {
            I.on(this.input, "input", () => {
                const t = this.input.value.length;
                this._counterElement.innerHTML = `${t} / ${this._maxLength}`
            }
            )
        }
        _toggleDefaultDatePlaceholder(t=this.input) {
            const e = t.getAttribute("type");
            if (!["date", "time", "datetime-local", "month", "week"].includes(e))
                return;
            document.activeElement === t || t.value ? t.style.opacity = 1 : t.style.opacity = 0
        }
        _showPlaceholder() {
            N.addClass(this.input, "placeholder-active")
        }
        _getNotchData() {
            this._notchMiddle = B.findOne(fo, this._element),
            this._notchLeading = B.findOne(po, this._element)
        }
        _getLabelWidth() {
            this._labelWidth = .8 * this._label.clientWidth + 8
        }
        _getLabelPositionInInputGroup() {
            if (this._labelMarginLeft = 0,
            !this._element.classList.contains("input-group"))
                return;
            const t = this.input
              , e = B.prev(t, ".input-group-text")[0];
            this._labelMarginLeft = void 0 === e ? 0 : e.offsetWidth - 1
        }
        _applyDivs() {
            const t = B.find(uo, this._element)
              , e = _("div");
            N.addClass(e, lo),
            this._notchLeading = _("div"),
            N.addClass(this._notchLeading, ho),
            this._notchMiddle = _("div"),
            N.addClass(this._notchMiddle, co),
            this._notchTrailing = _("div"),
            N.addClass(this._notchTrailing, "form-notch-trailing"),
            t.length >= 1 || (e.append(this._notchLeading),
            e.append(this._notchMiddle),
            e.append(this._notchTrailing),
            this._element.append(e))
        }
        _applyNotch() {
            this._notchMiddle.style.width = `${this._labelWidth}px`,
            this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`,
            null !== this._label && (this._label.style.marginLeft = `${this._labelMarginLeft}px`)
        }
        _removeBorder() {
            const t = B.findOne(uo, this._element);
            t && t.remove()
        }
        _activate(t) {
            g( () => {
                if (this._getElements(t),
                !this._element)
                    return;
                const e = t ? t.target : this.input;
                "" !== e.value && N.addClass(e, ro),
                this._toggleDefaultDatePlaceholder(e)
            }
            )
        }
        _getElements(t) {
            let e;
            if (t && (this._element = t.target.parentNode,
            this._label = B.findOne("label", this._element),
            e = N.getDataAttribute(this._element, `${this.constructor.NAME}-initialized`)),
            e && t && this._label) {
                const e = this._labelWidth;
                this._getLabelData(),
                e !== this._labelWidth && (this._notchMiddle = B.findOne(".form-notch-middle", t.target.parentNode),
                this._notchLeading = B.findOne(po, t.target.parentNode),
                this._applyNotch())
            }
        }
        _deactivate(t) {
            const e = t ? t.target : this.input;
            "" === e.value && e.classList.remove(ro),
            this._toggleDefaultDatePlaceholder(e)
        }
        static activate(t) {
            return function(e) {
                t._activate(e)
            }
        }
        static deactivate(t) {
            return function(e) {
                t._deactivate(e)
            }
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                let i = s.getData(this, "mdb.input");
                const n = "object" == typeof t && t;
                if ((i || !/dispose/.test(t)) && (i || (i = new go(this,n)),
                "string" == typeof t)) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
    }
    const mo = ".bs.collapse"
      , _o = `show${mo}`
      , bo = `shown${mo}`
      , vo = `hide${mo}`
      , yo = `hidden${mo}`
      , xo = "show"
      , wo = "collapse"
      , Co = "collapsing"
      , ko = `:scope .${wo} .${wo}`
      , So = "[data-mdb-collapse-init]"
      , To = {
        parent: null,
        toggle: !0
    }
      , Ao = {
        parent: "(null|element)",
        toggle: "boolean"
    };
    let Eo = class t extends Ct {
        constructor(t, e) {
            super(t, e),
            this._isTransitioning = !1,
            this._triggerArray = [];
            const i = Yt.find(So);
            for (const n of i) {
                const t = Yt.getSelectorFromElement(n)
                  , e = Yt.find(t).filter(t => t === this._element);
                null !== t && e.length && this._triggerArray.push(n)
            }
            this._initializeChildren(),
            this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()),
            this._config.toggle && this.toggle()
        }
        static get Default() {
            return To
        }
        static get DefaultType() {
            return Ao
        }
        static get NAME() {
            return "collapse"
        }
        toggle() {
            this._isShown() ? this.hide() : this.show()
        }
        show() {
            if (this._isTransitioning || this._isShown())
                return;
            let e = [];
            if (this._config.parent && (e = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter(t => t !== this._element).map(e => t.getOrCreateInstance(e, {
                toggle: !1
            }))),
            e.length && e[0]._isTransitioning)
                return;
            if (_t.trigger(this._element, _o).defaultPrevented)
                return;
            for (const t of e)
                t.hide();
            const i = this._getDimension();
            this._element.classList.remove(wo),
            this._element.classList.add(Co),
            this._element.style[i] = 0,
            this._addAriaAndCollapsedClass(this._triggerArray, !0),
            this._isTransitioning = !0;
            const n = `scroll${i[0].toUpperCase() + i.slice(1)}`;
            this._queueCallback( () => {
                this._isTransitioning = !1,
                this._element.classList.remove(Co),
                this._element.classList.add(wo, xo),
                this._element.style[i] = "",
                _t.trigger(this._element, bo)
            }
            , this._element, !0),
            this._element.style[i] = `${this._element[n]}px`
        }
        hide() {
            if (this._isTransitioning || !this._isShown())
                return;
            if (_t.trigger(this._element, vo).defaultPrevented)
                return;
            const t = this._getDimension();
            this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`,
            G(this._element),
            this._element.classList.add(Co),
            this._element.classList.remove(wo, xo);
            for (const e of this._triggerArray) {
                const t = Yt.getElementFromSelector(e);
                t && !this._isShown(t) && this._addAriaAndCollapsedClass([e], !1)
            }
            this._isTransitioning = !0;
            this._element.style[t] = "",
            this._queueCallback( () => {
                this._isTransitioning = !1,
                this._element.classList.remove(Co),
                this._element.classList.add(wo),
                _t.trigger(this._element, yo)
            }
            , this._element, !0)
        }
        _isShown(t=this._element) {
            return t.classList.contains(xo)
        }
        _configAfterMerge(t) {
            return t.toggle = Boolean(t.toggle),
            t.parent = X(t.parent),
            t
        }
        _getDimension() {
            return this._element.classList.contains("collapse-horizontal") ? "width" : "height"
        }
        _initializeChildren() {
            if (!this._config.parent)
                return;
            const t = this._getFirstLevelChildren(So);
            for (const e of t) {
                const t = Yt.getElementFromSelector(e);
                t && this._addAriaAndCollapsedClass([e], this._isShown(t))
            }
        }
        _getFirstLevelChildren(t) {
            const e = Yt.find(ko, this._config.parent);
            return Yt.find(t, this._config.parent).filter(t => !e.includes(t))
        }
        _addAriaAndCollapsedClass(t, e) {
            if (t.length)
                for (const i of t)
                    i.classList.toggle("collapsed", !e),
                    i.setAttribute("aria-expanded", e)
        }
        static jQueryInterface(e) {
            const i = {};
            return "string" == typeof e && /show|hide/.test(e) && (i.toggle = !1),
            this.each(function() {
                const n = t.getOrCreateInstance(this, i);
                if ("string" == typeof e) {
                    if (void 0 === n[e])
                        throw new TypeError(`No method named "${e}"`);
                    n[e]()
                }
            })
        }
    }
    ;
    const Mo = "collapse"
      , Oo = [{
        name: "show"
    }, {
        name: "shown"
    }, {
        name: "hide"
    }, {
        name: "hidden"
    }];
    class Do extends Eo {
        constructor(t, e={}) {
            super(t, e),
            this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        dispose() {
            I.off(this._element, "show.bs.collapse"),
            I.off(this._element, "shown.bs.collapse"),
            I.off(this._element, "hide.bs.collapse"),
            I.off(this._element, "hidden.bs.collapse"),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        static get NAME() {
            return Mo
        }
        _init() {
            this._bindMdbEvents()
        }
        _bindMdbEvents() {
            I.extend(this._element, Oo, Mo)
        }
    }
    const $o = "dropdown"
      , Io = ".bs.dropdown"
      , Lo = "ArrowUp"
      , Po = "ArrowDown"
      , Ro = `hide${Io}`
      , No = `hidden${Io}`
      , Bo = `show${Io}`
      , Ho = `shown${Io}`
      , Fo = "show"
      , zo = "[data-mdb-dropdown-initialized]:not(.disabled):not(:disabled)"
      , jo = `${zo}.${Fo}`
      , Wo = ".dropdown-menu"
      , Vo = Q() ? "top-end" : "top-start"
      , Yo = Q() ? "top-start" : "top-end"
      , Xo = Q() ? "bottom-end" : "bottom-start"
      , Ko = Q() ? "bottom-start" : "bottom-end"
      , Uo = Q() ? "left-start" : "right-start"
      , qo = Q() ? "right-start" : "left-start"
      , Zo = {
        autoClose: !0,
        boundary: "clippingParents",
        display: "dynamic",
        offset: [0, 2],
        popperConfig: null,
        reference: "toggle"
    }
      , Go = {
        autoClose: "(boolean|string)",
        boundary: "(string|element)",
        display: "string",
        offset: "(array|string|function)",
        popperConfig: "(null|object|function)",
        reference: "(string|element|object)"
    };
    let Qo = class t extends Ct {
        constructor(t, e) {
            super(t, e),
            this._popper = null,
            this._parent = this._element.parentNode,
            this._menu = Yt.next(this._element, Wo)[0] || Yt.prev(this._element, Wo)[0] || Yt.findOne(Wo, this._parent),
            this._inNavbar = this._detectNavbar()
        }
        static get Default() {
            return Zo
        }
        static get DefaultType() {
            return Go
        }
        static get NAME() {
            return $o
        }
        toggle() {
            return this._isShown() ? this.hide() : this.show()
        }
        show() {
            if (U(this._element) || this._isShown())
                return;
            const t = {
                relatedTarget: this._element
            };
            if (!_t.trigger(this._element, Bo, t).defaultPrevented) {
                if (this._createPopper(),
                "ontouchstart"in document.documentElement && !this._parent.closest(".navbar-nav"))
                    for (const t of [].concat(...document.body.children))
                        _t.on(t, "mouseover", Z);
                this._element.focus(),
                this._element.setAttribute("aria-expanded", !0),
                this._menu.classList.add(Fo),
                this._element.classList.add(Fo),
                _t.trigger(this._element, Ho, t)
            }
        }
        hide() {
            if (U(this._element) || !this._isShown())
                return;
            const t = {
                relatedTarget: this._element
            };
            this._completeHide(t)
        }
        dispose() {
            this._popper && this._popper.destroy(),
            super.dispose()
        }
        update() {
            this._inNavbar = this._detectNavbar(),
            this._popper && this._popper.update()
        }
        _completeHide(t) {
            if (!_t.trigger(this._element, Ro, t).defaultPrevented) {
                if ("ontouchstart"in document.documentElement)
                    for (const t of [].concat(...document.body.children))
                        _t.off(t, "mouseover", Z);
                this._popper && this._popper.destroy(),
                this._menu.classList.remove(Fo),
                this._element.classList.remove(Fo),
                this._element.setAttribute("aria-expanded", "false"),
                xt.removeDataAttribute(this._menu, "popper"),
                _t.trigger(this._element, No, t)
            }
        }
        _getConfig(t) {
            if ("object" == typeof (t = super._getConfig(t)).reference && !Y(t.reference) && "function" != typeof t.reference.getBoundingClientRect)
                throw new TypeError(`${$o.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
            return t
        }
        _createPopper() {
            if (void 0 === Pn)
                throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
            let t = this._element;
            "parent" === this._config.reference ? t = this._parent : Y(this._config.reference) ? t = X(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference);
            const e = this._getPopperConfig();
            this._popper = Ln(t, this._menu, e)
        }
        _isShown() {
            return this._menu.classList.contains(Fo)
        }
        _getPlacement() {
            const t = this._parent;
            if (t.classList.contains("dropend"))
                return Uo;
            if (t.classList.contains("dropstart"))
                return qo;
            if (t.classList.contains("dropup-center"))
                return "top";
            if (t.classList.contains("dropdown-center"))
                return "bottom";
            const e = "end" === getComputedStyle(this._menu).getPropertyValue("--mdb-position").trim();
            return t.classList.contains("dropup") ? e ? Yo : Vo : e ? Ko : Xo
        }
        _detectNavbar() {
            return null !== this._element.closest(".navbar")
        }
        _getOffset() {
            const {offset: t} = this._config;
            return "string" == typeof t ? t.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof t ? e => t(e, this._element) : t
        }
        _getPopperConfig() {
            const t = {
                placement: this._getPlacement(),
                modifiers: [{
                    name: "preventOverflow",
                    options: {
                        boundary: this._config.boundary
                    }
                }, {
                    name: "offset",
                    options: {
                        offset: this._getOffset()
                    }
                }]
            };
            return (this._inNavbar || "static" === this._config.display) && (xt.setDataAttribute(this._menu, "popper", "static"),
            t.modifiers = [{
                name: "applyStyles",
                enabled: !1
            }]),
            {
                ...t,
                ...J(this._config.popperConfig, [t])
            }
        }
        _selectMenuItem({key: t, target: e}) {
            const i = Yt.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(t => K(t));
            i.length && et(i, e, t === Po, !i.includes(e)).focus()
        }
        static jQueryInterface(e) {
            return this.each(function() {
                const i = t.getOrCreateInstance(this, e);
                if ("string" == typeof e) {
                    if (void 0 === i[e])
                        throw new TypeError(`No method named "${e}"`);
                    i[e]()
                }
            })
        }
        static clearMenus(e) {
            if (2 === e.button || "keyup" === e.type && "Tab" !== e.key)
                return;
            const i = Yt.find(jo);
            for (const n of i) {
                const i = t.getInstance(n);
                if (!i || !1 === i._config.autoClose)
                    continue;
                const s = e.composedPath()
                  , o = s.includes(i._menu);
                if (s.includes(i._element) || "inside" === i._config.autoClose && !o || "outside" === i._config.autoClose && o)
                    continue;
                if (i._menu.contains(e.target) && ("keyup" === e.type && "Tab" === e.key || /input|select|option|textarea|form/i.test(e.target.tagName)))
                    continue;
                const a = {
                    relatedTarget: i._element
                };
                "click" === e.type && (a.clickEvent = e),
                i._completeHide(a)
            }
        }
        static dataApiKeydownHandler(e) {
            const i = /input|textarea/i.test(e.target.tagName)
              , n = "Escape" === e.key
              , s = [Lo, Po].includes(e.key);
            if (!s && !n)
                return;
            if (i && !n)
                return;
            e.preventDefault();
            const o = this.matches(zo) ? this : Yt.prev(this, zo)[0] || Yt.next(this, zo)[0] || Yt.findOne(zo, e.delegateTarget.parentNode)
              , a = t.getOrCreateInstance(o);
            if (s)
                return e.stopPropagation(),
                a.show(),
                void a._selectMenuItem(e);
            a._isShown() && (e.stopPropagation(),
            a.hide(),
            o.focus())
        }
    }
    ;
    const Jo = "dropdown"
      , ta = `.${`mdb.${Jo}`}`
      , ea = {
        offset: [0, 2],
        boundary: "clippingParents",
        reference: "toggle",
        display: "dynamic",
        popperConfig: null,
        dropdownAnimation: "on"
    }
      , ia = {
        offset: "(array|string|function)",
        boundary: "(string|element)",
        reference: "(string|element|object)",
        display: "string",
        popperConfig: "(null|object|function)",
        dropdownAnimation: "string"
    }
      , na = "hide.bs.dropdown"
      , sa = "hidden.bs.dropdown"
      , oa = "show.bs.dropdown"
      , aa = "shown.bs.dropdown"
      , ra = `hide${ta}`
      , la = `hidden${ta}`
      , ha = `show${ta}`
      , ca = `shown${ta}`
      , da = "animation"
      , ua = "fade-in"
      , pa = "fade-out";
    class fa extends Qo {
        constructor(t, e) {
            super(t, e),
            this._config = this._getConfig(e),
            this._menuStyle = "",
            this._popperPlacement = "",
            this._mdbPopperConfig = "";
            const i = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
            "on" !== this._config.dropdownAnimation || i || this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        dispose() {
            I.off(this._element, oa),
            I.off(this._parent, aa),
            I.off(this._parent, na),
            I.off(this._parent, sa),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        static get NAME() {
            return Jo
        }
        _init() {
            this._bindShowEvent(),
            this._bindShownEvent(),
            this._bindHideEvent(),
            this._bindHiddenEvent()
        }
        _getConfig(t) {
            const e = {
                ...ea,
                ...N.getDataAttributes(this._element),
                ...t
            };
            return d(Jo, e, ia),
            e
        }
        _getOffset() {
            const {offset: t} = this._config;
            return "string" == typeof t ? t.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof t ? e => t(e, this._element) : t
        }
        _getPopperConfig() {
            const t = {
                placement: this._getPlacement(),
                modifiers: [{
                    name: "preventOverflow",
                    options: {
                        boundary: this._config.boundary
                    }
                }, {
                    name: "offset",
                    options: {
                        offset: this._getOffset()
                    }
                }]
            };
            return "static" === this._config.display && (N.setDataAttribute(this._menu, "popper", "static"),
            t.modifiers = [{
                name: "applyStyles",
                enabled: !1
            }]),
            {
                ...t,
                ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(t) : this._config.popperConfig
            }
        }
        _bindShowEvent() {
            I.on(this._element, oa, t => {
                I.trigger(this._element, ha, {
                    relatedTarget: t.relatedTarget
                }).defaultPrevented ? t.preventDefault() : this._dropdownAnimationStart("show")
            }
            )
        }
        _bindShownEvent() {
            I.on(this._parent, aa, t => {
                I.trigger(this._parent, ca, {
                    relatedTarget: t.relatedTarget
                }).defaultPrevented && t.preventDefault()
            }
            )
        }
        _bindHideEvent() {
            I.on(this._parent, na, t => {
                I.trigger(this._parent, ra, {
                    relatedTarget: t.relatedTarget
                }).defaultPrevented ? t.preventDefault() : (this._menuStyle = this._menu.style.cssText,
                this._popperPlacement = this._menu.getAttribute("data-popper-placement"),
                this._mdbPopperConfig = this._menu.getAttribute("data-mdb-popper"))
            }
            )
        }
        _bindHiddenEvent() {
            I.on(this._parent, sa, t => {
                I.trigger(this._parent, la, {
                    relatedTarget: t.relatedTarget
                }).defaultPrevented ? t.preventDefault() : ("static" !== this._config.display && "" !== this._menuStyle && (this._menu.style.cssText = this._menuStyle),
                this._menu.setAttribute("data-popper-placement", this._popperPlacement),
                this._menu.setAttribute("data-mdb-popper", this._mdbPopperConfig),
                this._dropdownAnimationStart("hide"))
            }
            )
        }
        _dropdownAnimationStart(t) {
            if ("show" === t)
                this._menu.classList.add(da, ua),
                this._menu.classList.remove(pa);
            else
                this._menu.classList.add(da, pa),
                this._menu.classList.remove(ua);
            this._bindAnimationEnd()
        }
        _bindAnimationEnd() {
            I.one(this._menu, "animationend", () => {
                this._menu.classList.remove(da, pa, ua)
            }
            )
        }
    }
    const ga = "ripple"
      , ma = "ripple-surface"
      , _a = "ripple-wave"
      , ba = "input-wrapper"
      , va = [".btn", `[data-mdb-${ga}-init]`]
      , ya = "ripple-surface-unbound"
      , xa = [0, 0, 0]
      , wa = ["primary", "secondary", "success", "danger", "warning", "info", "light", "dark"]
      , Ca = {
        rippleCentered: !1,
        rippleColor: "",
        rippleDuration: "500ms",
        rippleRadius: 0,
        rippleUnbound: !1
    }
      , ka = {
        rippleCentered: "boolean",
        rippleColor: "string",
        rippleDuration: "string",
        rippleRadius: "number",
        rippleUnbound: "boolean"
    };
    class Sa extends ao {
        constructor(t, e) {
            super(t),
            this._options = this._getConfig(e),
            this._element && (N.addClass(this._element, ma),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)),
            this._clickHandler = this._createRipple.bind(this),
            this._rippleTimer = null,
            this._isMinWidthSet = !1,
            this._rippleInSpan = !1,
            this.init()
        }
        static get NAME() {
            return ga
        }
        init() {
            this._addClickEvent(this._element)
        }
        dispose() {
            I.off(this._element, "mousedown", this._clickHandler),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _autoInit(t) {
            va.forEach(e => {
                B.closest(t.target, e) && (this._element = B.closest(t.target, e))
            }
            );
            const e = N.getDataAttributes(this._element);
            if (!this._element.classList.contains("btn") || !1 !== e.rippleInit) {
                if (this._options = this._getConfig(),
                "input" === this._element.tagName.toLowerCase()) {
                    const t = this._element.parentNode;
                    if (this._rippleInSpan = !0,
                    "span" === t.tagName.toLowerCase() && t.classList.contains(ma))
                        this._element = t;
                    else {
                        const e = getComputedStyle(this._element).boxShadow
                          , i = this._element
                          , n = document.createElement("span");
                        i.classList.contains("btn-block") && (n.style.display = "block"),
                        I.one(n, "mouseup", t => {
                            0 === t.button && i.click()
                        }
                        ),
                        n.classList.add(ma, ba),
                        N.addStyle(n, {
                            border: 0,
                            "box-shadow": e
                        }),
                        t.replaceChild(n, this._element),
                        n.appendChild(this._element),
                        this._element = n
                    }
                    this._element.focus()
                }
                this._element.style.minWidth || (N.style(this._element, {
                    "min-width": `${getComputedStyle(this._element).width}`
                }),
                this._isMinWidthSet = !0),
                N.addClass(this._element, ma),
                this._createRipple(t)
            }
        }
        _addClickEvent(t) {
            I.on(t, "mousedown", this._clickHandler)
        }
        _getEventLayer(t) {
            return {
                layerX: Math.round(t.clientX - t.target.getBoundingClientRect().x),
                layerY: Math.round(t.clientY - t.target.getBoundingClientRect().y)
            }
        }
        _createRipple(t) {
            if (null === this._element)
                return;
            N.hasClass(this._element, ma) || N.addClass(this._element, ma);
            const {layerX: e, layerY: i} = this._getEventLayer(t)
              , n = e
              , s = i
              , o = this._element.offsetHeight
              , a = this._element.offsetWidth
              , r = this._durationToMsNumber(this._options.rippleDuration)
              , l = {
                offsetX: this._options.rippleCentered ? o / 2 : n,
                offsetY: this._options.rippleCentered ? a / 2 : s,
                height: o,
                width: a
            }
              , h = this._getDiameter(l)
              , c = this._options.rippleRadius || h / 2
              , d = .5 * r
              , u = r - .5 * r
              , p = {
                left: this._options.rippleCentered ? a / 2 - c + "px" : n - c + "px",
                top: this._options.rippleCentered ? o / 2 - c + "px" : s - c + "px",
                height: `${2 * this._options.rippleRadius || h}px`,
                width: `${2 * this._options.rippleRadius || h}px`,
                transitionDelay: `0s, ${d}ms`,
                transitionDuration: `${r}ms, ${u}ms`
            }
              , f = _("div");
            this._createHTMLRipple({
                wrapper: this._element,
                ripple: f,
                styles: p
            }),
            this._removeHTMLRipple({
                ripple: f,
                duration: r
            })
        }
        _createHTMLRipple({wrapper: t, ripple: e, styles: i}) {
            Object.keys(i).forEach(t => e.style[t] = i[t]),
            e.classList.add(_a),
            "" !== this._options.rippleColor && (this._removeOldColorClasses(t),
            this._addColor(e, t)),
            this._toggleUnbound(t),
            this._appendRipple(e, t)
        }
        _removeHTMLRipple({ripple: t, duration: e}) {
            this._rippleTimer && (clearTimeout(this._rippleTimer),
            this._rippleTimer = null),
            this._rippleTimer = setTimeout( () => {
                t && (t.remove(),
                this._element && (B.find(`.${_a}`, this._element).forEach(t => {
                    t.remove()
                }
                ),
                this._isMinWidthSet && (N.style(this._element, {
                    "min-width": ""
                }),
                this._isMinWidthSet = !1),
                this._rippleInSpan && this._element.classList.contains(ba) ? this._removeWrapperSpan() : N.removeClass(this._element, ma)))
            }
            , e)
        }
        _removeWrapperSpan() {
            const t = this._element.firstChild;
            this._element.replaceWith(t),
            this._element = t,
            this._element.focus(),
            this._rippleInSpan = !1
        }
        _durationToMsNumber(t) {
            return Number(t.replace("ms", "").replace("s", "000"))
        }
        _getConfig(t={}) {
            const e = N.getDataAttributes(this._element);
            return t = {
                ...Ca,
                ...e,
                ...t
            },
            d(ga, t, ka),
            t
        }
        _getDiameter({offsetX: t, offsetY: e, height: i, width: n}) {
            const s = e <= i / 2
              , o = t <= n / 2
              , a = (t, e) => Math.sqrt(t ** 2 + e ** 2)
              , r = e === i / 2 && t === n / 2
              , l = !0 === s && !1 === o
              , h = !0 === s && !0 === o
              , c = !1 === s && !0 === o
              , d = !1 === s && !1 === o
              , u = {
                topLeft: a(t, e),
                topRight: a(n - t, e),
                bottomLeft: a(t, i - e),
                bottomRight: a(n - t, i - e)
            };
            let p = 0;
            return r || d ? p = u.topLeft : c ? p = u.topRight : h ? p = u.bottomRight : l && (p = u.bottomLeft),
            2 * p
        }
        _appendRipple(t, e) {
            e.appendChild(t),
            setTimeout( () => {
                N.addClass(t, "active")
            }
            , 50)
        }
        _toggleUnbound(t) {
            !0 === this._options.rippleUnbound ? N.addClass(t, ya) : t.classList.remove(ya)
        }
        _addColor(t, e) {
            if (wa.find(t => t === this._options.rippleColor.toLowerCase()))
                N.addClass(e, `${ma}-${this._options.rippleColor.toLowerCase()}`);
            else {
                const e = this._colorToRGB(this._options.rippleColor).join(",")
                  , i = "rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%".split("{{color}}").join(`${e}`);
                t.style.backgroundImage = `radial-gradient(circle, ${i})`
            }
        }
        _removeOldColorClasses(t) {
            const e = new RegExp(`${ma}-[a-z]+`,"gi");
            (t.classList.value.match(e) || []).forEach(e => {
                t.classList.remove(e)
            }
            )
        }
        _colorToRGB(t) {
            return "transparent" === t.toLowerCase() ? xa : "#" === t[0] ? ((e = t).length < 7 && (e = `#${e[1]}${e[1]}${e[2]}${e[2]}${e[3]}${e[3]}`),
            [parseInt(e.substr(1, 2), 16), parseInt(e.substr(3, 2), 16), parseInt(e.substr(5, 2), 16)]) : (-1 === t.indexOf("rgb") && (t = function(t) {
                const e = document.body.appendChild(document.createElement("fictum"))
                  , i = "rgb(1, 2, 3)";
                return e.style.color = i,
                e.style.color !== i ? xa : (e.style.color = t,
                e.style.color === i || "" === e.style.color ? xa : (t = getComputedStyle(e).color,
                document.body.removeChild(e),
                t))
            }(t)),
            0 === t.indexOf("rgb") ? function(t) {
                return (t = t.match(/[.\d]+/g).map(t => +Number(t))).length = 3,
                t
            }(t) : xa);
            var e
        }
        static autoInitial(t) {
            return function(e) {
                t._autoInit(e)
            }
        }
        static jQueryInterface(t) {
            return this.each(function() {
                return s.getData(this, "mdb.ripple") ? null : new Sa(this,t)
            })
        }
    }
    const Ta = "thumb"
      , Aa = "thumb-active"
      , Ea = `.${Ta}`;
    class Ma extends ao {
        constructor(t) {
            super(t),
            this._initiated = !1,
            this._thumb = null,
            this._element && (this.init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor))
        }
        static get NAME() {
            return "range"
        }
        get rangeInput() {
            return B.findOne("input[type=range]", this._element)
        }
        init() {
            this._initiated || (this._addThumb(),
            this._thumbUpdate(),
            this._handleEvents(),
            this._initiated = !0)
        }
        dispose() {
            this._disposeEvents(),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _addThumb() {
            const t = _("span");
            N.addClass(t, Ta),
            t.innerHTML = '<span class="thumb-value"></span>',
            this._element.append(t),
            this._thumb = B.findOne(Ea, this._element)
        }
        _handleEvents() {
            I.on(this.rangeInput, "mousedown", () => this._showThumb()),
            I.on(this.rangeInput, "mouseup", () => this._hideThumb()),
            I.on(this.rangeInput, "touchstart", () => this._showThumb()),
            I.on(this.rangeInput, "touchend", () => this._hideThumb()),
            I.on(this.rangeInput, "input", () => this._thumbUpdate())
        }
        _disposeEvents() {
            I.off(this.rangeInput, "mousedown"),
            I.off(this.rangeInput, "mouseup"),
            I.off(this.rangeInput, "touchstart"),
            I.off(this.rangeInput, "touchend"),
            I.off(this.rangeInput, "input")
        }
        _showThumb() {
            N.addClass(this._thumb, Aa)
        }
        _hideThumb() {
            N.removeClass(this._thumb, Aa)
        }
        _thumbUpdate() {
            const t = this.rangeInput
              , e = t.value
              , i = t.min ? t.min : 0
              , n = t.max ? t.max : 100;
            B.findOne(".thumb-value", this._thumb).textContent = e;
            const s = Number(100 * (e - i) / (n - i));
            N.style(this._thumb, {
                left: `calc(${s}% + (${8 - .15 * s}px))`
            })
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                let i = s.getData(this, "mdb.range");
                const n = "object" == typeof t && t;
                if ((i || !/dispose/.test(t)) && (i || (i = new Ma(this,n)),
                "string" == typeof t)) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
    }
    const Oa = "animation"
      , Da = {
        animation: "string",
        animationStart: "string",
        animationShowOnLoad: "boolean",
        onStart: "(null|function)",
        onEnd: "(null|function)",
        onHide: "(null|function)",
        onShow: "(null|function)",
        animationOnScroll: "(string)",
        animationOffset: "(number|string)",
        animationDelay: "(number|string)",
        animationDuration: "(number|string)",
        animationReverse: "boolean",
        animationInterval: "(number|string)",
        animationRepeat: "(number|boolean)",
        animationReset: "boolean"
    }
      , $a = {
        animation: "fade",
        animationStart: "onClick",
        animationShowOnLoad: !0,
        onStart: null,
        onEnd: null,
        onHide: null,
        onShow: null,
        animationOnScroll: "once",
        animationOffset: 0,
        animationDelay: 0,
        animationDuration: 500,
        animationReverse: !1,
        animationInterval: 0,
        animationRepeat: !1,
        animationReset: !1
    };
    class Ia extends ao {
        constructor(t, e) {
            super(t),
            this._animateElement = this._getAnimateElement(),
            this._isFirstScroll = !0,
            this._repeatAnimateOnScroll = !0,
            this._options = this._getConfig(e),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return Oa
        }
        init() {
            this._init()
        }
        startAnimation() {
            this._startAnimation()
        }
        stopAnimation() {
            this._clearAnimationClass()
        }
        changeAnimationType(t) {
            this._options.animation = t
        }
        dispose() {
            I.off(this._element, "mousedown"),
            I.off(this._animateElement, "animationend"),
            I.off(window, "scroll"),
            I.off(this._element, "mouseover"),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _init() {
            switch (this._options.animationStart) {
            case "onHover":
                this._bindHoverEvents();
                break;
            case "onLoad":
                this._startAnimation();
                break;
            case "onScroll":
                this._bindScrollEvents();
                break;
            case "onClick":
                this._bindClickEvents()
            }
            this._bindTriggerOnEndCallback(),
            this._options.animationReset && this._bindResetAnimationAfterFinish()
        }
        _getAnimateElement() {
            const t = N.getDataAttribute(this._element, "animation-target");
            return t ? B.find(t)[0] : this._element
        }
        _getConfig(t) {
            const e = N.getDataAttributes(this._animateElement);
            return t = {
                ...$a,
                ...e,
                ...t
            },
            d(Oa, t, Da),
            t
        }
        _animateOnScroll() {
            const t = N.offset(this._animateElement).top
              , e = this._animateElement.offsetHeight
              , i = window.innerHeight
              , n = t + this._options.animationOffset <= i && t + this._options.animationOffset + e >= 0
              , s = "visible" === this._animateElement.style.visibility;
            switch (!0) {
            case n && this._isFirstScroll:
                this._isFirstScroll = !1,
                this._startAnimation();
                break;
            case !n && this._isFirstScroll:
                this._isFirstScroll = !1,
                this._hideAnimateElement();
                break;
            case n && !s && this._repeatAnimateOnScroll:
                "repeat" !== this._options.animationOnScroll && (this._repeatAnimateOnScroll = !1),
                this._callback(this._options.onShow),
                this._showAnimateElement(),
                this._startAnimation();
                break;
            case !n && s && this._repeatAnimateOnScroll:
                this._hideAnimateElement(),
                this._clearAnimationClass(),
                this._callback(this._options.onHide)
            }
        }
        _addAnimatedClass() {
            N.addClass(this._animateElement, "animation"),
            N.addClass(this._animateElement, this._options.animation)
        }
        _clearAnimationClass() {
            this._animateElement.classList.remove(this._options.animation, "animation")
        }
        _removeInvisibleClass() {
            N.removeClass(this._animateElement, "invisible")
        }
        _startAnimation() {
            this._callback(this._options.onStart),
            this._removeInvisibleClass(),
            this._addAnimatedClass(),
            this._options.animationRepeat && !this._options.animationInterval && this._setAnimationRepeat(),
            this._options.animationReverse && this._setAnimationReverse(),
            this._options.animationDelay && this._setAnimationDelay(),
            this._options.animationDuration && this._setAnimationDuration(),
            this._options.animationInterval && this._setAnimationInterval()
        }
        _setAnimationReverse() {
            N.style(this._animateElement, {
                animationIterationCount: !0 === this._options.animationRepeat ? "infinite" : "2",
                animationDirection: "alternate"
            })
        }
        _setAnimationDuration() {
            N.style(this._animateElement, {
                animationDuration: `${this._options.animationDuration}ms`
            })
        }
        _setAnimationDelay() {
            N.style(this._animateElement, {
                animationDelay: `${this._options.animationDelay}ms`
            })
        }
        _setAnimationRepeat() {
            N.style(this._animateElement, {
                animationIterationCount: !0 === this._options.animationRepeat ? "infinite" : this._options.animationRepeat
            })
        }
        _setAnimationInterval() {
            I.on(this._animateElement, "animationend", () => {
                this._clearAnimationClass(),
                setTimeout( () => {
                    this._addAnimatedClass()
                }
                , this._options.animationInterval)
            }
            )
        }
        _hideAnimateElement() {
            N.style(this._animateElement, {
                visibility: "hidden"
            })
        }
        _showAnimateElement() {
            N.style(this._animateElement, {
                visibility: "visible"
            })
        }
        _bindResetAnimationAfterFinish() {
            I.on(this._animateElement, "animationend", () => {
                this._clearAnimationClass()
            }
            )
        }
        _bindTriggerOnEndCallback() {
            I.on(this._animateElement, "animationend", () => {
                this._callback(this._options.onEnd)
            }
            )
        }
        _bindScrollEvents() {
            this._options.animationShowOnLoad || this._animateOnScroll(),
            I.on(window, "scroll", () => {
                this._animateOnScroll()
            }
            )
        }
        _bindClickEvents() {
            I.on(this._element, "mousedown", () => {
                this._startAnimation()
            }
            )
        }
        _bindHoverEvents() {
            I.one(this._element, "mouseover", () => {
                this._startAnimation()
            }
            ),
            I.one(this._animateElement, "animationend", () => {
                setTimeout( () => {
                    this._bindHoverEvents()
                }
                , 100)
            }
            )
        }
        _callback(t) {
            t instanceof Function && t()
        }
        static autoInit(t) {
            t._init()
        }
        static jQueryInterface(t) {
            new Ia(this[0],t).init()
        }
    }
    /*!
   * Chart.js v3.9.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   */
    function La() {}
    const Pa = function() {
        let t = 0;
        return function() {
            return t++
        }
    }();
    function Ra(t) {
        return null == t
    }
    function Na(t) {
        if (Array.isArray && Array.isArray(t))
            return !0;
        const e = Object.prototype.toString.call(t);
        return "[object" === e.slice(0, 7) && "Array]" === e.slice(-6)
    }
    function Ba(t) {
        return null !== t && "[object Object]" === Object.prototype.toString.call(t)
    }
    const Ha = t => ("number" == typeof t || t instanceof Number) && isFinite(+t);
    function Fa(t, e) {
        return Ha(t) ? t : e
    }
    function za(t, e) {
        return void 0 === t ? e : t
    }
    const ja = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 * e : +t;
    function Wa(t, e, i) {
        if (t && "function" == typeof t.call)
            return t.apply(i, e)
    }
    function Va(t, e, i, n) {
        let s, o, a;
        if (Na(t))
            if (o = t.length,
            n)
                for (s = o - 1; s >= 0; s--)
                    e.call(i, t[s], s);
            else
                for (s = 0; s < o; s++)
                    e.call(i, t[s], s);
        else if (Ba(t))
            for (a = Object.keys(t),
            o = a.length,
            s = 0; s < o; s++)
                e.call(i, t[a[s]], a[s])
    }
    function Ya(t, e) {
        let i, n, s, o;
        if (!t || !e || t.length !== e.length)
            return !1;
        for (i = 0,
        n = t.length; i < n; ++i)
            if (s = t[i],
            o = e[i],
            s.datasetIndex !== o.datasetIndex || s.index !== o.index)
                return !1;
        return !0
    }
    function Xa(t) {
        if (Na(t))
            return t.map(Xa);
        if (Ba(t)) {
            const e = Object.create(null)
              , i = Object.keys(t)
              , n = i.length;
            let s = 0;
            for (; s < n; ++s)
                e[i[s]] = Xa(t[i[s]]);
            return e
        }
        return t
    }
    function Ka(t) {
        return -1 === ["__proto__", "prototype", "constructor"].indexOf(t)
    }
    function Ua(t, e, i, n) {
        if (!Ka(t))
            return;
        const s = e[t]
          , o = i[t];
        Ba(s) && Ba(o) ? qa(s, o, n) : e[t] = Xa(o)
    }
    function qa(t, e, i) {
        const n = Na(e) ? e : [e]
          , s = n.length;
        if (!Ba(t))
            return t;
        const o = (i = i || {}).merger || Ua;
        for (let a = 0; a < s; ++a) {
            if (!Ba(e = n[a]))
                continue;
            const s = Object.keys(e);
            for (let n = 0, a = s.length; n < a; ++n)
                o(s[n], t, e, i)
        }
        return t
    }
    function Za(t, e) {
        return qa(t, e, {
            merger: Ga
        })
    }
    function Ga(t, e, i) {
        if (!Ka(t))
            return;
        const n = e[t]
          , s = i[t];
        Ba(n) && Ba(s) ? Za(n, s) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = Xa(s))
    }
    const Qa = {
        "": t => t,
        x: t => t.x,
        y: t => t.y
    };
    function Ja(t, e) {
        const i = Qa[e] || (Qa[e] = function(t) {
            const e = function(t) {
                const e = t.split(".")
                  , i = [];
                let n = "";
                for (const s of e)
                    n += s,
                    n.endsWith("\\") ? n = n.slice(0, -1) + "." : (i.push(n),
                    n = "");
                return i
            }(t);
            return t => {
                for (const i of e) {
                    if ("" === i)
                        break;
                    t = t && t[i]
                }
                return t
            }
        }(e));
        return i(t)
    }
    function tr(t) {
        return t.charAt(0).toUpperCase() + t.slice(1)
    }
    const er = t => void 0 !== t
      , ir = t => "function" == typeof t
      , nr = (t, e) => {
        if (t.size !== e.size)
            return !1;
        for (const i of t)
            if (!e.has(i))
                return !1;
        return !0
    }
    ;
    const sr = Math.PI
      , or = 2 * sr
      , ar = or + sr
      , rr = Number.POSITIVE_INFINITY
      , lr = sr / 180
      , hr = sr / 2
      , cr = sr / 4
      , dr = 2 * sr / 3
      , ur = Math.log10
      , pr = Math.sign;
    function fr(t) {
        const e = Math.round(t);
        t = mr(t, e, t / 1e3) ? e : t;
        const i = Math.pow(10, Math.floor(ur(t)))
          , n = t / i;
        return (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * i
    }
    function gr(t) {
        return !isNaN(parseFloat(t)) && isFinite(t)
    }
    function mr(t, e, i) {
        return Math.abs(t - e) < i
    }
    function _r(t, e, i) {
        let n, s, o;
        for (n = 0,
        s = t.length; n < s; n++)
            o = t[n][i],
            isNaN(o) || (e.min = Math.min(e.min, o),
            e.max = Math.max(e.max, o))
    }
    function br(t) {
        return t * (sr / 180)
    }
    function vr(t) {
        return t * (180 / sr)
    }
    function yr(t) {
        if (!Ha(t))
            return;
        let e = 1
          , i = 0;
        for (; Math.round(t * e) / e !== t; )
            e *= 10,
            i++;
        return i
    }
    function xr(t, e) {
        const i = e.x - t.x
          , n = e.y - t.y
          , s = Math.sqrt(i * i + n * n);
        let o = Math.atan2(n, i);
        return o < -.5 * sr && (o += or),
        {
            angle: o,
            distance: s
        }
    }
    function wr(t, e) {
        return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))
    }
    function Cr(t, e) {
        return (t - e + ar) % or - sr
    }
    function kr(t) {
        return (t % or + or) % or
    }
    function Sr(t, e, i, n) {
        const s = kr(t)
          , o = kr(e)
          , a = kr(i)
          , r = kr(o - s)
          , l = kr(a - s)
          , h = kr(s - o)
          , c = kr(s - a);
        return s === o || s === a || n && o === a || r > l && h < c
    }
    function Tr(t, e, i) {
        return Math.max(e, Math.min(i, t))
    }
    function Ar(t, e, i, n=1e-6) {
        return t >= Math.min(e, i) - n && t <= Math.max(e, i) + n
    }
    function Er(t, e, i) {
        i = i || (i => t[i] < e);
        let n, s = t.length - 1, o = 0;
        for (; s - o > 1; )
            n = o + s >> 1,
            i(n) ? o = n : s = n;
        return {
            lo: o,
            hi: s
        }
    }
    const Mr = (t, e, i, n) => Er(t, i, n ? n => t[n][e] <= i : n => t[n][e] < i)
      , Or = (t, e, i) => Er(t, i, n => t[n][e] >= i);
    const Dr = ["push", "pop", "shift", "splice", "unshift"];
    function $r(t, e) {
        const i = t._chartjs;
        if (!i)
            return;
        const n = i.listeners
          , s = n.indexOf(e);
        -1 !== s && n.splice(s, 1),
        n.length > 0 || (Dr.forEach(e => {
            delete t[e]
        }
        ),
        delete t._chartjs)
    }
    function Ir(t) {
        const e = new Set;
        let i, n;
        for (i = 0,
        n = t.length; i < n; ++i)
            e.add(t[i]);
        return e.size === n ? t : Array.from(e)
    }
    const Lr = "undefined" == typeof window ? function(t) {
        return t()
    }
    : window.requestAnimationFrame;
    function Pr(t, e, i) {
        const n = i || (t => Array.prototype.slice.call(t));
        let s = !1
          , o = [];
        return function(...i) {
            o = n(i),
            s || (s = !0,
            Lr.call(window, () => {
                s = !1,
                t.apply(e, o)
            }
            ))
        }
    }
    const Rr = t => "start" === t ? "left" : "end" === t ? "right" : "center"
      , Nr = (t, e, i) => "start" === t ? e : "end" === t ? i : (e + i) / 2;
    function Br(t, e, i) {
        const n = e.length;
        let s = 0
          , o = n;
        if (t._sorted) {
            const {iScale: a, _parsed: r} = t
              , l = a.axis
              , {min: h, max: c, minDefined: d, maxDefined: u} = a.getUserBounds();
            d && (s = Tr(Math.min(Mr(r, a.axis, h).lo, i ? n : Mr(e, l, a.getPixelForValue(h)).lo), 0, n - 1)),
            o = u ? Tr(Math.max(Mr(r, a.axis, c, !0).hi + 1, i ? 0 : Mr(e, l, a.getPixelForValue(c), !0).hi + 1), s, n) - s : n - s
        }
        return {
            start: s,
            count: o
        }
    }
    function Hr(t) {
        const {xScale: e, yScale: i, _scaleRanges: n} = t
          , s = {
            xmin: e.min,
            xmax: e.max,
            ymin: i.min,
            ymax: i.max
        };
        if (!n)
            return t._scaleRanges = s,
            !0;
        const o = n.xmin !== e.min || n.xmax !== e.max || n.ymin !== i.min || n.ymax !== i.max;
        return Object.assign(n, s),
        o
    }
    const Fr = t => 0 === t || 1 === t
      , zr = (t, e, i) => -Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * or / i)
      , jr = (t, e, i) => Math.pow(2, -10 * t) * Math.sin((t - e) * or / i) + 1
      , Wr = {
        linear: t => t,
        easeInQuad: t => t * t,
        easeOutQuad: t => -t * (t - 2),
        easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1),
        easeInCubic: t => t * t * t,
        easeOutCubic: t => (t -= 1) * t * t + 1,
        easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),
        easeInQuart: t => t * t * t * t,
        easeOutQuart: t => -((t -= 1) * t * t * t - 1),
        easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2),
        easeInQuint: t => t * t * t * t * t,
        easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
        easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),
        easeInSine: t => 1 - Math.cos(t * hr),
        easeOutSine: t => Math.sin(t * hr),
        easeInOutSine: t => -.5 * (Math.cos(sr * t) - 1),
        easeInExpo: t => 0 === t ? 0 : Math.pow(2, 10 * (t - 1)),
        easeOutExpo: t => 1 === t ? 1 : 1 - Math.pow(2, -10 * t),
        easeInOutExpo: t => Fr(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),
        easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
        easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
        easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
        easeInElastic: t => Fr(t) ? t : zr(t, .075, .3),
        easeOutElastic: t => Fr(t) ? t : jr(t, .075, .3),
        easeInOutElastic(t) {
            const e = .1125;
            return Fr(t) ? t : t < .5 ? .5 * zr(2 * t, e, .45) : .5 + .5 * jr(2 * t - 1, e, .45)
        },
        easeInBack(t) {
            const e = 1.70158;
            return t * t * ((e + 1) * t - e)
        },
        easeOutBack(t) {
            const e = 1.70158;
            return (t -= 1) * t * ((e + 1) * t + e) + 1
        },
        easeInOutBack(t) {
            let e = 1.70158;
            return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2)
        },
        easeInBounce: t => 1 - Wr.easeOutBounce(1 - t),
        easeOutBounce(t) {
            const e = 7.5625
              , i = 2.75;
            return t < 1 / i ? e * t * t : t < 2 / i ? e * (t -= 1.5 / i) * t + .75 : t < 2.5 / i ? e * (t -= 2.25 / i) * t + .9375 : e * (t -= 2.625 / i) * t + .984375
        },
        easeInOutBounce: t => t < .5 ? .5 * Wr.easeInBounce(2 * t) : .5 * Wr.easeOutBounce(2 * t - 1) + .5
    };
    /*!
   * @kurkle/color v0.2.1
   * https://github.com/kurkle/color#readme
   * (c) 2022 Jukka Kurkela
   * Released under the MIT License
   */
    function Vr(t) {
        return t + .5 | 0
    }
    const Yr = (t, e, i) => Math.max(Math.min(t, i), e);
    function Xr(t) {
        return Yr(Vr(2.55 * t), 0, 255)
    }
    function Kr(t) {
        return Yr(Vr(255 * t), 0, 255)
    }
    function Ur(t) {
        return Yr(Vr(t / 2.55) / 100, 0, 1)
    }
    function qr(t) {
        return Yr(Vr(100 * t), 0, 100)
    }
    const Zr = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15,
        a: 10,
        b: 11,
        c: 12,
        d: 13,
        e: 14,
        f: 15
    }
      , Gr = [..."0123456789ABCDEF"]
      , Qr = t => Gr[15 & t]
      , Jr = t => Gr[(240 & t) >> 4] + Gr[15 & t]
      , tl = t => (240 & t) >> 4 == (15 & t);
    function el(t) {
        var e = (t => tl(t.r) && tl(t.g) && tl(t.b) && tl(t.a))(t) ? Qr : Jr;
        return t ? "#" + e(t.r) + e(t.g) + e(t.b) + ( (t, e) => t < 255 ? e(t) : "")(t.a, e) : void 0
    }
    const il = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
    function nl(t, e, i) {
        const n = e * Math.min(i, 1 - i)
          , s = (e, s=(e + t / 30) % 12) => i - n * Math.max(Math.min(s - 3, 9 - s, 1), -1);
        return [s(0), s(8), s(4)]
    }
    function sl(t, e, i) {
        const n = (n, s=(n + t / 60) % 6) => i - i * e * Math.max(Math.min(s, 4 - s, 1), 0);
        return [n(5), n(3), n(1)]
    }
    function ol(t, e, i) {
        const n = nl(t, 1, .5);
        let s;
        for (e + i > 1 && (s = 1 / (e + i),
        e *= s,
        i *= s),
        s = 0; s < 3; s++)
            n[s] *= 1 - e - i,
            n[s] += e;
        return n
    }
    function al(t) {
        const e = t.r / 255
          , i = t.g / 255
          , n = t.b / 255
          , s = Math.max(e, i, n)
          , o = Math.min(e, i, n)
          , a = (s + o) / 2;
        let r, l, h;
        return s !== o && (h = s - o,
        l = a > .5 ? h / (2 - s - o) : h / (s + o),
        r = function(t, e, i, n, s) {
            return t === s ? (e - i) / n + (e < i ? 6 : 0) : e === s ? (i - t) / n + 2 : (t - e) / n + 4
        }(e, i, n, h, s),
        r = 60 * r + .5),
        [0 | r, l || 0, a]
    }
    function rl(t, e, i, n) {
        return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, n)).map(Kr)
    }
    function ll(t, e, i) {
        return rl(nl, t, e, i)
    }
    function hl(t) {
        return (t % 360 + 360) % 360
    }
    function cl(t) {
        const e = il.exec(t);
        let i, n = 255;
        if (!e)
            return;
        e[5] !== i && (n = e[6] ? Xr(+e[5]) : Kr(+e[5]));
        const s = hl(+e[2])
          , o = +e[3] / 100
          , a = +e[4] / 100;
        return i = "hwb" === e[1] ? function(t, e, i) {
            return rl(ol, t, e, i)
        }(s, o, a) : "hsv" === e[1] ? function(t, e, i) {
            return rl(sl, t, e, i)
        }(s, o, a) : ll(s, o, a),
        {
            r: i[0],
            g: i[1],
            b: i[2],
            a: n
        }
    }
    const dl = {
        x: "dark",
        Z: "light",
        Y: "re",
        X: "blu",
        W: "gr",
        V: "medium",
        U: "slate",
        A: "ee",
        T: "ol",
        S: "or",
        B: "ra",
        C: "lateg",
        D: "ights",
        R: "in",
        Q: "turquois",
        E: "hi",
        P: "ro",
        O: "al",
        N: "le",
        M: "de",
        L: "yello",
        F: "en",
        K: "ch",
        G: "arks",
        H: "ea",
        I: "ightg",
        J: "wh"
    }
      , ul = {
        OiceXe: "f0f8ff",
        antiquewEte: "faebd7",
        aqua: "ffff",
        aquamarRe: "7fffd4",
        azuY: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "0",
        blanKedOmond: "ffebcd",
        Xe: "ff",
        XeviTet: "8a2be2",
        bPwn: "a52a2a",
        burlywood: "deb887",
        caMtXe: "5f9ea0",
        KartYuse: "7fff00",
        KocTate: "d2691e",
        cSO: "ff7f50",
        cSnflowerXe: "6495ed",
        cSnsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "ffff",
        xXe: "8b",
        xcyan: "8b8b",
        xgTMnPd: "b8860b",
        xWay: "a9a9a9",
        xgYF: "6400",
        xgYy: "a9a9a9",
        xkhaki: "bdb76b",
        xmagFta: "8b008b",
        xTivegYF: "556b2f",
        xSange: "ff8c00",
        xScEd: "9932cc",
        xYd: "8b0000",
        xsOmon: "e9967a",
        xsHgYF: "8fbc8f",
        xUXe: "483d8b",
        xUWay: "2f4f4f",
        xUgYy: "2f4f4f",
        xQe: "ced1",
        xviTet: "9400d3",
        dAppRk: "ff1493",
        dApskyXe: "bfff",
        dimWay: "696969",
        dimgYy: "696969",
        dodgerXe: "1e90ff",
        fiYbrick: "b22222",
        flSOwEte: "fffaf0",
        foYstWAn: "228b22",
        fuKsia: "ff00ff",
        gaRsbSo: "dcdcdc",
        ghostwEte: "f8f8ff",
        gTd: "ffd700",
        gTMnPd: "daa520",
        Way: "808080",
        gYF: "8000",
        gYFLw: "adff2f",
        gYy: "808080",
        honeyMw: "f0fff0",
        hotpRk: "ff69b4",
        RdianYd: "cd5c5c",
        Rdigo: "4b0082",
        ivSy: "fffff0",
        khaki: "f0e68c",
        lavFMr: "e6e6fa",
        lavFMrXsh: "fff0f5",
        lawngYF: "7cfc00",
        NmoncEffon: "fffacd",
        ZXe: "add8e6",
        ZcSO: "f08080",
        Zcyan: "e0ffff",
        ZgTMnPdLw: "fafad2",
        ZWay: "d3d3d3",
        ZgYF: "90ee90",
        ZgYy: "d3d3d3",
        ZpRk: "ffb6c1",
        ZsOmon: "ffa07a",
        ZsHgYF: "20b2aa",
        ZskyXe: "87cefa",
        ZUWay: "778899",
        ZUgYy: "778899",
        ZstAlXe: "b0c4de",
        ZLw: "ffffe0",
        lime: "ff00",
        limegYF: "32cd32",
        lRF: "faf0e6",
        magFta: "ff00ff",
        maPon: "800000",
        VaquamarRe: "66cdaa",
        VXe: "cd",
        VScEd: "ba55d3",
        VpurpN: "9370db",
        VsHgYF: "3cb371",
        VUXe: "7b68ee",
        VsprRggYF: "fa9a",
        VQe: "48d1cc",
        VviTetYd: "c71585",
        midnightXe: "191970",
        mRtcYam: "f5fffa",
        mistyPse: "ffe4e1",
        moccasR: "ffe4b5",
        navajowEte: "ffdead",
        navy: "80",
        Tdlace: "fdf5e6",
        Tive: "808000",
        TivedBb: "6b8e23",
        Sange: "ffa500",
        SangeYd: "ff4500",
        ScEd: "da70d6",
        pOegTMnPd: "eee8aa",
        pOegYF: "98fb98",
        pOeQe: "afeeee",
        pOeviTetYd: "db7093",
        papayawEp: "ffefd5",
        pHKpuff: "ffdab9",
        peru: "cd853f",
        pRk: "ffc0cb",
        plum: "dda0dd",
        powMrXe: "b0e0e6",
        purpN: "800080",
        YbeccapurpN: "663399",
        Yd: "ff0000",
        Psybrown: "bc8f8f",
        PyOXe: "4169e1",
        saddNbPwn: "8b4513",
        sOmon: "fa8072",
        sandybPwn: "f4a460",
        sHgYF: "2e8b57",
        sHshell: "fff5ee",
        siFna: "a0522d",
        silver: "c0c0c0",
        skyXe: "87ceeb",
        UXe: "6a5acd",
        UWay: "708090",
        UgYy: "708090",
        snow: "fffafa",
        sprRggYF: "ff7f",
        stAlXe: "4682b4",
        tan: "d2b48c",
        teO: "8080",
        tEstN: "d8bfd8",
        tomato: "ff6347",
        Qe: "40e0d0",
        viTet: "ee82ee",
        JHt: "f5deb3",
        wEte: "ffffff",
        wEtesmoke: "f5f5f5",
        Lw: "ffff00",
        LwgYF: "9acd32"
    };
    let pl;
    function fl(t) {
        pl || (pl = function() {
            const t = {}
              , e = Object.keys(ul)
              , i = Object.keys(dl);
            let n, s, o, a, r;
            for (n = 0; n < e.length; n++) {
                for (a = r = e[n],
                s = 0; s < i.length; s++)
                    o = i[s],
                    r = r.replace(o, dl[o]);
                o = parseInt(ul[a], 16),
                t[r] = [o >> 16 & 255, o >> 8 & 255, 255 & o]
            }
            return t
        }(),
        pl.transparent = [0, 0, 0, 0]);
        const e = pl[t.toLowerCase()];
        return e && {
            r: e[0],
            g: e[1],
            b: e[2],
            a: 4 === e.length ? e[3] : 255
        }
    }
    const gl = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
    const ml = t => t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055
      , _l = t => t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);
    function bl(t, e, i) {
        if (t) {
            let n = al(t);
            n[e] = Math.max(0, Math.min(n[e] + n[e] * i, 0 === e ? 360 : 1)),
            n = ll(n),
            t.r = n[0],
            t.g = n[1],
            t.b = n[2]
        }
    }
    function vl(t, e) {
        return t ? Object.assign(e || {}, t) : t
    }
    function yl(t) {
        var e = {
            r: 0,
            g: 0,
            b: 0,
            a: 255
        };
        return Array.isArray(t) ? t.length >= 3 && (e = {
            r: t[0],
            g: t[1],
            b: t[2],
            a: 255
        },
        t.length > 3 && (e.a = Kr(t[3]))) : (e = vl(t, {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        })).a = Kr(e.a),
        e
    }
    function xl(t) {
        return "r" === t.charAt(0) ? function(t) {
            const e = gl.exec(t);
            let i, n, s, o = 255;
            if (e) {
                if (e[7] !== i) {
                    const t = +e[7];
                    o = e[8] ? Xr(t) : Yr(255 * t, 0, 255)
                }
                return i = +e[1],
                n = +e[3],
                s = +e[5],
                i = 255 & (e[2] ? Xr(i) : Yr(i, 0, 255)),
                n = 255 & (e[4] ? Xr(n) : Yr(n, 0, 255)),
                s = 255 & (e[6] ? Xr(s) : Yr(s, 0, 255)),
                {
                    r: i,
                    g: n,
                    b: s,
                    a: o
                }
            }
        }(t) : cl(t)
    }
    class wl {
        constructor(t) {
            if (t instanceof wl)
                return t;
            const e = typeof t;
            let i;
            var n, s, o;
            "object" === e ? i = yl(t) : "string" === e && (o = (n = t).length,
            "#" === n[0] && (4 === o || 5 === o ? s = {
                r: 255 & 17 * Zr[n[1]],
                g: 255 & 17 * Zr[n[2]],
                b: 255 & 17 * Zr[n[3]],
                a: 5 === o ? 17 * Zr[n[4]] : 255
            } : 7 !== o && 9 !== o || (s = {
                r: Zr[n[1]] << 4 | Zr[n[2]],
                g: Zr[n[3]] << 4 | Zr[n[4]],
                b: Zr[n[5]] << 4 | Zr[n[6]],
                a: 9 === o ? Zr[n[7]] << 4 | Zr[n[8]] : 255
            })),
            i = s || fl(t) || xl(t)),
            this._rgb = i,
            this._valid = !!i
        }
        get valid() {
            return this._valid
        }
        get rgb() {
            var t = vl(this._rgb);
            return t && (t.a = Ur(t.a)),
            t
        }
        set rgb(t) {
            this._rgb = yl(t)
        }
        rgbString() {
            return this._valid ? (t = this._rgb) && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${Ur(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) : void 0;
            var t
        }
        hexString() {
            return this._valid ? el(this._rgb) : void 0
        }
        hslString() {
            return this._valid ? function(t) {
                if (!t)
                    return;
                const e = al(t)
                  , i = e[0]
                  , n = qr(e[1])
                  , s = qr(e[2]);
                return t.a < 255 ? `hsla(${i}, ${n}%, ${s}%, ${Ur(t.a)})` : `hsl(${i}, ${n}%, ${s}%)`
            }(this._rgb) : void 0
        }
        mix(t, e) {
            if (t) {
                const i = this.rgb
                  , n = t.rgb;
                let s;
                const o = e === s ? .5 : e
                  , a = 2 * o - 1
                  , r = i.a - n.a
                  , l = ((a * r === -1 ? a : (a + r) / (1 + a * r)) + 1) / 2;
                s = 1 - l,
                i.r = 255 & l * i.r + s * n.r + .5,
                i.g = 255 & l * i.g + s * n.g + .5,
                i.b = 255 & l * i.b + s * n.b + .5,
                i.a = o * i.a + (1 - o) * n.a,
                this.rgb = i
            }
            return this
        }
        interpolate(t, e) {
            return t && (this._rgb = function(t, e, i) {
                const n = _l(Ur(t.r))
                  , s = _l(Ur(t.g))
                  , o = _l(Ur(t.b));
                return {
                    r: Kr(ml(n + i * (_l(Ur(e.r)) - n))),
                    g: Kr(ml(s + i * (_l(Ur(e.g)) - s))),
                    b: Kr(ml(o + i * (_l(Ur(e.b)) - o))),
                    a: t.a + i * (e.a - t.a)
                }
            }(this._rgb, t._rgb, e)),
            this
        }
        clone() {
            return new wl(this.rgb)
        }
        alpha(t) {
            return this._rgb.a = Kr(t),
            this
        }
        clearer(t) {
            return this._rgb.a *= 1 - t,
            this
        }
        greyscale() {
            const t = this._rgb
              , e = Vr(.3 * t.r + .59 * t.g + .11 * t.b);
            return t.r = t.g = t.b = e,
            this
        }
        opaquer(t) {
            return this._rgb.a *= 1 + t,
            this
        }
        negate() {
            const t = this._rgb;
            return t.r = 255 - t.r,
            t.g = 255 - t.g,
            t.b = 255 - t.b,
            this
        }
        lighten(t) {
            return bl(this._rgb, 2, t),
            this
        }
        darken(t) {
            return bl(this._rgb, 2, -t),
            this
        }
        saturate(t) {
            return bl(this._rgb, 1, t),
            this
        }
        desaturate(t) {
            return bl(this._rgb, 1, -t),
            this
        }
        rotate(t) {
            return function(t, e) {
                var i = al(t);
                i[0] = hl(i[0] + e),
                i = ll(i),
                t.r = i[0],
                t.g = i[1],
                t.b = i[2]
            }(this._rgb, t),
            this
        }
    }
    function Cl(t) {
        return new wl(t)
    }
    function kl(t) {
        if (t && "object" == typeof t) {
            const e = t.toString();
            return "[object CanvasPattern]" === e || "[object CanvasGradient]" === e
        }
        return !1
    }
    function Sl(t) {
        return kl(t) ? t : Cl(t)
    }
    function Tl(t) {
        return kl(t) ? t : Cl(t).saturate(.5).darken(.1).hexString()
    }
    const Al = Object.create(null)
      , El = Object.create(null);
    function Ml(t, e) {
        if (!e)
            return t;
        const i = e.split(".");
        for (let n = 0, s = i.length; n < s; ++n) {
            const e = i[n];
            t = t[e] || (t[e] = Object.create(null))
        }
        return t
    }
    function Ol(t, e, i) {
        return "string" == typeof e ? qa(Ml(t, e), i) : qa(Ml(t, ""), e)
    }
    var Dl = new class {
        constructor(t) {
            this.animation = void 0,
            this.backgroundColor = "rgba(0,0,0,0.1)",
            this.borderColor = "rgba(0,0,0,0.1)",
            this.color = "#666",
            this.datasets = {},
            this.devicePixelRatio = t => t.chart.platform.getDevicePixelRatio(),
            this.elements = {},
            this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
            this.font = {
                family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                size: 12,
                style: "normal",
                lineHeight: 1.2,
                weight: null
            },
            this.hover = {},
            this.hoverBackgroundColor = (t, e) => Tl(e.backgroundColor),
            this.hoverBorderColor = (t, e) => Tl(e.borderColor),
            this.hoverColor = (t, e) => Tl(e.color),
            this.indexAxis = "x",
            this.interaction = {
                mode: "nearest",
                intersect: !0,
                includeInvisible: !1
            },
            this.maintainAspectRatio = !0,
            this.onHover = null,
            this.onClick = null,
            this.parsing = !0,
            this.plugins = {},
            this.responsive = !0,
            this.scale = void 0,
            this.scales = {},
            this.showLine = !0,
            this.drawActiveElementsOnTop = !0,
            this.describe(t)
        }
        set(t, e) {
            return Ol(this, t, e)
        }
        get(t) {
            return Ml(this, t)
        }
        describe(t, e) {
            return Ol(El, t, e)
        }
        override(t, e) {
            return Ol(Al, t, e)
        }
        route(t, e, i, n) {
            const s = Ml(this, t)
              , o = Ml(this, i)
              , a = "_" + e;
            Object.defineProperties(s, {
                [a]: {
                    value: s[e],
                    writable: !0
                },
                [e]: {
                    enumerable: !0,
                    get() {
                        const t = this[a]
                          , e = o[n];
                        return Ba(t) ? Object.assign({}, e, t) : za(t, e)
                    },
                    set(t) {
                        this[a] = t
                    }
                }
            })
        }
    }
    ({
        _scriptable: t => !t.startsWith("on"),
        _indexable: t => "events" !== t,
        hover: {
            _fallback: "interaction"
        },
        interaction: {
            _scriptable: !1,
            _indexable: !1
        }
    });
    function $l(t, e, i, n, s) {
        let o = e[s];
        return o || (o = e[s] = t.measureText(s).width,
        i.push(s)),
        o > n && (n = o),
        n
    }
    function Il(t, e, i, n) {
        let s = (n = n || {}).data = n.data || {}
          , o = n.garbageCollect = n.garbageCollect || [];
        n.font !== e && (s = n.data = {},
        o = n.garbageCollect = [],
        n.font = e),
        t.save(),
        t.font = e;
        let a = 0;
        const r = i.length;
        let l, h, c, d, u;
        for (l = 0; l < r; l++)
            if (d = i[l],
            null != d && !0 !== Na(d))
                a = $l(t, s, o, a, d);
            else if (Na(d))
                for (h = 0,
                c = d.length; h < c; h++)
                    u = d[h],
                    null == u || Na(u) || (a = $l(t, s, o, a, u));
        t.restore();
        const p = o.length / 2;
        if (p > i.length) {
            for (l = 0; l < p; l++)
                delete s[o[l]];
            o.splice(0, p)
        }
        return a
    }
    function Ll(t, e, i) {
        const n = t.currentDevicePixelRatio
          , s = 0 !== i ? Math.max(i / 2, .5) : 0;
        return Math.round((e - s) * n) / n + s
    }
    function Pl(t, e) {
        (e = e || t.getContext("2d")).save(),
        e.resetTransform(),
        e.clearRect(0, 0, t.width, t.height),
        e.restore()
    }
    function Rl(t, e, i, n) {
        Nl(t, e, i, n, null)
    }
    function Nl(t, e, i, n, s) {
        let o, a, r, l, h, c;
        const d = e.pointStyle
          , u = e.rotation
          , p = e.radius;
        let f = (u || 0) * lr;
        if (d && "object" == typeof d && (o = d.toString(),
        "[object HTMLImageElement]" === o || "[object HTMLCanvasElement]" === o))
            return t.save(),
            t.translate(i, n),
            t.rotate(f),
            t.drawImage(d, -d.width / 2, -d.height / 2, d.width, d.height),
            void t.restore();
        if (!(isNaN(p) || p <= 0)) {
            switch (t.beginPath(),
            d) {
            default:
                s ? t.ellipse(i, n, s / 2, p, 0, 0, or) : t.arc(i, n, p, 0, or),
                t.closePath();
                break;
            case "triangle":
                t.moveTo(i + Math.sin(f) * p, n - Math.cos(f) * p),
                f += dr,
                t.lineTo(i + Math.sin(f) * p, n - Math.cos(f) * p),
                f += dr,
                t.lineTo(i + Math.sin(f) * p, n - Math.cos(f) * p),
                t.closePath();
                break;
            case "rectRounded":
                h = .516 * p,
                l = p - h,
                a = Math.cos(f + cr) * l,
                r = Math.sin(f + cr) * l,
                t.arc(i - a, n - r, h, f - sr, f - hr),
                t.arc(i + r, n - a, h, f - hr, f),
                t.arc(i + a, n + r, h, f, f + hr),
                t.arc(i - r, n + a, h, f + hr, f + sr),
                t.closePath();
                break;
            case "rect":
                if (!u) {
                    l = Math.SQRT1_2 * p,
                    c = s ? s / 2 : l,
                    t.rect(i - c, n - l, 2 * c, 2 * l);
                    break
                }
                f += cr;
            case "rectRot":
                a = Math.cos(f) * p,
                r = Math.sin(f) * p,
                t.moveTo(i - a, n - r),
                t.lineTo(i + r, n - a),
                t.lineTo(i + a, n + r),
                t.lineTo(i - r, n + a),
                t.closePath();
                break;
            case "crossRot":
                f += cr;
            case "cross":
                a = Math.cos(f) * p,
                r = Math.sin(f) * p,
                t.moveTo(i - a, n - r),
                t.lineTo(i + a, n + r),
                t.moveTo(i + r, n - a),
                t.lineTo(i - r, n + a);
                break;
            case "star":
                a = Math.cos(f) * p,
                r = Math.sin(f) * p,
                t.moveTo(i - a, n - r),
                t.lineTo(i + a, n + r),
                t.moveTo(i + r, n - a),
                t.lineTo(i - r, n + a),
                f += cr,
                a = Math.cos(f) * p,
                r = Math.sin(f) * p,
                t.moveTo(i - a, n - r),
                t.lineTo(i + a, n + r),
                t.moveTo(i + r, n - a),
                t.lineTo(i - r, n + a);
                break;
            case "line":
                a = s ? s / 2 : Math.cos(f) * p,
                r = Math.sin(f) * p,
                t.moveTo(i - a, n - r),
                t.lineTo(i + a, n + r);
                break;
            case "dash":
                t.moveTo(i, n),
                t.lineTo(i + Math.cos(f) * p, n + Math.sin(f) * p)
            }
            t.fill(),
            e.borderWidth > 0 && t.stroke()
        }
    }
    function Bl(t, e, i) {
        return i = i || .5,
        !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i
    }
    function Hl(t, e) {
        t.save(),
        t.beginPath(),
        t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top),
        t.clip()
    }
    function Fl(t) {
        t.restore()
    }
    function zl(t, e, i, n, s) {
        if (!e)
            return t.lineTo(i.x, i.y);
        if ("middle" === s) {
            const n = (e.x + i.x) / 2;
            t.lineTo(n, e.y),
            t.lineTo(n, i.y)
        } else
            "after" === s != !!n ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);
        t.lineTo(i.x, i.y)
    }
    function jl(t, e, i, n) {
        if (!e)
            return t.lineTo(i.x, i.y);
        t.bezierCurveTo(n ? e.cp1x : e.cp2x, n ? e.cp1y : e.cp2y, n ? i.cp2x : i.cp1x, n ? i.cp2y : i.cp1y, i.x, i.y)
    }
    function Wl(t, e, i, n, s, o={}) {
        const a = Na(e) ? e : [e]
          , r = o.strokeWidth > 0 && "" !== o.strokeColor;
        let l, h;
        for (t.save(),
        t.font = s.string,
        function(t, e) {
            e.translation && t.translate(e.translation[0], e.translation[1]);
            Ra(e.rotation) || t.rotate(e.rotation);
            e.color && (t.fillStyle = e.color);
            e.textAlign && (t.textAlign = e.textAlign);
            e.textBaseline && (t.textBaseline = e.textBaseline)
        }(t, o),
        l = 0; l < a.length; ++l)
            h = a[l],
            r && (o.strokeColor && (t.strokeStyle = o.strokeColor),
            Ra(o.strokeWidth) || (t.lineWidth = o.strokeWidth),
            t.strokeText(h, i, n, o.maxWidth)),
            t.fillText(h, i, n, o.maxWidth),
            Vl(t, i, n, h, o),
            n += s.lineHeight;
        t.restore()
    }
    function Vl(t, e, i, n, s) {
        if (s.strikethrough || s.underline) {
            const o = t.measureText(n)
              , a = e - o.actualBoundingBoxLeft
              , r = e + o.actualBoundingBoxRight
              , l = i - o.actualBoundingBoxAscent
              , h = i + o.actualBoundingBoxDescent
              , c = s.strikethrough ? (l + h) / 2 : h;
            t.strokeStyle = t.fillStyle,
            t.beginPath(),
            t.lineWidth = s.decorationWidth || 2,
            t.moveTo(a, c),
            t.lineTo(r, c),
            t.stroke()
        }
    }
    function Yl(t, e) {
        const {x: i, y: n, w: s, h: o, radius: a} = e;
        t.arc(i + a.topLeft, n + a.topLeft, a.topLeft, -hr, sr, !0),
        t.lineTo(i, n + o - a.bottomLeft),
        t.arc(i + a.bottomLeft, n + o - a.bottomLeft, a.bottomLeft, sr, hr, !0),
        t.lineTo(i + s - a.bottomRight, n + o),
        t.arc(i + s - a.bottomRight, n + o - a.bottomRight, a.bottomRight, hr, 0, !0),
        t.lineTo(i + s, n + a.topRight),
        t.arc(i + s - a.topRight, n + a.topRight, a.topRight, 0, -hr, !0),
        t.lineTo(i + a.topLeft, n)
    }
    const Xl = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/)
      , Kl = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
    function Ul(t, e) {
        const i = ("" + t).match(Xl);
        if (!i || "normal" === i[1])
            return 1.2 * e;
        switch (t = +i[2],
        i[3]) {
        case "px":
            return t;
        case "%":
            t /= 100
        }
        return e * t
    }
    const ql = t => +t || 0;
    function Zl(t, e) {
        const i = {}
          , n = Ba(e)
          , s = n ? Object.keys(e) : e
          , o = Ba(t) ? n ? i => za(t[i], t[e[i]]) : e => t[e] : () => t;
        for (const a of s)
            i[a] = ql(o(a));
        return i
    }
    function Gl(t) {
        return Zl(t, {
            top: "y",
            right: "x",
            bottom: "y",
            left: "x"
        })
    }
    function Ql(t) {
        return Zl(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"])
    }
    function Jl(t) {
        const e = Gl(t);
        return e.width = e.left + e.right,
        e.height = e.top + e.bottom,
        e
    }
    function th(t, e) {
        t = t || {},
        e = e || Dl.font;
        let i = za(t.size, e.size);
        "string" == typeof i && (i = parseInt(i, 10));
        let n = za(t.style, e.style);
        n && !("" + n).match(Kl) && (console.warn('Invalid font style specified: "' + n + '"'),
        n = "");
        const s = {
            family: za(t.family, e.family),
            lineHeight: Ul(za(t.lineHeight, e.lineHeight), i),
            size: i,
            style: n,
            weight: za(t.weight, e.weight),
            string: ""
        };
        return s.string = function(t) {
            return !t || Ra(t.size) || Ra(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family
        }(s),
        s
    }
    function eh(t, e, i, n) {
        let s, o, a, r = !0;
        for (s = 0,
        o = t.length; s < o; ++s)
            if (a = t[s],
            void 0 !== a && (void 0 !== e && "function" == typeof a && (a = a(e),
            r = !1),
            void 0 !== i && Na(a) && (a = a[i % a.length],
            r = !1),
            void 0 !== a))
                return n && !r && (n.cacheable = !1),
                a
    }
    function ih(t, e) {
        return Object.assign(Object.create(t), e)
    }
    function nh(t, e=[""], i=t, n, s= () => t[0]) {
        er(n) || (n = fh("_fallback", t));
        const o = {
            [Symbol.toStringTag]: "Object",
            _cacheable: !0,
            _scopes: t,
            _rootScopes: i,
            _fallback: n,
            _getTarget: s,
            override: s => nh([s, ...t], e, i, n)
        };
        return new Proxy(o,{
            deleteProperty: (e, i) => (delete e[i],
            delete e._keys,
            delete t[0][i],
            !0),
            get: (i, n) => lh(i, n, () => function(t, e, i, n) {
                let s;
                for (const o of e)
                    if (s = fh(ah(o, t), i),
                    er(s))
                        return rh(t, s) ? uh(i, n, t, s) : s
            }(n, e, t, i)),
            getOwnPropertyDescriptor: (t, e) => Reflect.getOwnPropertyDescriptor(t._scopes[0], e),
            getPrototypeOf: () => Reflect.getPrototypeOf(t[0]),
            has: (t, e) => gh(t).includes(e),
            ownKeys: t => gh(t),
            set(t, e, i) {
                const n = t._storage || (t._storage = s());
                return t[e] = n[e] = i,
                delete t._keys,
                !0
            }
        })
    }
    function sh(t, e, i, n) {
        const s = {
            _cacheable: !1,
            _proxy: t,
            _context: e,
            _subProxy: i,
            _stack: new Set,
            _descriptors: oh(t, n),
            setContext: e => sh(t, e, i, n),
            override: s => sh(t.override(s), e, i, n)
        };
        return new Proxy(s,{
            deleteProperty: (e, i) => (delete e[i],
            delete t[i],
            !0),
            get: (t, e, i) => lh(t, e, () => function(t, e, i) {
                const {_proxy: n, _context: s, _subProxy: o, _descriptors: a} = t;
                let r = n[e];
                ir(r) && a.isScriptable(e) && (r = function(t, e, i, n) {
                    const {_proxy: s, _context: o, _subProxy: a, _stack: r} = i;
                    if (r.has(t))
                        throw new Error("Recursion detected: " + Array.from(r).join("->") + "->" + t);
                    r.add(t),
                    e = e(o, a || n),
                    r.delete(t),
                    rh(t, e) && (e = uh(s._scopes, s, t, e));
                    return e
                }(e, r, t, i));
                Na(r) && r.length && (r = function(t, e, i, n) {
                    const {_proxy: s, _context: o, _subProxy: a, _descriptors: r} = i;
                    if (er(o.index) && n(t))
                        e = e[o.index % e.length];
                    else if (Ba(e[0])) {
                        const i = e
                          , n = s._scopes.filter(t => t !== i);
                        e = [];
                        for (const l of i) {
                            const i = uh(n, s, t, l);
                            e.push(sh(i, o, a && a[t], r))
                        }
                    }
                    return e
                }(e, r, t, a.isIndexable));
                rh(e, r) && (r = sh(r, s, o && o[e], a));
                return r
            }(t, e, i)),
            getOwnPropertyDescriptor: (e, i) => e._descriptors.allKeys ? Reflect.has(t, i) ? {
                enumerable: !0,
                configurable: !0
            } : void 0 : Reflect.getOwnPropertyDescriptor(t, i),
            getPrototypeOf: () => Reflect.getPrototypeOf(t),
            has: (e, i) => Reflect.has(t, i),
            ownKeys: () => Reflect.ownKeys(t),
            set: (e, i, n) => (t[i] = n,
            delete e[i],
            !0)
        })
    }
    function oh(t, e={
        scriptable: !0,
        indexable: !0
    }) {
        const {_scriptable: i=e.scriptable, _indexable: n=e.indexable, _allKeys: s=e.allKeys} = t;
        return {
            allKeys: s,
            scriptable: i,
            indexable: n,
            isScriptable: ir(i) ? i : () => i,
            isIndexable: ir(n) ? n : () => n
        }
    }
    const ah = (t, e) => t ? t + tr(e) : e
      , rh = (t, e) => Ba(e) && "adapters" !== t && (null === Object.getPrototypeOf(e) || e.constructor === Object);
    function lh(t, e, i) {
        if (Object.prototype.hasOwnProperty.call(t, e))
            return t[e];
        const n = i();
        return t[e] = n,
        n
    }
    function hh(t, e, i) {
        return ir(t) ? t(e, i) : t
    }
    const ch = (t, e) => !0 === t ? e : "string" == typeof t ? Ja(e, t) : void 0;
    function dh(t, e, i, n, s) {
        for (const o of e) {
            const e = ch(i, o);
            if (e) {
                t.add(e);
                const o = hh(e._fallback, i, s);
                if (er(o) && o !== i && o !== n)
                    return o
            } else if (!1 === e && er(n) && i !== n)
                return null
        }
        return !1
    }
    function uh(t, e, i, n) {
        const s = e._rootScopes
          , o = hh(e._fallback, i, n)
          , a = [...t, ...s]
          , r = new Set;
        r.add(n);
        let l = ph(r, a, i, o || i, n);
        return null !== l && ((!er(o) || o === i || (l = ph(r, a, o, l, n),
        null !== l)) && nh(Array.from(r), [""], s, o, () => function(t, e, i) {
            const n = t._getTarget();
            e in n || (n[e] = {});
            const s = n[e];
            if (Na(s) && Ba(i))
                return i;
            return s
        }(e, i, n)))
    }
    function ph(t, e, i, n, s) {
        for (; i; )
            i = dh(t, e, i, n, s);
        return i
    }
    function fh(t, e) {
        for (const i of e) {
            if (!i)
                continue;
            const e = i[t];
            if (er(e))
                return e
        }
    }
    function gh(t) {
        let e = t._keys;
        return e || (e = t._keys = function(t) {
            const e = new Set;
            for (const i of t)
                for (const t of Object.keys(i).filter(t => !t.startsWith("_")))
                    e.add(t);
            return Array.from(e)
        }(t._scopes)),
        e
    }
    function mh(t, e, i, n) {
        const {iScale: s} = t
          , {key: o="r"} = this._parsing
          , a = new Array(n);
        let r, l, h, c;
        for (r = 0,
        l = n; r < l; ++r)
            h = r + i,
            c = e[h],
            a[r] = {
                r: s.parse(Ja(c, o), h)
            };
        return a
    }
    const _h = Number.EPSILON || 1e-14
      , bh = (t, e) => e < t.length && !t[e].skip && t[e]
      , vh = t => "x" === t ? "y" : "x";
    function yh(t, e, i, n) {
        const s = t.skip ? e : t
          , o = e
          , a = i.skip ? e : i
          , r = wr(o, s)
          , l = wr(a, o);
        let h = r / (r + l)
          , c = l / (r + l);
        h = isNaN(h) ? 0 : h,
        c = isNaN(c) ? 0 : c;
        const d = n * h
          , u = n * c;
        return {
            previous: {
                x: o.x - d * (a.x - s.x),
                y: o.y - d * (a.y - s.y)
            },
            next: {
                x: o.x + u * (a.x - s.x),
                y: o.y + u * (a.y - s.y)
            }
        }
    }
    function xh(t, e="x") {
        const i = vh(e)
          , n = t.length
          , s = Array(n).fill(0)
          , o = Array(n);
        let a, r, l, h = bh(t, 0);
        for (a = 0; a < n; ++a)
            if (r = l,
            l = h,
            h = bh(t, a + 1),
            l) {
                if (h) {
                    const t = h[e] - l[e];
                    s[a] = 0 !== t ? (h[i] - l[i]) / t : 0
                }
                o[a] = r ? h ? pr(s[a - 1]) !== pr(s[a]) ? 0 : (s[a - 1] + s[a]) / 2 : s[a - 1] : s[a]
            }
        !function(t, e, i) {
            const n = t.length;
            let s, o, a, r, l, h = bh(t, 0);
            for (let c = 0; c < n - 1; ++c)
                l = h,
                h = bh(t, c + 1),
                l && h && (mr(e[c], 0, _h) ? i[c] = i[c + 1] = 0 : (s = i[c] / e[c],
                o = i[c + 1] / e[c],
                r = Math.pow(s, 2) + Math.pow(o, 2),
                r <= 9 || (a = 3 / Math.sqrt(r),
                i[c] = s * a * e[c],
                i[c + 1] = o * a * e[c])))
        }(t, s, o),
        function(t, e, i="x") {
            const n = vh(i)
              , s = t.length;
            let o, a, r, l = bh(t, 0);
            for (let h = 0; h < s; ++h) {
                if (a = r,
                r = l,
                l = bh(t, h + 1),
                !r)
                    continue;
                const s = r[i]
                  , c = r[n];
                a && (o = (s - a[i]) / 3,
                r[`cp1${i}`] = s - o,
                r[`cp1${n}`] = c - o * e[h]),
                l && (o = (l[i] - s) / 3,
                r[`cp2${i}`] = s + o,
                r[`cp2${n}`] = c + o * e[h])
            }
        }(t, o, e)
    }
    function wh(t, e, i) {
        return Math.max(Math.min(t, i), e)
    }
    function Ch(t, e, i, n, s) {
        let o, a, r, l;
        if (e.spanGaps && (t = t.filter(t => !t.skip)),
        "monotone" === e.cubicInterpolationMode)
            xh(t, s);
        else {
            let i = n ? t[t.length - 1] : t[0];
            for (o = 0,
            a = t.length; o < a; ++o)
                r = t[o],
                l = yh(i, r, t[Math.min(o + 1, a - (n ? 0 : 1)) % a], e.tension),
                r.cp1x = l.previous.x,
                r.cp1y = l.previous.y,
                r.cp2x = l.next.x,
                r.cp2y = l.next.y,
                i = r
        }
        e.capBezierPoints && function(t, e) {
            let i, n, s, o, a, r = Bl(t[0], e);
            for (i = 0,
            n = t.length; i < n; ++i)
                a = o,
                o = r,
                r = i < n - 1 && Bl(t[i + 1], e),
                o && (s = t[i],
                a && (s.cp1x = wh(s.cp1x, e.left, e.right),
                s.cp1y = wh(s.cp1y, e.top, e.bottom)),
                r && (s.cp2x = wh(s.cp2x, e.left, e.right),
                s.cp2y = wh(s.cp2y, e.top, e.bottom)))
        }(t, i)
    }
    function kh() {
        return "undefined" != typeof window && "undefined" != typeof document
    }
    function Sh(t) {
        let e = t.parentNode;
        return e && "[object ShadowRoot]" === e.toString() && (e = e.host),
        e
    }
    function Th(t, e, i) {
        let n;
        return "string" == typeof t ? (n = parseInt(t, 10),
        -1 !== t.indexOf("%") && (n = n / 100 * e.parentNode[i])) : n = t,
        n
    }
    const Ah = t => window.getComputedStyle(t, null);
    const Eh = ["top", "right", "bottom", "left"];
    function Mh(t, e, i) {
        const n = {};
        i = i ? "-" + i : "";
        for (let s = 0; s < 4; s++) {
            const o = Eh[s];
            n[o] = parseFloat(t[e + "-" + o + i]) || 0
        }
        return n.width = n.left + n.right,
        n.height = n.top + n.bottom,
        n
    }
    function Oh(t, e) {
        if ("native"in t)
            return t;
        const {canvas: i, currentDevicePixelRatio: n} = e
          , s = Ah(i)
          , o = "border-box" === s.boxSizing
          , a = Mh(s, "padding")
          , r = Mh(s, "border", "width")
          , {x: l, y: h, box: c} = function(t, e) {
            const i = t.touches
              , n = i && i.length ? i[0] : t
              , {offsetX: s, offsetY: o} = n;
            let a, r, l = !1;
            if (( (t, e, i) => (t > 0 || e > 0) && (!i || !i.shadowRoot))(s, o, t.target))
                a = s,
                r = o;
            else {
                const t = e.getBoundingClientRect();
                a = n.clientX - t.left,
                r = n.clientY - t.top,
                l = !0
            }
            return {
                x: a,
                y: r,
                box: l
            }
        }(t, i)
          , d = a.left + (c && r.left)
          , u = a.top + (c && r.top);
        let {width: p, height: f} = e;
        return o && (p -= a.width + r.width,
        f -= a.height + r.height),
        {
            x: Math.round((l - d) / p * i.width / n),
            y: Math.round((h - u) / f * i.height / n)
        }
    }
    const Dh = t => Math.round(10 * t) / 10;
    function $h(t, e, i, n) {
        const s = Ah(t)
          , o = Mh(s, "margin")
          , a = Th(s.maxWidth, t, "clientWidth") || rr
          , r = Th(s.maxHeight, t, "clientHeight") || rr
          , l = function(t, e, i) {
            let n, s;
            if (void 0 === e || void 0 === i) {
                const o = Sh(t);
                if (o) {
                    const t = o.getBoundingClientRect()
                      , a = Ah(o)
                      , r = Mh(a, "border", "width")
                      , l = Mh(a, "padding");
                    e = t.width - l.width - r.width,
                    i = t.height - l.height - r.height,
                    n = Th(a.maxWidth, o, "clientWidth"),
                    s = Th(a.maxHeight, o, "clientHeight")
                } else
                    e = t.clientWidth,
                    i = t.clientHeight
            }
            return {
                width: e,
                height: i,
                maxWidth: n || rr,
                maxHeight: s || rr
            }
        }(t, e, i);
        let {width: h, height: c} = l;
        if ("content-box" === s.boxSizing) {
            const t = Mh(s, "border", "width")
              , e = Mh(s, "padding");
            h -= e.width + t.width,
            c -= e.height + t.height
        }
        return h = Math.max(0, h - o.width),
        c = Math.max(0, n ? Math.floor(h / n) : c - o.height),
        h = Dh(Math.min(h, a, l.maxWidth)),
        c = Dh(Math.min(c, r, l.maxHeight)),
        h && !c && (c = Dh(h / 2)),
        {
            width: h,
            height: c
        }
    }
    function Ih(t, e, i) {
        const n = e || 1
          , s = Math.floor(t.height * n)
          , o = Math.floor(t.width * n);
        t.height = s / n,
        t.width = o / n;
        const a = t.canvas;
        return a.style && (i || !a.style.height && !a.style.width) && (a.style.height = `${t.height}px`,
        a.style.width = `${t.width}px`),
        (t.currentDevicePixelRatio !== n || a.height !== s || a.width !== o) && (t.currentDevicePixelRatio = n,
        a.height = s,
        a.width = o,
        t.ctx.setTransform(n, 0, 0, n, 0, 0),
        !0)
    }
    const Lh = function() {
        let e = !1;
        try {
            const t = {
                get passive() {
                    return e = !0,
                    !1
                }
            };
            window.addEventListener("test", null, t),
            window.removeEventListener("test", null, t)
        } catch (t) {}
        return e
    }();
    function Ph(t, e) {
        const i = function(t, e) {
            return Ah(t).getPropertyValue(e)
        }(t, e)
          , n = i && i.match(/^(\d+)(\.\d+)?px$/);
        return n ? +n[1] : void 0
    }
    function Rh(t, e, i, n) {
        return {
            x: t.x + i * (e.x - t.x),
            y: t.y + i * (e.y - t.y)
        }
    }
    function Nh(t, e, i, n) {
        return {
            x: t.x + i * (e.x - t.x),
            y: "middle" === n ? i < .5 ? t.y : e.y : "after" === n ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y
        }
    }
    function Bh(t, e, i, n) {
        const s = {
            x: t.cp2x,
            y: t.cp2y
        }
          , o = {
            x: e.cp1x,
            y: e.cp1y
        }
          , a = Rh(t, s, i)
          , r = Rh(s, o, i)
          , l = Rh(o, e, i)
          , h = Rh(a, r, i)
          , c = Rh(r, l, i);
        return Rh(h, c, i)
    }
    const Hh = new Map;
    function Fh(t, e, i) {
        return function(t, e) {
            e = e || {};
            const i = t + JSON.stringify(e);
            let n = Hh.get(i);
            return n || (n = new Intl.NumberFormat(t,e),
            Hh.set(i, n)),
            n
        }(e, i).format(t)
    }
    function zh(t, e, i) {
        return t ? function(t, e) {
            return {
                x: i => t + t + e - i,
                setWidth(t) {
                    e = t
                },
                textAlign: t => "center" === t ? t : "right" === t ? "left" : "right",
                xPlus: (t, e) => t - e,
                leftForLtr: (t, e) => t - e
            }
        }(e, i) : {
            x: t => t,
            setWidth(t) {},
            textAlign: t => t,
            xPlus: (t, e) => t + e,
            leftForLtr: (t, e) => t
        }
    }
    function jh(t, e) {
        let i, n;
        "ltr" !== e && "rtl" !== e || (i = t.canvas.style,
        n = [i.getPropertyValue("direction"), i.getPropertyPriority("direction")],
        i.setProperty("direction", e, "important"),
        t.prevTextDirection = n)
    }
    function Wh(t, e) {
        void 0 !== e && (delete t.prevTextDirection,
        t.canvas.style.setProperty("direction", e[0], e[1]))
    }
    function Vh(t) {
        return "angle" === t ? {
            between: Sr,
            compare: Cr,
            normalize: kr
        } : {
            between: Ar,
            compare: (t, e) => t - e,
            normalize: t => t
        }
    }
    function Yh({start: t, end: e, count: i, loop: n, style: s}) {
        return {
            start: t % i,
            end: e % i,
            loop: n && (e - t + 1) % i == 0,
            style: s
        }
    }
    function Xh(t, e, i) {
        if (!i)
            return [t];
        const {property: n, start: s, end: o} = i
          , a = e.length
          , {compare: r, between: l, normalize: h} = Vh(n)
          , {start: c, end: d, loop: u, style: p} = function(t, e, i) {
            const {property: n, start: s, end: o} = i
              , {between: a, normalize: r} = Vh(n)
              , l = e.length;
            let h, c, {start: d, end: u, loop: p} = t;
            if (p) {
                for (d += l,
                u += l,
                h = 0,
                c = l; h < c && a(r(e[d % l][n]), s, o); ++h)
                    d--,
                    u--;
                d %= l,
                u %= l
            }
            return u < d && (u += l),
            {
                start: d,
                end: u,
                loop: p,
                style: t.style
            }
        }(t, e, i)
          , f = [];
        let g, m, _, b = !1, v = null;
        const y = () => b || l(s, _, g) && 0 !== r(s, _)
          , x = () => !b || 0 === r(o, g) || l(o, _, g);
        for (let w = c, C = c; w <= d; ++w)
            m = e[w % a],
            m.skip || (g = h(m[n]),
            g !== _ && (b = l(g, s, o),
            null === v && y() && (v = 0 === r(g, s) ? w : C),
            null !== v && x() && (f.push(Yh({
                start: v,
                end: w,
                loop: u,
                count: a,
                style: p
            })),
            v = null),
            C = w,
            _ = g));
        return null !== v && f.push(Yh({
            start: v,
            end: d,
            loop: u,
            count: a,
            style: p
        })),
        f
    }
    function Kh(t, e) {
        const i = []
          , n = t.segments;
        for (let s = 0; s < n.length; s++) {
            const o = Xh(n[s], t.points, e);
            o.length && i.push(...o)
        }
        return i
    }
    function Uh(t, e, i, n) {
        return n && n.setContext && i ? function(t, e, i, n) {
            const s = t._chart.getContext()
              , o = qh(t.options)
              , {_datasetIndex: a, options: {spanGaps: r}} = t
              , l = i.length
              , h = [];
            let c = o
              , d = e[0].start
              , u = d;
            function p(t, e, n, s) {
                const o = r ? -1 : 1;
                if (t !== e) {
                    for (t += l; i[t % l].skip; )
                        t -= o;
                    for (; i[e % l].skip; )
                        e += o;
                    t % l !== e % l && (h.push({
                        start: t % l,
                        end: e % l,
                        loop: n,
                        style: s
                    }),
                    c = s,
                    d = e % l)
                }
            }
            for (const f of e) {
                d = r ? d : f.start;
                let t, e = i[d % l];
                for (u = d + 1; u <= f.end; u++) {
                    const o = i[u % l];
                    t = qh(n.setContext(ih(s, {
                        type: "segment",
                        p0: e,
                        p1: o,
                        p0DataIndex: (u - 1) % l,
                        p1DataIndex: u % l,
                        datasetIndex: a
                    }))),
                    Zh(t, c) && p(d, u - 1, f.loop, c),
                    e = o,
                    c = t
                }
                d < u - 1 && p(d, u - 1, f.loop, c)
            }
            return h
        }(t, e, i, n) : e
    }
    function qh(t) {
        return {
            backgroundColor: t.backgroundColor,
            borderCapStyle: t.borderCapStyle,
            borderDash: t.borderDash,
            borderDashOffset: t.borderDashOffset,
            borderJoinStyle: t.borderJoinStyle,
            borderWidth: t.borderWidth,
            borderColor: t.borderColor
        }
    }
    function Zh(t, e) {
        return e && JSON.stringify(t) !== JSON.stringify(e)
    }
    /*!
   * Chart.js v3.9.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   */
    var Gh = new class {
        constructor() {
            this._request = null,
            this._charts = new Map,
            this._running = !1,
            this._lastDate = void 0
        }
        _notify(t, e, i, n) {
            const s = e.listeners[n]
              , o = e.duration;
            s.forEach(n => n({
                chart: t,
                initial: e.initial,
                numSteps: o,
                currentStep: Math.min(i - e.start, o)
            }))
        }
        _refresh() {
            this._request || (this._running = !0,
            this._request = Lr.call(window, () => {
                this._update(),
                this._request = null,
                this._running && this._refresh()
            }
            ))
        }
        _update(t=Date.now()) {
            let e = 0;
            this._charts.forEach( (i, n) => {
                if (!i.running || !i.items.length)
                    return;
                const s = i.items;
                let o, a = s.length - 1, r = !1;
                for (; a >= 0; --a)
                    o = s[a],
                    o._active ? (o._total > i.duration && (i.duration = o._total),
                    o.tick(t),
                    r = !0) : (s[a] = s[s.length - 1],
                    s.pop());
                r && (n.draw(),
                this._notify(n, i, t, "progress")),
                s.length || (i.running = !1,
                this._notify(n, i, t, "complete"),
                i.initial = !1),
                e += s.length
            }
            ),
            this._lastDate = t,
            0 === e && (this._running = !1)
        }
        _getAnims(t) {
            const e = this._charts;
            let i = e.get(t);
            return i || (i = {
                running: !1,
                initial: !0,
                items: [],
                listeners: {
                    complete: [],
                    progress: []
                }
            },
            e.set(t, i)),
            i
        }
        listen(t, e, i) {
            this._getAnims(t).listeners[e].push(i)
        }
        add(t, e) {
            e && e.length && this._getAnims(t).items.push(...e)
        }
        has(t) {
            return this._getAnims(t).items.length > 0
        }
        start(t) {
            const e = this._charts.get(t);
            e && (e.running = !0,
            e.start = Date.now(),
            e.duration = e.items.reduce( (t, e) => Math.max(t, e._duration), 0),
            this._refresh())
        }
        running(t) {
            if (!this._running)
                return !1;
            const e = this._charts.get(t);
            return !!(e && e.running && e.items.length)
        }
        stop(t) {
            const e = this._charts.get(t);
            if (!e || !e.items.length)
                return;
            const i = e.items;
            let n = i.length - 1;
            for (; n >= 0; --n)
                i[n].cancel();
            e.items = [],
            this._notify(t, e, Date.now(), "complete")
        }
        remove(t) {
            return this._charts.delete(t)
        }
    }
    ;
    const Qh = "transparent"
      , Jh = {
        boolean: (t, e, i) => i > .5 ? e : t,
        color(t, e, i) {
            const n = Sl(t || Qh)
              , s = n.valid && Sl(e || Qh);
            return s && s.valid ? s.mix(n, i).hexString() : e
        },
        number: (t, e, i) => t + (e - t) * i
    };
    class tc {
        constructor(t, e, i, n) {
            const s = e[i];
            n = eh([t.to, n, s, t.from]);
            const o = eh([t.from, s, n]);
            this._active = !0,
            this._fn = t.fn || Jh[t.type || typeof o],
            this._easing = Wr[t.easing] || Wr.linear,
            this._start = Math.floor(Date.now() + (t.delay || 0)),
            this._duration = this._total = Math.floor(t.duration),
            this._loop = !!t.loop,
            this._target = e,
            this._prop = i,
            this._from = o,
            this._to = n,
            this._promises = void 0
        }
        active() {
            return this._active
        }
        update(t, e, i) {
            if (this._active) {
                this._notify(!1);
                const n = this._target[this._prop]
                  , s = i - this._start
                  , o = this._duration - s;
                this._start = i,
                this._duration = Math.floor(Math.max(o, t.duration)),
                this._total += s,
                this._loop = !!t.loop,
                this._to = eh([t.to, e, n, t.from]),
                this._from = eh([t.from, n, e])
            }
        }
        cancel() {
            this._active && (this.tick(Date.now()),
            this._active = !1,
            this._notify(!1))
        }
        tick(t) {
            const e = t - this._start
              , i = this._duration
              , n = this._prop
              , s = this._from
              , o = this._loop
              , a = this._to;
            let r;
            if (this._active = s !== a && (o || e < i),
            !this._active)
                return this._target[n] = a,
                void this._notify(!0);
            e < 0 ? this._target[n] = s : (r = e / i % 2,
            r = o && r > 1 ? 2 - r : r,
            r = this._easing(Math.min(1, Math.max(0, r))),
            this._target[n] = this._fn(s, a, r))
        }
        wait() {
            const t = this._promises || (this._promises = []);
            return new Promise( (e, i) => {
                t.push({
                    res: e,
                    rej: i
                })
            }
            )
        }
        _notify(t) {
            const e = t ? "res" : "rej"
              , i = this._promises || [];
            for (let n = 0; n < i.length; n++)
                i[n][e]()
        }
    }
    Dl.set("animation", {
        delay: void 0,
        duration: 1e3,
        easing: "easeOutQuart",
        fn: void 0,
        from: void 0,
        loop: void 0,
        to: void 0,
        type: void 0
    });
    const ec = Object.keys(Dl.animation);
    Dl.describe("animation", {
        _fallback: !1,
        _indexable: !1,
        _scriptable: t => "onProgress" !== t && "onComplete" !== t && "fn" !== t
    }),
    Dl.set("animations", {
        colors: {
            type: "color",
            properties: ["color", "borderColor", "backgroundColor"]
        },
        numbers: {
            type: "number",
            properties: ["x", "y", "borderWidth", "radius", "tension"]
        }
    }),
    Dl.describe("animations", {
        _fallback: "animation"
    }),
    Dl.set("transitions", {
        active: {
            animation: {
                duration: 400
            }
        },
        resize: {
            animation: {
                duration: 0
            }
        },
        show: {
            animations: {
                colors: {
                    from: "transparent"
                },
                visible: {
                    type: "boolean",
                    duration: 0
                }
            }
        },
        hide: {
            animations: {
                colors: {
                    to: "transparent"
                },
                visible: {
                    type: "boolean",
                    easing: "linear",
                    fn: t => 0 | t
                }
            }
        }
    });
    class ic {
        constructor(t, e) {
            this._chart = t,
            this._properties = new Map,
            this.configure(e)
        }
        configure(t) {
            if (!Ba(t))
                return;
            const e = this._properties;
            Object.getOwnPropertyNames(t).forEach(i => {
                const n = t[i];
                if (!Ba(n))
                    return;
                const s = {};
                for (const t of ec)
                    s[t] = n[t];
                (Na(n.properties) && n.properties || [i]).forEach(t => {
                    t !== i && e.has(t) || e.set(t, s)
                }
                )
            }
            )
        }
        _animateOptions(t, e) {
            const i = e.options
              , n = function(t, e) {
                if (!e)
                    return;
                let i = t.options;
                if (!i)
                    return void (t.options = e);
                i.$shared && (t.options = i = Object.assign({}, i, {
                    $shared: !1,
                    $animations: {}
                }));
                return i
            }(t, i);
            if (!n)
                return [];
            const s = this._createAnimations(n, i);
            return i.$shared && function(t, e) {
                const i = []
                  , n = Object.keys(e);
                for (let s = 0; s < n.length; s++) {
                    const e = t[n[s]];
                    e && e.active() && i.push(e.wait())
                }
                return Promise.all(i)
            }(t.options.$animations, i).then( () => {
                t.options = i
            }
            , () => {}
            ),
            s
        }
        _createAnimations(t, e) {
            const i = this._properties
              , n = []
              , s = t.$animations || (t.$animations = {})
              , o = Object.keys(e)
              , a = Date.now();
            let r;
            for (r = o.length - 1; r >= 0; --r) {
                const l = o[r];
                if ("$" === l.charAt(0))
                    continue;
                if ("options" === l) {
                    n.push(...this._animateOptions(t, e));
                    continue
                }
                const h = e[l];
                let c = s[l];
                const d = i.get(l);
                if (c) {
                    if (d && c.active()) {
                        c.update(d, h, a);
                        continue
                    }
                    c.cancel()
                }
                d && d.duration ? (s[l] = c = new tc(d,t,l,h),
                n.push(c)) : t[l] = h
            }
            return n
        }
        update(t, e) {
            if (0 === this._properties.size)
                return void Object.assign(t, e);
            const i = this._createAnimations(t, e);
            return i.length ? (Gh.add(this._chart, i),
            !0) : void 0
        }
    }
    function nc(t, e) {
        const i = t && t.options || {}
          , n = i.reverse
          , s = void 0 === i.min ? e : 0
          , o = void 0 === i.max ? e : 0;
        return {
            start: n ? o : s,
            end: n ? s : o
        }
    }
    function sc(t, e) {
        const i = []
          , n = t._getSortedDatasetMetas(e);
        let s, o;
        for (s = 0,
        o = n.length; s < o; ++s)
            i.push(n[s].index);
        return i
    }
    function oc(t, e, i, n={}) {
        const s = t.keys
          , o = "single" === n.mode;
        let a, r, l, h;
        if (null !== e) {
            for (a = 0,
            r = s.length; a < r; ++a) {
                if (l = +s[a],
                l === i) {
                    if (n.all)
                        continue;
                    break
                }
                h = t.values[l],
                Ha(h) && (o || 0 === e || pr(e) === pr(h)) && (e += h)
            }
            return e
        }
    }
    function ac(t, e) {
        const i = t && t.options.stacked;
        return i || void 0 === i && void 0 !== e.stack
    }
    function rc(t, e, i) {
        const n = t[e] || (t[e] = {});
        return n[i] || (n[i] = {})
    }
    function lc(t, e, i, n) {
        for (const s of e.getMatchingVisibleMetas(n).reverse()) {
            const e = t[s.index];
            if (i && e > 0 || !i && e < 0)
                return s.index
        }
        return null
    }
    function hc(t, e) {
        const {chart: i, _cachedMeta: n} = t
          , s = i._stacks || (i._stacks = {})
          , {iScale: o, vScale: a, index: r} = n
          , l = o.axis
          , h = a.axis
          , c = function(t, e, i) {
            return `${t.id}.${e.id}.${i.stack || i.type}`
        }(o, a, n)
          , d = e.length;
        let u;
        for (let p = 0; p < d; ++p) {
            const t = e[p]
              , {[l]: i, [h]: o} = t;
            u = (t._stacks || (t._stacks = {}))[h] = rc(s, c, i),
            u[r] = o,
            u._top = lc(u, a, !0, n.type),
            u._bottom = lc(u, a, !1, n.type)
        }
    }
    function cc(t, e) {
        const i = t.scales;
        return Object.keys(i).filter(t => i[t].axis === e).shift()
    }
    function dc(t, e) {
        const i = t.controller.index
          , n = t.vScale && t.vScale.axis;
        if (n) {
            e = e || t._parsed;
            for (const t of e) {
                const e = t._stacks;
                if (!e || void 0 === e[n] || void 0 === e[n][i])
                    return;
                delete e[n][i]
            }
        }
    }
    const uc = t => "reset" === t || "none" === t
      , pc = (t, e) => e ? t : Object.assign({}, t);
    class fc {
        constructor(t, e) {
            this.chart = t,
            this._ctx = t.ctx,
            this.index = e,
            this._cachedDataOpts = {},
            this._cachedMeta = this.getMeta(),
            this._type = this._cachedMeta.type,
            this.options = void 0,
            this._parsing = !1,
            this._data = void 0,
            this._objectData = void 0,
            this._sharedOptions = void 0,
            this._drawStart = void 0,
            this._drawCount = void 0,
            this.enableOptionSharing = !1,
            this.supportsDecimation = !1,
            this.$context = void 0,
            this._syncList = [],
            this.initialize()
        }
        initialize() {
            const t = this._cachedMeta;
            this.configure(),
            this.linkScales(),
            t._stacked = ac(t.vScale, t),
            this.addElements()
        }
        updateIndex(t) {
            this.index !== t && dc(this._cachedMeta),
            this.index = t
        }
        linkScales() {
            const t = this.chart
              , e = this._cachedMeta
              , i = this.getDataset()
              , n = (t, e, i, n) => "x" === t ? e : "r" === t ? n : i
              , s = e.xAxisID = za(i.xAxisID, cc(t, "x"))
              , o = e.yAxisID = za(i.yAxisID, cc(t, "y"))
              , a = e.rAxisID = za(i.rAxisID, cc(t, "r"))
              , r = e.indexAxis
              , l = e.iAxisID = n(r, s, o, a)
              , h = e.vAxisID = n(r, o, s, a);
            e.xScale = this.getScaleForId(s),
            e.yScale = this.getScaleForId(o),
            e.rScale = this.getScaleForId(a),
            e.iScale = this.getScaleForId(l),
            e.vScale = this.getScaleForId(h)
        }
        getDataset() {
            return this.chart.data.datasets[this.index]
        }
        getMeta() {
            return this.chart.getDatasetMeta(this.index)
        }
        getScaleForId(t) {
            return this.chart.scales[t]
        }
        _getOtherScale(t) {
            const e = this._cachedMeta;
            return t === e.iScale ? e.vScale : e.iScale
        }
        reset() {
            this._update("reset")
        }
        _destroy() {
            const t = this._cachedMeta;
            this._data && $r(this._data, this),
            t._stacked && dc(t)
        }
        _dataCheck() {
            const t = this.getDataset()
              , e = t.data || (t.data = [])
              , i = this._data;
            if (Ba(e))
                this._data = function(t) {
                    const e = Object.keys(t)
                      , i = new Array(e.length);
                    let n, s, o;
                    for (n = 0,
                    s = e.length; n < s; ++n)
                        o = e[n],
                        i[n] = {
                            x: o,
                            y: t[o]
                        };
                    return i
                }(e);
            else if (i !== e) {
                if (i) {
                    $r(i, this);
                    const t = this._cachedMeta;
                    dc(t),
                    t._parsed = []
                }
                e && Object.isExtensible(e) && (s = this,
                (n = e)._chartjs ? n._chartjs.listeners.push(s) : (Object.defineProperty(n, "_chartjs", {
                    configurable: !0,
                    enumerable: !1,
                    value: {
                        listeners: [s]
                    }
                }),
                Dr.forEach(t => {
                    const e = "_onData" + tr(t)
                      , i = n[t];
                    Object.defineProperty(n, t, {
                        configurable: !0,
                        enumerable: !1,
                        value(...t) {
                            const s = i.apply(this, t);
                            return n._chartjs.listeners.forEach(i => {
                                "function" == typeof i[e] && i[e](...t)
                            }
                            ),
                            s
                        }
                    })
                }
                ))),
                this._syncList = [],
                this._data = e
            }
            var n, s
        }
        addElements() {
            const t = this._cachedMeta;
            this._dataCheck(),
            this.datasetElementType && (t.dataset = new this.datasetElementType)
        }
        buildOrUpdateElements(t) {
            const e = this._cachedMeta
              , i = this.getDataset();
            let n = !1;
            this._dataCheck();
            const s = e._stacked;
            e._stacked = ac(e.vScale, e),
            e.stack !== i.stack && (n = !0,
            dc(e),
            e.stack = i.stack),
            this._resyncElements(t),
            (n || s !== e._stacked) && hc(this, e._parsed)
        }
        configure() {
            const t = this.chart.config
              , e = t.datasetScopeKeys(this._type)
              , i = t.getOptionScopes(this.getDataset(), e, !0);
            this.options = t.createResolver(i, this.getContext()),
            this._parsing = this.options.parsing,
            this._cachedDataOpts = {}
        }
        parse(t, e) {
            const {_cachedMeta: i, _data: n} = this
              , {iScale: s, _stacked: o} = i
              , a = s.axis;
            let r, l, h, c = 0 === t && e === n.length || i._sorted, d = t > 0 && i._parsed[t - 1];
            if (!1 === this._parsing)
                i._parsed = n,
                i._sorted = !0,
                h = n;
            else {
                h = Na(n[t]) ? this.parseArrayData(i, n, t, e) : Ba(n[t]) ? this.parseObjectData(i, n, t, e) : this.parsePrimitiveData(i, n, t, e);
                const s = () => null === l[a] || d && l[a] < d[a];
                for (r = 0; r < e; ++r)
                    i._parsed[r + t] = l = h[r],
                    c && (s() && (c = !1),
                    d = l);
                i._sorted = c
            }
            o && hc(this, h)
        }
        parsePrimitiveData(t, e, i, n) {
            const {iScale: s, vScale: o} = t
              , a = s.axis
              , r = o.axis
              , l = s.getLabels()
              , h = s === o
              , c = new Array(n);
            let d, u, p;
            for (d = 0,
            u = n; d < u; ++d)
                p = d + i,
                c[d] = {
                    [a]: h || s.parse(l[p], p),
                    [r]: o.parse(e[p], p)
                };
            return c
        }
        parseArrayData(t, e, i, n) {
            const {xScale: s, yScale: o} = t
              , a = new Array(n);
            let r, l, h, c;
            for (r = 0,
            l = n; r < l; ++r)
                h = r + i,
                c = e[h],
                a[r] = {
                    x: s.parse(c[0], h),
                    y: o.parse(c[1], h)
                };
            return a
        }
        parseObjectData(t, e, i, n) {
            const {xScale: s, yScale: o} = t
              , {xAxisKey: a="x", yAxisKey: r="y"} = this._parsing
              , l = new Array(n);
            let h, c, d, u;
            for (h = 0,
            c = n; h < c; ++h)
                d = h + i,
                u = e[d],
                l[h] = {
                    x: s.parse(Ja(u, a), d),
                    y: o.parse(Ja(u, r), d)
                };
            return l
        }
        getParsed(t) {
            return this._cachedMeta._parsed[t]
        }
        getDataElement(t) {
            return this._cachedMeta.data[t]
        }
        applyStack(t, e, i) {
            const n = this.chart
              , s = this._cachedMeta
              , o = e[t.axis];
            return oc({
                keys: sc(n, !0),
                values: e._stacks[t.axis]
            }, o, s.index, {
                mode: i
            })
        }
        updateRangeFromParsed(t, e, i, n) {
            const s = i[e.axis];
            let o = null === s ? NaN : s;
            const a = n && i._stacks[e.axis];
            n && a && (n.values = a,
            o = oc(n, s, this._cachedMeta.index)),
            t.min = Math.min(t.min, o),
            t.max = Math.max(t.max, o)
        }
        getMinMax(t, e) {
            const i = this._cachedMeta
              , n = i._parsed
              , s = i._sorted && t === i.iScale
              , o = n.length
              , a = this._getOtherScale(t)
              , r = ( (t, e, i) => t && !e.hidden && e._stacked && {
                keys: sc(i, !0),
                values: null
            })(e, i, this.chart)
              , l = {
                min: Number.POSITIVE_INFINITY,
                max: Number.NEGATIVE_INFINITY
            }
              , {min: h, max: c} = function(t) {
                const {min: e, max: i, minDefined: n, maxDefined: s} = t.getUserBounds();
                return {
                    min: n ? e : Number.NEGATIVE_INFINITY,
                    max: s ? i : Number.POSITIVE_INFINITY
                }
            }(a);
            let d, u;
            function p() {
                u = n[d];
                const e = u[a.axis];
                return !Ha(u[t.axis]) || h > e || c < e
            }
            for (d = 0; d < o && (p() || (this.updateRangeFromParsed(l, t, u, r),
            !s)); ++d)
                ;
            if (s)
                for (d = o - 1; d >= 0; --d)
                    if (!p()) {
                        this.updateRangeFromParsed(l, t, u, r);
                        break
                    }
            return l
        }
        getAllParsedValues(t) {
            const e = this._cachedMeta._parsed
              , i = [];
            let n, s, o;
            for (n = 0,
            s = e.length; n < s; ++n)
                o = e[n][t.axis],
                Ha(o) && i.push(o);
            return i
        }
        getMaxOverflow() {
            return !1
        }
        getLabelAndValue(t) {
            const e = this._cachedMeta
              , i = e.iScale
              , n = e.vScale
              , s = this.getParsed(t);
            return {
                label: i ? "" + i.getLabelForValue(s[i.axis]) : "",
                value: n ? "" + n.getLabelForValue(s[n.axis]) : ""
            }
        }
        _update(t) {
            const e = this._cachedMeta;
            this.update(t || "default"),
            e._clip = function(t) {
                let e, i, n, s;
                return Ba(t) ? (e = t.top,
                i = t.right,
                n = t.bottom,
                s = t.left) : e = i = n = s = t,
                {
                    top: e,
                    right: i,
                    bottom: n,
                    left: s,
                    disabled: !1 === t
                }
            }(za(this.options.clip, function(t, e, i) {
                if (!1 === i)
                    return !1;
                const n = nc(t, i)
                  , s = nc(e, i);
                return {
                    top: s.end,
                    right: n.end,
                    bottom: s.start,
                    left: n.start
                }
            }(e.xScale, e.yScale, this.getMaxOverflow())))
        }
        update(t) {}
        draw() {
            const t = this._ctx
              , e = this.chart
              , i = this._cachedMeta
              , n = i.data || []
              , s = e.chartArea
              , o = []
              , a = this._drawStart || 0
              , r = this._drawCount || n.length - a
              , l = this.options.drawActiveElementsOnTop;
            let h;
            for (i.dataset && i.dataset.draw(t, s, a, r),
            h = a; h < a + r; ++h) {
                const e = n[h];
                e.hidden || (e.active && l ? o.push(e) : e.draw(t, s))
            }
            for (h = 0; h < o.length; ++h)
                o[h].draw(t, s)
        }
        getStyle(t, e) {
            const i = e ? "active" : "default";
            return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i)
        }
        getContext(t, e, i) {
            const n = this.getDataset();
            let s;
            if (t >= 0 && t < this._cachedMeta.data.length) {
                const e = this._cachedMeta.data[t];
                s = e.$context || (e.$context = function(t, e, i) {
                    return ih(t, {
                        active: !1,
                        dataIndex: e,
                        parsed: void 0,
                        raw: void 0,
                        element: i,
                        index: e,
                        mode: "default",
                        type: "data"
                    })
                }(this.getContext(), t, e)),
                s.parsed = this.getParsed(t),
                s.raw = n.data[t],
                s.index = s.dataIndex = t
            } else
                s = this.$context || (this.$context = function(t, e) {
                    return ih(t, {
                        active: !1,
                        dataset: void 0,
                        datasetIndex: e,
                        index: e,
                        mode: "default",
                        type: "dataset"
                    })
                }(this.chart.getContext(), this.index)),
                s.dataset = n,
                s.index = s.datasetIndex = this.index;
            return s.active = !!e,
            s.mode = i,
            s
        }
        resolveDatasetElementOptions(t) {
            return this._resolveElementOptions(this.datasetElementType.id, t)
        }
        resolveDataElementOptions(t, e) {
            return this._resolveElementOptions(this.dataElementType.id, e, t)
        }
        _resolveElementOptions(t, e="default", i) {
            const n = "active" === e
              , s = this._cachedDataOpts
              , o = t + "-" + e
              , a = s[o]
              , r = this.enableOptionSharing && er(i);
            if (a)
                return pc(a, r);
            const l = this.chart.config
              , h = l.datasetElementScopeKeys(this._type, t)
              , c = n ? [`${t}Hover`, "hover", t, ""] : [t, ""]
              , d = l.getOptionScopes(this.getDataset(), h)
              , u = Object.keys(Dl.elements[t])
              , p = l.resolveNamedOptions(d, u, () => this.getContext(i, n), c);
            return p.$shared && (p.$shared = r,
            s[o] = Object.freeze(pc(p, r))),
            p
        }
        _resolveAnimations(t, e, i) {
            const n = this.chart
              , s = this._cachedDataOpts
              , o = `animation-${e}`
              , a = s[o];
            if (a)
                return a;
            let r;
            if (!1 !== n.options.animation) {
                const n = this.chart.config
                  , s = n.datasetAnimationScopeKeys(this._type, e)
                  , o = n.getOptionScopes(this.getDataset(), s);
                r = n.createResolver(o, this.getContext(t, i, e))
            }
            const l = new ic(n,r && r.animations);
            return r && r._cacheable && (s[o] = Object.freeze(l)),
            l
        }
        getSharedOptions(t) {
            if (t.$shared)
                return this._sharedOptions || (this._sharedOptions = Object.assign({}, t))
        }
        includeOptions(t, e) {
            return !e || uc(t) || this.chart._animationsDisabled
        }
        _getSharedOptions(t, e) {
            const i = this.resolveDataElementOptions(t, e)
              , n = this._sharedOptions
              , s = this.getSharedOptions(i)
              , o = this.includeOptions(e, s) || s !== n;
            return this.updateSharedOptions(s, e, i),
            {
                sharedOptions: s,
                includeOptions: o
            }
        }
        updateElement(t, e, i, n) {
            uc(n) ? Object.assign(t, i) : this._resolveAnimations(e, n).update(t, i)
        }
        updateSharedOptions(t, e, i) {
            t && !uc(e) && this._resolveAnimations(void 0, e).update(t, i)
        }
        _setStyle(t, e, i, n) {
            t.active = n;
            const s = this.getStyle(e, n);
            this._resolveAnimations(e, i, n).update(t, {
                options: !n && this.getSharedOptions(s) || s
            })
        }
        removeHoverStyle(t, e, i) {
            this._setStyle(t, i, "active", !1)
        }
        setHoverStyle(t, e, i) {
            this._setStyle(t, i, "active", !0)
        }
        _removeDatasetHoverStyle() {
            const t = this._cachedMeta.dataset;
            t && this._setStyle(t, void 0, "active", !1)
        }
        _setDatasetHoverStyle() {
            const t = this._cachedMeta.dataset;
            t && this._setStyle(t, void 0, "active", !0)
        }
        _resyncElements(t) {
            const e = this._data
              , i = this._cachedMeta.data;
            for (const [a,r,l] of this._syncList)
                this[a](r, l);
            this._syncList = [];
            const n = i.length
              , s = e.length
              , o = Math.min(s, n);
            o && this.parse(0, o),
            s > n ? this._insertElements(n, s - n, t) : s < n && this._removeElements(s, n - s)
        }
        _insertElements(t, e, i=!0) {
            const n = this._cachedMeta
              , s = n.data
              , o = t + e;
            let a;
            const r = t => {
                for (t.length += e,
                a = t.length - 1; a >= o; a--)
                    t[a] = t[a - e]
            }
            ;
            for (r(s),
            a = t; a < o; ++a)
                s[a] = new this.dataElementType;
            this._parsing && r(n._parsed),
            this.parse(t, e),
            i && this.updateElements(s, t, e, "reset")
        }
        updateElements(t, e, i, n) {}
        _removeElements(t, e) {
            const i = this._cachedMeta;
            if (this._parsing) {
                const n = i._parsed.splice(t, e);
                i._stacked && dc(i, n)
            }
            i.data.splice(t, e)
        }
        _sync(t) {
            if (this._parsing)
                this._syncList.push(t);
            else {
                const [e,i,n] = t;
                this[e](i, n)
            }
            this.chart._dataChanges.push([this.index, ...t])
        }
        _onDataPush() {
            const t = arguments.length;
            this._sync(["_insertElements", this.getDataset().data.length - t, t])
        }
        _onDataPop() {
            this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1])
        }
        _onDataShift() {
            this._sync(["_removeElements", 0, 1])
        }
        _onDataSplice(t, e) {
            e && this._sync(["_removeElements", t, e]);
            const i = arguments.length - 2;
            i && this._sync(["_insertElements", t, i])
        }
        _onDataUnshift() {
            this._sync(["_insertElements", 0, arguments.length])
        }
    }
    function gc(t) {
        const e = t.iScale
          , i = function(t, e) {
            if (!t._cache.$bar) {
                const i = t.getMatchingVisibleMetas(e);
                let n = [];
                for (let e = 0, s = i.length; e < s; e++)
                    n = n.concat(i[e].controller.getAllParsedValues(t));
                t._cache.$bar = Ir(n.sort( (t, e) => t - e))
            }
            return t._cache.$bar
        }(e, t.type);
        let n, s, o, a, r = e._length;
        const l = () => {
            32767 !== o && -32768 !== o && (er(a) && (r = Math.min(r, Math.abs(o - a) || r)),
            a = o)
        }
        ;
        for (n = 0,
        s = i.length; n < s; ++n)
            o = e.getPixelForValue(i[n]),
            l();
        for (a = void 0,
        n = 0,
        s = e.ticks.length; n < s; ++n)
            o = e.getPixelForTick(n),
            l();
        return r
    }
    function mc(t, e, i, n) {
        return Na(t) ? function(t, e, i, n) {
            const s = i.parse(t[0], n)
              , o = i.parse(t[1], n)
              , a = Math.min(s, o)
              , r = Math.max(s, o);
            let l = a
              , h = r;
            Math.abs(a) > Math.abs(r) && (l = r,
            h = a),
            e[i.axis] = h,
            e._custom = {
                barStart: l,
                barEnd: h,
                start: s,
                end: o,
                min: a,
                max: r
            }
        }(t, e, i, n) : e[i.axis] = i.parse(t, n),
        e
    }
    function _c(t, e, i, n) {
        const s = t.iScale
          , o = t.vScale
          , a = s.getLabels()
          , r = s === o
          , l = [];
        let h, c, d, u;
        for (h = i,
        c = i + n; h < c; ++h)
            u = e[h],
            d = {},
            d[s.axis] = r || s.parse(a[h], h),
            l.push(mc(u, d, o, h));
        return l
    }
    function bc(t) {
        return t && void 0 !== t.barStart && void 0 !== t.barEnd
    }
    function vc(t, e, i, n) {
        let s = e.borderSkipped;
        const o = {};
        if (!s)
            return void (t.borderSkipped = o);
        if (!0 === s)
            return void (t.borderSkipped = {
                top: !0,
                right: !0,
                bottom: !0,
                left: !0
            });
        const {start: a, end: r, reverse: l, top: h, bottom: c} = function(t) {
            let e, i, n, s, o;
            return t.horizontal ? (e = t.base > t.x,
            i = "left",
            n = "right") : (e = t.base < t.y,
            i = "bottom",
            n = "top"),
            e ? (s = "end",
            o = "start") : (s = "start",
            o = "end"),
            {
                start: i,
                end: n,
                reverse: e,
                top: s,
                bottom: o
            }
        }(t);
        "middle" === s && i && (t.enableBorderRadius = !0,
        (i._top || 0) === n ? s = h : (i._bottom || 0) === n ? s = c : (o[yc(c, a, r, l)] = !0,
        s = h)),
        o[yc(s, a, r, l)] = !0,
        t.borderSkipped = o
    }
    function yc(t, e, i, n) {
        var s, o, a;
        return n ? (a = i,
        t = xc(t = (s = t) === (o = e) ? a : s === a ? o : s, i, e)) : t = xc(t, e, i),
        t
    }
    function xc(t, e, i) {
        return "start" === t ? e : "end" === t ? i : t
    }
    function wc(t, {inflateAmount: e}, i) {
        t.inflateAmount = "auto" === e ? 1 === i ? .33 : 0 : e
    }
    fc.defaults = {},
    fc.prototype.datasetElementType = null,
    fc.prototype.dataElementType = null;
    class Cc extends fc {
        parsePrimitiveData(t, e, i, n) {
            return _c(t, e, i, n)
        }
        parseArrayData(t, e, i, n) {
            return _c(t, e, i, n)
        }
        parseObjectData(t, e, i, n) {
            const {iScale: s, vScale: o} = t
              , {xAxisKey: a="x", yAxisKey: r="y"} = this._parsing
              , l = "x" === s.axis ? a : r
              , h = "x" === o.axis ? a : r
              , c = [];
            let d, u, p, f;
            for (d = i,
            u = i + n; d < u; ++d)
                f = e[d],
                p = {},
                p[s.axis] = s.parse(Ja(f, l), d),
                c.push(mc(Ja(f, h), p, o, d));
            return c
        }
        updateRangeFromParsed(t, e, i, n) {
            super.updateRangeFromParsed(t, e, i, n);
            const s = i._custom;
            s && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, s.min),
            t.max = Math.max(t.max, s.max))
        }
        getMaxOverflow() {
            return 0
        }
        getLabelAndValue(t) {
            const e = this._cachedMeta
              , {iScale: i, vScale: n} = e
              , s = this.getParsed(t)
              , o = s._custom
              , a = bc(o) ? "[" + o.start + ", " + o.end + "]" : "" + n.getLabelForValue(s[n.axis]);
            return {
                label: "" + i.getLabelForValue(s[i.axis]),
                value: a
            }
        }
        initialize() {
            this.enableOptionSharing = !0,
            super.initialize();
            this._cachedMeta.stack = this.getDataset().stack
        }
        update(t) {
            const e = this._cachedMeta;
            this.updateElements(e.data, 0, e.data.length, t)
        }
        updateElements(t, e, i, n) {
            const s = "reset" === n
              , {index: o, _cachedMeta: {vScale: a}} = this
              , r = a.getBasePixel()
              , l = a.isHorizontal()
              , h = this._getRuler()
              , {sharedOptions: c, includeOptions: d} = this._getSharedOptions(e, n);
            for (let u = e; u < e + i; u++) {
                const e = this.getParsed(u)
                  , i = s || Ra(e[a.axis]) ? {
                    base: r,
                    head: r
                } : this._calculateBarValuePixels(u)
                  , p = this._calculateBarIndexPixels(u, h)
                  , f = (e._stacks || {})[a.axis]
                  , g = {
                    horizontal: l,
                    base: i.base,
                    enableBorderRadius: !f || bc(e._custom) || o === f._top || o === f._bottom,
                    x: l ? i.head : p.center,
                    y: l ? p.center : i.head,
                    height: l ? p.size : Math.abs(i.size),
                    width: l ? Math.abs(i.size) : p.size
                };
                d && (g.options = c || this.resolveDataElementOptions(u, t[u].active ? "active" : n));
                const m = g.options || t[u].options;
                vc(g, m, f, o),
                wc(g, m, h.ratio),
                this.updateElement(t[u], u, g, n)
            }
        }
        _getStacks(t, e) {
            const {iScale: i} = this._cachedMeta
              , n = i.getMatchingVisibleMetas(this._type).filter(t => t.controller.options.grouped)
              , s = i.options.stacked
              , o = []
              , a = t => {
                const i = t.controller.getParsed(e)
                  , n = i && i[t.vScale.axis];
                if (Ra(n) || isNaN(n))
                    return !0
            }
            ;
            for (const r of n)
                if ((void 0 === e || !a(r)) && ((!1 === s || -1 === o.indexOf(r.stack) || void 0 === s && void 0 === r.stack) && o.push(r.stack),
                r.index === t))
                    break;
            return o.length || o.push(void 0),
            o
        }
        _getStackCount(t) {
            return this._getStacks(void 0, t).length
        }
        _getStackIndex(t, e, i) {
            const n = this._getStacks(t, i)
              , s = void 0 !== e ? n.indexOf(e) : -1;
            return -1 === s ? n.length - 1 : s
        }
        _getRuler() {
            const t = this.options
              , e = this._cachedMeta
              , i = e.iScale
              , n = [];
            let s, o;
            for (s = 0,
            o = e.data.length; s < o; ++s)
                n.push(i.getPixelForValue(this.getParsed(s)[i.axis], s));
            const a = t.barThickness;
            return {
                min: a || gc(e),
                pixels: n,
                start: i._startPixel,
                end: i._endPixel,
                stackCount: this._getStackCount(),
                scale: i,
                grouped: t.grouped,
                ratio: a ? 1 : t.categoryPercentage * t.barPercentage
            }
        }
        _calculateBarValuePixels(t) {
            const {_cachedMeta: {vScale: e, _stacked: i}, options: {base: n, minBarLength: s}} = this
              , o = n || 0
              , a = this.getParsed(t)
              , r = a._custom
              , l = bc(r);
            let h, c, d = a[e.axis], u = 0, p = i ? this.applyStack(e, a, i) : d;
            p !== d && (u = p - d,
            p = d),
            l && (d = r.barStart,
            p = r.barEnd - r.barStart,
            0 !== d && pr(d) !== pr(r.barEnd) && (u = 0),
            u += d);
            const f = Ra(n) || l ? u : n;
            let g = e.getPixelForValue(f);
            if (h = this.chart.getDataVisibility(t) ? e.getPixelForValue(u + p) : g,
            c = h - g,
            Math.abs(c) < s) {
                c = function(t, e, i) {
                    return 0 !== t ? pr(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1)
                }(c, e, o) * s,
                d === o && (g -= c / 2);
                const t = e.getPixelForDecimal(0)
                  , i = e.getPixelForDecimal(1)
                  , n = Math.min(t, i)
                  , a = Math.max(t, i);
                g = Math.max(Math.min(g, a), n),
                h = g + c
            }
            if (g === e.getPixelForValue(o)) {
                const t = pr(c) * e.getLineWidthForValue(o) / 2;
                g += t,
                c -= t
            }
            return {
                size: c,
                base: g,
                head: h,
                center: h + c / 2
            }
        }
        _calculateBarIndexPixels(t, e) {
            const i = e.scale
              , n = this.options
              , s = n.skipNull
              , o = za(n.maxBarThickness, 1 / 0);
            let a, r;
            if (e.grouped) {
                const i = s ? this._getStackCount(t) : e.stackCount
                  , l = "flex" === n.barThickness ? function(t, e, i, n) {
                    const s = e.pixels
                      , o = s[t];
                    let a = t > 0 ? s[t - 1] : null
                      , r = t < s.length - 1 ? s[t + 1] : null;
                    const l = i.categoryPercentage;
                    null === a && (a = o - (null === r ? e.end - e.start : r - o)),
                    null === r && (r = o + o - a);
                    const h = o - (o - Math.min(a, r)) / 2 * l;
                    return {
                        chunk: Math.abs(r - a) / 2 * l / n,
                        ratio: i.barPercentage,
                        start: h
                    }
                }(t, e, n, i) : function(t, e, i, n) {
                    const s = i.barThickness;
                    let o, a;
                    return Ra(s) ? (o = e.min * i.categoryPercentage,
                    a = i.barPercentage) : (o = s * n,
                    a = 1),
                    {
                        chunk: o / n,
                        ratio: a,
                        start: e.pixels[t] - o / 2
                    }
                }(t, e, n, i)
                  , h = this._getStackIndex(this.index, this._cachedMeta.stack, s ? t : void 0);
                a = l.start + l.chunk * h + l.chunk / 2,
                r = Math.min(o, l.chunk * l.ratio)
            } else
                a = i.getPixelForValue(this.getParsed(t)[i.axis], t),
                r = Math.min(o, e.min * e.ratio);
            return {
                base: a - r / 2,
                head: a + r / 2,
                center: a,
                size: r
            }
        }
        draw() {
            const t = this._cachedMeta
              , e = t.vScale
              , i = t.data
              , n = i.length;
            let s = 0;
            for (; s < n; ++s)
                null !== this.getParsed(s)[e.axis] && i[s].draw(this._ctx)
        }
    }
    Cc.id = "bar",
    Cc.defaults = {
        datasetElementType: !1,
        dataElementType: "bar",
        categoryPercentage: .8,
        barPercentage: .9,
        grouped: !0,
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "base", "width", "height"]
            }
        }
    },
    Cc.overrides = {
        scales: {
            _index_: {
                type: "category",
                offset: !0,
                grid: {
                    offset: !0
                }
            },
            _value_: {
                type: "linear",
                beginAtZero: !0
            }
        }
    };
    class kc extends fc {
        initialize() {
            this.enableOptionSharing = !0,
            super.initialize()
        }
        parsePrimitiveData(t, e, i, n) {
            const s = super.parsePrimitiveData(t, e, i, n);
            for (let o = 0; o < s.length; o++)
                s[o]._custom = this.resolveDataElementOptions(o + i).radius;
            return s
        }
        parseArrayData(t, e, i, n) {
            const s = super.parseArrayData(t, e, i, n);
            for (let o = 0; o < s.length; o++) {
                const t = e[i + o];
                s[o]._custom = za(t[2], this.resolveDataElementOptions(o + i).radius)
            }
            return s
        }
        parseObjectData(t, e, i, n) {
            const s = super.parseObjectData(t, e, i, n);
            for (let o = 0; o < s.length; o++) {
                const t = e[i + o];
                s[o]._custom = za(t && t.r && +t.r, this.resolveDataElementOptions(o + i).radius)
            }
            return s
        }
        getMaxOverflow() {
            const t = this._cachedMeta.data;
            let e = 0;
            for (let i = t.length - 1; i >= 0; --i)
                e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) / 2);
            return e > 0 && e
        }
        getLabelAndValue(t) {
            const e = this._cachedMeta
              , {xScale: i, yScale: n} = e
              , s = this.getParsed(t)
              , o = i.getLabelForValue(s.x)
              , a = n.getLabelForValue(s.y)
              , r = s._custom;
            return {
                label: e.label,
                value: "(" + o + ", " + a + (r ? ", " + r : "") + ")"
            }
        }
        update(t) {
            const e = this._cachedMeta.data;
            this.updateElements(e, 0, e.length, t)
        }
        updateElements(t, e, i, n) {
            const s = "reset" === n
              , {iScale: o, vScale: a} = this._cachedMeta
              , {sharedOptions: r, includeOptions: l} = this._getSharedOptions(e, n)
              , h = o.axis
              , c = a.axis;
            for (let d = e; d < e + i; d++) {
                const e = t[d]
                  , i = !s && this.getParsed(d)
                  , u = {}
                  , p = u[h] = s ? o.getPixelForDecimal(.5) : o.getPixelForValue(i[h])
                  , f = u[c] = s ? a.getBasePixel() : a.getPixelForValue(i[c]);
                u.skip = isNaN(p) || isNaN(f),
                l && (u.options = r || this.resolveDataElementOptions(d, e.active ? "active" : n),
                s && (u.options.radius = 0)),
                this.updateElement(e, d, u, n)
            }
        }
        resolveDataElementOptions(t, e) {
            const i = this.getParsed(t);
            let n = super.resolveDataElementOptions(t, e);
            n.$shared && (n = Object.assign({}, n, {
                $shared: !1
            }));
            const s = n.radius;
            return "active" !== e && (n.radius = 0),
            n.radius += za(i && i._custom, s),
            n
        }
    }
    kc.id = "bubble",
    kc.defaults = {
        datasetElementType: !1,
        dataElementType: "point",
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "borderWidth", "radius"]
            }
        }
    },
    kc.overrides = {
        scales: {
            x: {
                type: "linear"
            },
            y: {
                type: "linear"
            }
        },
        plugins: {
            tooltip: {
                callbacks: {
                    title: () => ""
                }
            }
        }
    };
    class Sc extends fc {
        constructor(t, e) {
            super(t, e),
            this.enableOptionSharing = !0,
            this.innerRadius = void 0,
            this.outerRadius = void 0,
            this.offsetX = void 0,
            this.offsetY = void 0
        }
        linkScales() {}
        parse(t, e) {
            const i = this.getDataset().data
              , n = this._cachedMeta;
            if (!1 === this._parsing)
                n._parsed = i;
            else {
                let s, o, a = t => +i[t];
                if (Ba(i[t])) {
                    const {key: t="value"} = this._parsing;
                    a = e => +Ja(i[e], t)
                }
                for (s = t,
                o = t + e; s < o; ++s)
                    n._parsed[s] = a(s)
            }
        }
        _getRotation() {
            return br(this.options.rotation - 90)
        }
        _getCircumference() {
            return br(this.options.circumference)
        }
        _getRotationExtents() {
            let t = or
              , e = -or;
            for (let i = 0; i < this.chart.data.datasets.length; ++i)
                if (this.chart.isDatasetVisible(i)) {
                    const n = this.chart.getDatasetMeta(i).controller
                      , s = n._getRotation()
                      , o = n._getCircumference();
                    t = Math.min(t, s),
                    e = Math.max(e, s + o)
                }
            return {
                rotation: t,
                circumference: e - t
            }
        }
        update(t) {
            const e = this.chart
              , {chartArea: i} = e
              , n = this._cachedMeta
              , s = n.data
              , o = this.getMaxBorderWidth() + this.getMaxOffset(s) + this.options.spacing
              , a = Math.max((Math.min(i.width, i.height) - o) / 2, 0)
              , r = Math.min((l = this.options.cutout,
            h = a,
            "string" == typeof l && l.endsWith("%") ? parseFloat(l) / 100 : l / h), 1);
            var l, h;
            const c = this._getRingWeight(this.index)
              , {circumference: d, rotation: u} = this._getRotationExtents()
              , {ratioX: p, ratioY: f, offsetX: g, offsetY: m} = function(t, e, i) {
                let n = 1
                  , s = 1
                  , o = 0
                  , a = 0;
                if (e < or) {
                    const r = t
                      , l = r + e
                      , h = Math.cos(r)
                      , c = Math.sin(r)
                      , d = Math.cos(l)
                      , u = Math.sin(l)
                      , p = (t, e, n) => Sr(t, r, l, !0) ? 1 : Math.max(e, e * i, n, n * i)
                      , f = (t, e, n) => Sr(t, r, l, !0) ? -1 : Math.min(e, e * i, n, n * i)
                      , g = p(0, h, d)
                      , m = p(hr, c, u)
                      , _ = f(sr, h, d)
                      , b = f(sr + hr, c, u);
                    n = (g - _) / 2,
                    s = (m - b) / 2,
                    o = -(g + _) / 2,
                    a = -(m + b) / 2
                }
                return {
                    ratioX: n,
                    ratioY: s,
                    offsetX: o,
                    offsetY: a
                }
            }(u, d, r)
              , _ = (i.width - o) / p
              , b = (i.height - o) / f
              , v = Math.max(Math.min(_, b) / 2, 0)
              , y = ja(this.options.radius, v)
              , x = (y - Math.max(y * r, 0)) / this._getVisibleDatasetWeightTotal();
            this.offsetX = g * y,
            this.offsetY = m * y,
            n.total = this.calculateTotal(),
            this.outerRadius = y - x * this._getRingWeightOffset(this.index),
            this.innerRadius = Math.max(this.outerRadius - x * c, 0),
            this.updateElements(s, 0, s.length, t)
        }
        _circumference(t, e) {
            const i = this.options
              , n = this._cachedMeta
              , s = this._getCircumference();
            return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === n._parsed[t] || n.data[t].hidden ? 0 : this.calculateCircumference(n._parsed[t] * s / or)
        }
        updateElements(t, e, i, n) {
            const s = "reset" === n
              , o = this.chart
              , a = o.chartArea
              , r = o.options.animation
              , l = (a.left + a.right) / 2
              , h = (a.top + a.bottom) / 2
              , c = s && r.animateScale
              , d = c ? 0 : this.innerRadius
              , u = c ? 0 : this.outerRadius
              , {sharedOptions: p, includeOptions: f} = this._getSharedOptions(e, n);
            let g, m = this._getRotation();
            for (g = 0; g < e; ++g)
                m += this._circumference(g, s);
            for (g = e; g < e + i; ++g) {
                const e = this._circumference(g, s)
                  , i = t[g]
                  , o = {
                    x: l + this.offsetX,
                    y: h + this.offsetY,
                    startAngle: m,
                    endAngle: m + e,
                    circumference: e,
                    outerRadius: u,
                    innerRadius: d
                };
                f && (o.options = p || this.resolveDataElementOptions(g, i.active ? "active" : n)),
                m += e,
                this.updateElement(i, g, o, n)
            }
        }
        calculateTotal() {
            const t = this._cachedMeta
              , e = t.data;
            let i, n = 0;
            for (i = 0; i < e.length; i++) {
                const s = t._parsed[i];
                null === s || isNaN(s) || !this.chart.getDataVisibility(i) || e[i].hidden || (n += Math.abs(s))
            }
            return n
        }
        calculateCircumference(t) {
            const e = this._cachedMeta.total;
            return e > 0 && !isNaN(t) ? or * (Math.abs(t) / e) : 0
        }
        getLabelAndValue(t) {
            const e = this._cachedMeta
              , i = this.chart
              , n = i.data.labels || []
              , s = Fh(e._parsed[t], i.options.locale);
            return {
                label: n[t] || "",
                value: s
            }
        }
        getMaxBorderWidth(t) {
            let e = 0;
            const i = this.chart;
            let n, s, o, a, r;
            if (!t)
                for (n = 0,
                s = i.data.datasets.length; n < s; ++n)
                    if (i.isDatasetVisible(n)) {
                        o = i.getDatasetMeta(n),
                        t = o.data,
                        a = o.controller;
                        break
                    }
            if (!t)
                return 0;
            for (n = 0,
            s = t.length; n < s; ++n)
                r = a.resolveDataElementOptions(n),
                "inner" !== r.borderAlign && (e = Math.max(e, r.borderWidth || 0, r.hoverBorderWidth || 0));
            return e
        }
        getMaxOffset(t) {
            let e = 0;
            for (let i = 0, n = t.length; i < n; ++i) {
                const t = this.resolveDataElementOptions(i);
                e = Math.max(e, t.offset || 0, t.hoverOffset || 0)
            }
            return e
        }
        _getRingWeightOffset(t) {
            let e = 0;
            for (let i = 0; i < t; ++i)
                this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));
            return e
        }
        _getRingWeight(t) {
            return Math.max(za(this.chart.data.datasets[t].weight, 1), 0)
        }
        _getVisibleDatasetWeightTotal() {
            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
        }
    }
    Sc.id = "doughnut",
    Sc.defaults = {
        datasetElementType: !1,
        dataElementType: "arc",
        animation: {
            animateRotate: !0,
            animateScale: !1
        },
        animations: {
            numbers: {
                type: "number",
                properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
            }
        },
        cutout: "50%",
        rotation: 0,
        circumference: 360,
        radius: "100%",
        spacing: 0,
        indexAxis: "r"
    },
    Sc.descriptors = {
        _scriptable: t => "spacing" !== t,
        _indexable: t => "spacing" !== t
    },
    Sc.overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels(t) {
                        const e = t.data;
                        if (e.labels.length && e.datasets.length) {
                            const {labels: {pointStyle: i}} = t.legend.options;
                            return e.labels.map( (e, n) => {
                                const s = t.getDatasetMeta(0).controller.getStyle(n);
                                return {
                                    text: e,
                                    fillStyle: s.backgroundColor,
                                    strokeStyle: s.borderColor,
                                    lineWidth: s.borderWidth,
                                    pointStyle: i,
                                    hidden: !t.getDataVisibility(n),
                                    index: n
                                }
                            }
                            )
                        }
                        return []
                    }
                },
                onClick(t, e, i) {
                    i.chart.toggleDataVisibility(e.index),
                    i.chart.update()
                }
            },
            tooltip: {
                callbacks: {
                    title: () => "",
                    label(t) {
                        let e = t.label;
                        const i = ": " + t.formattedValue;
                        return Na(e) ? (e = e.slice(),
                        e[0] += i) : e += i,
                        e
                    }
                }
            }
        }
    };
    class Tc extends fc {
        initialize() {
            this.enableOptionSharing = !0,
            this.supportsDecimation = !0,
            super.initialize()
        }
        update(t) {
            const e = this._cachedMeta
              , {dataset: i, data: n=[], _dataset: s} = e
              , o = this.chart._animationsDisabled;
            let {start: a, count: r} = Br(e, n, o);
            this._drawStart = a,
            this._drawCount = r,
            Hr(e) && (a = 0,
            r = n.length),
            i._chart = this.chart,
            i._datasetIndex = this.index,
            i._decimated = !!s._decimated,
            i.points = n;
            const l = this.resolveDatasetElementOptions(t);
            this.options.showLine || (l.borderWidth = 0),
            l.segment = this.options.segment,
            this.updateElement(i, void 0, {
                animated: !o,
                options: l
            }, t),
            this.updateElements(n, a, r, t)
        }
        updateElements(t, e, i, n) {
            const s = "reset" === n
              , {iScale: o, vScale: a, _stacked: r, _dataset: l} = this._cachedMeta
              , {sharedOptions: h, includeOptions: c} = this._getSharedOptions(e, n)
              , d = o.axis
              , u = a.axis
              , {spanGaps: p, segment: f} = this.options
              , g = gr(p) ? p : Number.POSITIVE_INFINITY
              , m = this.chart._animationsDisabled || s || "none" === n;
            let _ = e > 0 && this.getParsed(e - 1);
            for (let b = e; b < e + i; ++b) {
                const e = t[b]
                  , i = this.getParsed(b)
                  , p = m ? e : {}
                  , v = Ra(i[u])
                  , y = p[d] = o.getPixelForValue(i[d], b)
                  , x = p[u] = s || v ? a.getBasePixel() : a.getPixelForValue(r ? this.applyStack(a, i, r) : i[u], b);
                p.skip = isNaN(y) || isNaN(x) || v,
                p.stop = b > 0 && Math.abs(i[d] - _[d]) > g,
                f && (p.parsed = i,
                p.raw = l.data[b]),
                c && (p.options = h || this.resolveDataElementOptions(b, e.active ? "active" : n)),
                m || this.updateElement(e, b, p, n),
                _ = i
            }
        }
        getMaxOverflow() {
            const t = this._cachedMeta
              , e = t.dataset
              , i = e.options && e.options.borderWidth || 0
              , n = t.data || [];
            if (!n.length)
                return i;
            const s = n[0].size(this.resolveDataElementOptions(0))
              , o = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1));
            return Math.max(i, s, o) / 2
        }
        draw() {
            const t = this._cachedMeta;
            t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis),
            super.draw()
        }
    }
    Tc.id = "line",
    Tc.defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        showLine: !0,
        spanGaps: !1
    },
    Tc.overrides = {
        scales: {
            _index_: {
                type: "category"
            },
            _value_: {
                type: "linear"
            }
        }
    };
    class Ac extends fc {
        constructor(t, e) {
            super(t, e),
            this.innerRadius = void 0,
            this.outerRadius = void 0
        }
        getLabelAndValue(t) {
            const e = this._cachedMeta
              , i = this.chart
              , n = i.data.labels || []
              , s = Fh(e._parsed[t].r, i.options.locale);
            return {
                label: n[t] || "",
                value: s
            }
        }
        parseObjectData(t, e, i, n) {
            return mh.bind(this)(t, e, i, n)
        }
        update(t) {
            const e = this._cachedMeta.data;
            this._updateRadius(),
            this.updateElements(e, 0, e.length, t)
        }
        getMinMax() {
            const t = this._cachedMeta
              , e = {
                min: Number.POSITIVE_INFINITY,
                max: Number.NEGATIVE_INFINITY
            };
            return t.data.forEach( (t, i) => {
                const n = this.getParsed(i).r;
                !isNaN(n) && this.chart.getDataVisibility(i) && (n < e.min && (e.min = n),
                n > e.max && (e.max = n))
            }
            ),
            e
        }
        _updateRadius() {
            const t = this.chart
              , e = t.chartArea
              , i = t.options
              , n = Math.min(e.right - e.left, e.bottom - e.top)
              , s = Math.max(n / 2, 0)
              , o = (s - Math.max(i.cutoutPercentage ? s / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount();
            this.outerRadius = s - o * this.index,
            this.innerRadius = this.outerRadius - o
        }
        updateElements(t, e, i, n) {
            const s = "reset" === n
              , o = this.chart
              , a = o.options.animation
              , r = this._cachedMeta.rScale
              , l = r.xCenter
              , h = r.yCenter
              , c = r.getIndexAngle(0) - .5 * sr;
            let d, u = c;
            const p = 360 / this.countVisibleElements();
            for (d = 0; d < e; ++d)
                u += this._computeAngle(d, n, p);
            for (d = e; d < e + i; d++) {
                const e = t[d];
                let i = u
                  , f = u + this._computeAngle(d, n, p)
                  , g = o.getDataVisibility(d) ? r.getDistanceFromCenterForValue(this.getParsed(d).r) : 0;
                u = f,
                s && (a.animateScale && (g = 0),
                a.animateRotate && (i = f = c));
                const m = {
                    x: l,
                    y: h,
                    innerRadius: 0,
                    outerRadius: g,
                    startAngle: i,
                    endAngle: f,
                    options: this.resolveDataElementOptions(d, e.active ? "active" : n)
                };
                this.updateElement(e, d, m, n)
            }
        }
        countVisibleElements() {
            const t = this._cachedMeta;
            let e = 0;
            return t.data.forEach( (t, i) => {
                !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && e++
            }
            ),
            e
        }
        _computeAngle(t, e, i) {
            return this.chart.getDataVisibility(t) ? br(this.resolveDataElementOptions(t, e).angle || i) : 0
        }
    }
    Ac.id = "polarArea",
    Ac.defaults = {
        dataElementType: "arc",
        animation: {
            animateRotate: !0,
            animateScale: !0
        },
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
            }
        },
        indexAxis: "r",
        startAngle: 0
    },
    Ac.overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels(t) {
                        const e = t.data;
                        if (e.labels.length && e.datasets.length) {
                            const {labels: {pointStyle: i}} = t.legend.options;
                            return e.labels.map( (e, n) => {
                                const s = t.getDatasetMeta(0).controller.getStyle(n);
                                return {
                                    text: e,
                                    fillStyle: s.backgroundColor,
                                    strokeStyle: s.borderColor,
                                    lineWidth: s.borderWidth,
                                    pointStyle: i,
                                    hidden: !t.getDataVisibility(n),
                                    index: n
                                }
                            }
                            )
                        }
                        return []
                    }
                },
                onClick(t, e, i) {
                    i.chart.toggleDataVisibility(e.index),
                    i.chart.update()
                }
            },
            tooltip: {
                callbacks: {
                    title: () => "",
                    label: t => t.chart.data.labels[t.dataIndex] + ": " + t.formattedValue
                }
            }
        },
        scales: {
            r: {
                type: "radialLinear",
                angleLines: {
                    display: !1
                },
                beginAtZero: !0,
                grid: {
                    circular: !0
                },
                pointLabels: {
                    display: !1
                },
                startAngle: 0
            }
        }
    };
    class Ec extends Sc {
    }
    Ec.id = "pie",
    Ec.defaults = {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: "100%"
    };
    class Mc extends fc {
        getLabelAndValue(t) {
            const e = this._cachedMeta.vScale
              , i = this.getParsed(t);
            return {
                label: e.getLabels()[t],
                value: "" + e.getLabelForValue(i[e.axis])
            }
        }
        parseObjectData(t, e, i, n) {
            return mh.bind(this)(t, e, i, n)
        }
        update(t) {
            const e = this._cachedMeta
              , i = e.dataset
              , n = e.data || []
              , s = e.iScale.getLabels();
            if (i.points = n,
            "resize" !== t) {
                const e = this.resolveDatasetElementOptions(t);
                this.options.showLine || (e.borderWidth = 0);
                const o = {
                    _loop: !0,
                    _fullLoop: s.length === n.length,
                    options: e
                };
                this.updateElement(i, void 0, o, t)
            }
            this.updateElements(n, 0, n.length, t)
        }
        updateElements(t, e, i, n) {
            const s = this._cachedMeta.rScale
              , o = "reset" === n;
            for (let a = e; a < e + i; a++) {
                const e = t[a]
                  , i = this.resolveDataElementOptions(a, e.active ? "active" : n)
                  , r = s.getPointPositionForValue(a, this.getParsed(a).r)
                  , l = o ? s.xCenter : r.x
                  , h = o ? s.yCenter : r.y
                  , c = {
                    x: l,
                    y: h,
                    angle: r.angle,
                    skip: isNaN(l) || isNaN(h),
                    options: i
                };
                this.updateElement(e, a, c, n)
            }
        }
    }
    Mc.id = "radar",
    Mc.defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        indexAxis: "r",
        showLine: !0,
        elements: {
            line: {
                fill: "start"
            }
        }
    },
    Mc.overrides = {
        aspectRatio: 1,
        scales: {
            r: {
                type: "radialLinear"
            }
        }
    };
    let Oc = class {
        constructor() {
            this.x = void 0,
            this.y = void 0,
            this.active = !1,
            this.options = void 0,
            this.$animations = void 0
        }
        tooltipPosition(t) {
            const {x: e, y: i} = this.getProps(["x", "y"], t);
            return {
                x: e,
                y: i
            }
        }
        hasValue() {
            return gr(this.x) && gr(this.y)
        }
        getProps(t, e) {
            const i = this.$animations;
            if (!e || !i)
                return this;
            const n = {};
            return t.forEach(t => {
                n[t] = i[t] && i[t].active() ? i[t]._to : this[t]
            }
            ),
            n
        }
    }
    ;
    Oc.defaults = {},
    Oc.defaultRoutes = void 0;
    const Dc = {
        values: t => Na(t) ? t : "" + t,
        numeric(t, e, i) {
            if (0 === t)
                return "0";
            const n = this.chart.options.locale;
            let s, o = t;
            if (i.length > 1) {
                const e = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
                (e < 1e-4 || e > 1e15) && (s = "scientific"),
                o = function(t, e) {
                    let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
                    Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t));
                    return i
                }(t, i)
            }
            const a = ur(Math.abs(o))
              , r = Math.max(Math.min(-1 * Math.floor(a), 20), 0)
              , l = {
                notation: s,
                minimumFractionDigits: r,
                maximumFractionDigits: r
            };
            return Object.assign(l, this.options.ticks.format),
            Fh(t, n, l)
        },
        logarithmic(t, e, i) {
            if (0 === t)
                return "0";
            const n = t / Math.pow(10, Math.floor(ur(t)));
            return 1 === n || 2 === n || 5 === n ? Dc.numeric.call(this, t, e, i) : ""
        }
    };
    var $c = {
        formatters: Dc
    };
    function Ic(t, e) {
        const i = t.options.ticks
          , n = i.maxTicksLimit || function(t) {
            const e = t.options.offset
              , i = t._tickSize()
              , n = t._length / i + (e ? 0 : 1)
              , s = t._maxLength / i;
            return Math.floor(Math.min(n, s))
        }(t)
          , s = i.major.enabled ? function(t) {
            const e = [];
            let i, n;
            for (i = 0,
            n = t.length; i < n; i++)
                t[i].major && e.push(i);
            return e
        }(e) : []
          , o = s.length
          , a = s[0]
          , r = s[o - 1]
          , l = [];
        if (o > n)
            return function(t, e, i, n) {
                let s, o = 0, a = i[0];
                for (n = Math.ceil(n),
                s = 0; s < t.length; s++)
                    s === a && (e.push(t[s]),
                    o++,
                    a = i[o * n])
            }(e, l, s, o / n),
            l;
        const h = function(t, e, i) {
            const n = function(t) {
                const e = t.length;
                let i, n;
                if (e < 2)
                    return !1;
                for (n = t[0],
                i = 1; i < e; ++i)
                    if (t[i] - t[i - 1] !== n)
                        return !1;
                return n
            }(t)
              , s = e.length / i;
            if (!n)
                return Math.max(s, 1);
            const o = function(t) {
                const e = []
                  , i = Math.sqrt(t);
                let n;
                for (n = 1; n < i; n++)
                    t % n === 0 && (e.push(n),
                    e.push(t / n));
                return i === (0 | i) && e.push(i),
                e.sort( (t, e) => t - e).pop(),
                e
            }(n);
            for (let a = 0, r = o.length - 1; a < r; a++) {
                const t = o[a];
                if (t > s)
                    return t
            }
            return Math.max(s, 1)
        }(s, e, n);
        if (o > 0) {
            let t, i;
            const n = o > 1 ? Math.round((r - a) / (o - 1)) : null;
            for (Lc(e, l, h, Ra(n) ? 0 : a - n, a),
            t = 0,
            i = o - 1; t < i; t++)
                Lc(e, l, h, s[t], s[t + 1]);
            return Lc(e, l, h, r, Ra(n) ? e.length : r + n),
            l
        }
        return Lc(e, l, h),
        l
    }
    function Lc(t, e, i, n, s) {
        const o = za(n, 0)
          , a = Math.min(za(s, t.length), t.length);
        let r, l, h, c = 0;
        for (i = Math.ceil(i),
        s && (r = s - n,
        i = r / Math.floor(r / i)),
        h = o; h < 0; )
            c++,
            h = Math.round(o + c * i);
        for (l = Math.max(o, 0); l < a; l++)
            l === h && (e.push(t[l]),
            c++,
            h = Math.round(o + c * i))
    }
    Dl.set("scale", {
        display: !0,
        offset: !1,
        reverse: !1,
        beginAtZero: !1,
        bounds: "ticks",
        grace: 0,
        grid: {
            display: !0,
            lineWidth: 1,
            drawBorder: !0,
            drawOnChartArea: !0,
            drawTicks: !0,
            tickLength: 8,
            tickWidth: (t, e) => e.lineWidth,
            tickColor: (t, e) => e.color,
            offset: !1,
            borderDash: [],
            borderDashOffset: 0,
            borderWidth: 1
        },
        title: {
            display: !1,
            text: "",
            padding: {
                top: 4,
                bottom: 4
            }
        },
        ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: !1,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: !0,
            autoSkip: !0,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: $c.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: !1,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
        }
    }),
    Dl.route("scale.ticks", "color", "", "color"),
    Dl.route("scale.grid", "color", "", "borderColor"),
    Dl.route("scale.grid", "borderColor", "", "borderColor"),
    Dl.route("scale.title", "color", "", "color"),
    Dl.describe("scale", {
        _fallback: !1,
        _scriptable: t => !t.startsWith("before") && !t.startsWith("after") && "callback" !== t && "parser" !== t,
        _indexable: t => "borderDash" !== t && "tickBorderDash" !== t
    }),
    Dl.describe("scales", {
        _fallback: "scale"
    }),
    Dl.describe("scale.ticks", {
        _scriptable: t => "backdropPadding" !== t && "callback" !== t,
        _indexable: t => "backdropPadding" !== t
    });
    const Pc = (t, e, i) => "top" === e || "left" === e ? t[e] + i : t[e] - i;
    function Rc(t, e) {
        const i = []
          , n = t.length / e
          , s = t.length;
        let o = 0;
        for (; o < s; o += n)
            i.push(t[Math.floor(o)]);
        return i
    }
    function Nc(t, e, i) {
        const n = t.ticks.length
          , s = Math.min(e, n - 1)
          , o = t._startPixel
          , a = t._endPixel
          , r = 1e-6;
        let l, h = t.getPixelForTick(s);
        if (!(i && (l = 1 === n ? Math.max(h - o, a - h) : 0 === e ? (t.getPixelForTick(1) - h) / 2 : (h - t.getPixelForTick(s - 1)) / 2,
        h += s < e ? l : -l,
        h < o - r || h > a + r)))
            return h
    }
    function Bc(t) {
        return t.drawTicks ? t.tickLength : 0
    }
    function Hc(t, e) {
        if (!t.display)
            return 0;
        const i = th(t.font, e)
          , n = Jl(t.padding);
        return (Na(t.text) ? t.text.length : 1) * i.lineHeight + n.height
    }
    function Fc(t, e, i) {
        let n = Rr(t);
        return (i && "right" !== e || !i && "right" === e) && (n = (t => "left" === t ? "right" : "right" === t ? "left" : t)(n)),
        n
    }
    class zc extends Oc {
        constructor(t) {
            super(),
            this.id = t.id,
            this.type = t.type,
            this.options = void 0,
            this.ctx = t.ctx,
            this.chart = t.chart,
            this.top = void 0,
            this.bottom = void 0,
            this.left = void 0,
            this.right = void 0,
            this.width = void 0,
            this.height = void 0,
            this._margins = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            },
            this.maxWidth = void 0,
            this.maxHeight = void 0,
            this.paddingTop = void 0,
            this.paddingBottom = void 0,
            this.paddingLeft = void 0,
            this.paddingRight = void 0,
            this.axis = void 0,
            this.labelRotation = void 0,
            this.min = void 0,
            this.max = void 0,
            this._range = void 0,
            this.ticks = [],
            this._gridLineItems = null,
            this._labelItems = null,
            this._labelSizes = null,
            this._length = 0,
            this._maxLength = 0,
            this._longestTextCache = {},
            this._startPixel = void 0,
            this._endPixel = void 0,
            this._reversePixels = !1,
            this._userMax = void 0,
            this._userMin = void 0,
            this._suggestedMax = void 0,
            this._suggestedMin = void 0,
            this._ticksLength = 0,
            this._borderValue = 0,
            this._cache = {},
            this._dataLimitsCached = !1,
            this.$context = void 0
        }
        init(t) {
            this.options = t.setContext(this.getContext()),
            this.axis = t.axis,
            this._userMin = this.parse(t.min),
            this._userMax = this.parse(t.max),
            this._suggestedMin = this.parse(t.suggestedMin),
            this._suggestedMax = this.parse(t.suggestedMax)
        }
        parse(t, e) {
            return t
        }
        getUserBounds() {
            let {_userMin: t, _userMax: e, _suggestedMin: i, _suggestedMax: n} = this;
            return t = Fa(t, Number.POSITIVE_INFINITY),
            e = Fa(e, Number.NEGATIVE_INFINITY),
            i = Fa(i, Number.POSITIVE_INFINITY),
            n = Fa(n, Number.NEGATIVE_INFINITY),
            {
                min: Fa(t, i),
                max: Fa(e, n),
                minDefined: Ha(t),
                maxDefined: Ha(e)
            }
        }
        getMinMax(t) {
            let e, {min: i, max: n, minDefined: s, maxDefined: o} = this.getUserBounds();
            if (s && o)
                return {
                    min: i,
                    max: n
                };
            const a = this.getMatchingVisibleMetas();
            for (let r = 0, l = a.length; r < l; ++r)
                e = a[r].controller.getMinMax(this, t),
                s || (i = Math.min(i, e.min)),
                o || (n = Math.max(n, e.max));
            return i = o && i > n ? n : i,
            n = s && i > n ? i : n,
            {
                min: Fa(i, Fa(n, i)),
                max: Fa(n, Fa(i, n))
            }
        }
        getPadding() {
            return {
                left: this.paddingLeft || 0,
                top: this.paddingTop || 0,
                right: this.paddingRight || 0,
                bottom: this.paddingBottom || 0
            }
        }
        getTicks() {
            return this.ticks
        }
        getLabels() {
            const t = this.chart.data;
            return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []
        }
        beforeLayout() {
            this._cache = {},
            this._dataLimitsCached = !1
        }
        beforeUpdate() {
            Wa(this.options.beforeUpdate, [this])
        }
        update(t, e, i) {
            const {beginAtZero: n, grace: s, ticks: o} = this.options
              , a = o.sampleSize;
            this.beforeUpdate(),
            this.maxWidth = t,
            this.maxHeight = e,
            this._margins = i = Object.assign({
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            }, i),
            this.ticks = null,
            this._labelSizes = null,
            this._gridLineItems = null,
            this._labelItems = null,
            this.beforeSetDimensions(),
            this.setDimensions(),
            this.afterSetDimensions(),
            this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom,
            this._dataLimitsCached || (this.beforeDataLimits(),
            this.determineDataLimits(),
            this.afterDataLimits(),
            this._range = function(t, e, i) {
                const {min: n, max: s} = t
                  , o = ja(e, (s - n) / 2)
                  , a = (t, e) => i && 0 === t ? 0 : t + e;
                return {
                    min: a(n, -Math.abs(o)),
                    max: a(s, o)
                }
            }(this, s, n),
            this._dataLimitsCached = !0),
            this.beforeBuildTicks(),
            this.ticks = this.buildTicks() || [],
            this.afterBuildTicks();
            const r = a < this.ticks.length;
            this._convertTicksToLabels(r ? Rc(this.ticks, a) : this.ticks),
            this.configure(),
            this.beforeCalculateLabelRotation(),
            this.calculateLabelRotation(),
            this.afterCalculateLabelRotation(),
            o.display && (o.autoSkip || "auto" === o.source) && (this.ticks = Ic(this, this.ticks),
            this._labelSizes = null,
            this.afterAutoSkip()),
            r && this._convertTicksToLabels(this.ticks),
            this.beforeFit(),
            this.fit(),
            this.afterFit(),
            this.afterUpdate()
        }
        configure() {
            let t, e, i = this.options.reverse;
            this.isHorizontal() ? (t = this.left,
            e = this.right) : (t = this.top,
            e = this.bottom,
            i = !i),
            this._startPixel = t,
            this._endPixel = e,
            this._reversePixels = i,
            this._length = e - t,
            this._alignToPixels = this.options.alignToPixels
        }
        afterUpdate() {
            Wa(this.options.afterUpdate, [this])
        }
        beforeSetDimensions() {
            Wa(this.options.beforeSetDimensions, [this])
        }
        setDimensions() {
            this.isHorizontal() ? (this.width = this.maxWidth,
            this.left = 0,
            this.right = this.width) : (this.height = this.maxHeight,
            this.top = 0,
            this.bottom = this.height),
            this.paddingLeft = 0,
            this.paddingTop = 0,
            this.paddingRight = 0,
            this.paddingBottom = 0
        }
        afterSetDimensions() {
            Wa(this.options.afterSetDimensions, [this])
        }
        _callHooks(t) {
            this.chart.notifyPlugins(t, this.getContext()),
            Wa(this.options[t], [this])
        }
        beforeDataLimits() {
            this._callHooks("beforeDataLimits")
        }
        determineDataLimits() {}
        afterDataLimits() {
            this._callHooks("afterDataLimits")
        }
        beforeBuildTicks() {
            this._callHooks("beforeBuildTicks")
        }
        buildTicks() {
            return []
        }
        afterBuildTicks() {
            this._callHooks("afterBuildTicks")
        }
        beforeTickToLabelConversion() {
            Wa(this.options.beforeTickToLabelConversion, [this])
        }
        generateTickLabels(t) {
            const e = this.options.ticks;
            let i, n, s;
            for (i = 0,
            n = t.length; i < n; i++)
                s = t[i],
                s.label = Wa(e.callback, [s.value, i, t], this)
        }
        afterTickToLabelConversion() {
            Wa(this.options.afterTickToLabelConversion, [this])
        }
        beforeCalculateLabelRotation() {
            Wa(this.options.beforeCalculateLabelRotation, [this])
        }
        calculateLabelRotation() {
            const t = this.options
              , e = t.ticks
              , i = this.ticks.length
              , n = e.minRotation || 0
              , s = e.maxRotation;
            let o, a, r, l = n;
            if (!this._isVisible() || !e.display || n >= s || i <= 1 || !this.isHorizontal())
                return void (this.labelRotation = n);
            const h = this._getLabelSizes()
              , c = h.widest.width
              , d = h.highest.height
              , u = Tr(this.chart.width - c, 0, this.maxWidth);
            o = t.offset ? this.maxWidth / i : u / (i - 1),
            c + 6 > o && (o = u / (i - (t.offset ? .5 : 1)),
            a = this.maxHeight - Bc(t.grid) - e.padding - Hc(t.title, this.chart.options.font),
            r = Math.sqrt(c * c + d * d),
            l = vr(Math.min(Math.asin(Tr((h.highest.height + 6) / o, -1, 1)), Math.asin(Tr(a / r, -1, 1)) - Math.asin(Tr(d / r, -1, 1)))),
            l = Math.max(n, Math.min(s, l))),
            this.labelRotation = l
        }
        afterCalculateLabelRotation() {
            Wa(this.options.afterCalculateLabelRotation, [this])
        }
        afterAutoSkip() {}
        beforeFit() {
            Wa(this.options.beforeFit, [this])
        }
        fit() {
            const t = {
                width: 0,
                height: 0
            }
              , {chart: e, options: {ticks: i, title: n, grid: s}} = this
              , o = this._isVisible()
              , a = this.isHorizontal();
            if (o) {
                const o = Hc(n, e.options.font);
                if (a ? (t.width = this.maxWidth,
                t.height = Bc(s) + o) : (t.height = this.maxHeight,
                t.width = Bc(s) + o),
                i.display && this.ticks.length) {
                    const {first: e, last: n, widest: s, highest: o} = this._getLabelSizes()
                      , r = 2 * i.padding
                      , l = br(this.labelRotation)
                      , h = Math.cos(l)
                      , c = Math.sin(l);
                    if (a) {
                        const e = i.mirror ? 0 : c * s.width + h * o.height;
                        t.height = Math.min(this.maxHeight, t.height + e + r)
                    } else {
                        const e = i.mirror ? 0 : h * s.width + c * o.height;
                        t.width = Math.min(this.maxWidth, t.width + e + r)
                    }
                    this._calculatePadding(e, n, c, h)
                }
            }
            this._handleMargins(),
            a ? (this.width = this._length = e.width - this._margins.left - this._margins.right,
            this.height = t.height) : (this.width = t.width,
            this.height = this._length = e.height - this._margins.top - this._margins.bottom)
        }
        _calculatePadding(t, e, i, n) {
            const {ticks: {align: s, padding: o}, position: a} = this.options
              , r = 0 !== this.labelRotation
              , l = "top" !== a && "x" === this.axis;
            if (this.isHorizontal()) {
                const a = this.getPixelForTick(0) - this.left
                  , h = this.right - this.getPixelForTick(this.ticks.length - 1);
                let c = 0
                  , d = 0;
                r ? l ? (c = n * t.width,
                d = i * e.height) : (c = i * t.height,
                d = n * e.width) : "start" === s ? d = e.width : "end" === s ? c = t.width : "inner" !== s && (c = t.width / 2,
                d = e.width / 2),
                this.paddingLeft = Math.max((c - a + o) * this.width / (this.width - a), 0),
                this.paddingRight = Math.max((d - h + o) * this.width / (this.width - h), 0)
            } else {
                let i = e.height / 2
                  , n = t.height / 2;
                "start" === s ? (i = 0,
                n = t.height) : "end" === s && (i = e.height,
                n = 0),
                this.paddingTop = i + o,
                this.paddingBottom = n + o
            }
        }
        _handleMargins() {
            this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left),
            this._margins.top = Math.max(this.paddingTop, this._margins.top),
            this._margins.right = Math.max(this.paddingRight, this._margins.right),
            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))
        }
        afterFit() {
            Wa(this.options.afterFit, [this])
        }
        isHorizontal() {
            const {axis: t, position: e} = this.options;
            return "top" === e || "bottom" === e || "x" === t
        }
        isFullSize() {
            return this.options.fullSize
        }
        _convertTicksToLabels(t) {
            let e, i;
            for (this.beforeTickToLabelConversion(),
            this.generateTickLabels(t),
            e = 0,
            i = t.length; e < i; e++)
                Ra(t[e].label) && (t.splice(e, 1),
                i--,
                e--);
            this.afterTickToLabelConversion()
        }
        _getLabelSizes() {
            let t = this._labelSizes;
            if (!t) {
                const e = this.options.ticks.sampleSize;
                let i = this.ticks;
                e < i.length && (i = Rc(i, e)),
                this._labelSizes = t = this._computeLabelSizes(i, i.length)
            }
            return t
        }
        _computeLabelSizes(t, e) {
            const {ctx: i, _longestTextCache: n} = this
              , s = []
              , o = [];
            let a, r, l, h, c, d, u, p, f, g, m, _ = 0, b = 0;
            for (a = 0; a < e; ++a) {
                if (h = t[a].label,
                c = this._resolveTickFontOptions(a),
                i.font = d = c.string,
                u = n[d] = n[d] || {
                    data: {},
                    gc: []
                },
                p = c.lineHeight,
                f = g = 0,
                Ra(h) || Na(h)) {
                    if (Na(h))
                        for (r = 0,
                        l = h.length; r < l; ++r)
                            m = h[r],
                            Ra(m) || Na(m) || (f = $l(i, u.data, u.gc, f, m),
                            g += p)
                } else
                    f = $l(i, u.data, u.gc, f, h),
                    g = p;
                s.push(f),
                o.push(g),
                _ = Math.max(f, _),
                b = Math.max(g, b)
            }
            !function(t, e) {
                Va(t, t => {
                    const i = t.gc
                      , n = i.length / 2;
                    let s;
                    if (n > e) {
                        for (s = 0; s < n; ++s)
                            delete t.data[i[s]];
                        i.splice(0, n)
                    }
                }
                )
            }(n, e);
            const v = s.indexOf(_)
              , y = o.indexOf(b)
              , x = t => ({
                width: s[t] || 0,
                height: o[t] || 0
            });
            return {
                first: x(0),
                last: x(e - 1),
                widest: x(v),
                highest: x(y),
                widths: s,
                heights: o
            }
        }
        getLabelForValue(t) {
            return t
        }
        getPixelForValue(t, e) {
            return NaN
        }
        getValueForPixel(t) {}
        getPixelForTick(t) {
            const e = this.ticks;
            return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
        }
        getPixelForDecimal(t) {
            this._reversePixels && (t = 1 - t);
            const e = this._startPixel + t * this._length;
            return Tr(this._alignToPixels ? Ll(this.chart, e, 0) : e, -32768, 32767)
        }
        getDecimalForPixel(t) {
            const e = (t - this._startPixel) / this._length;
            return this._reversePixels ? 1 - e : e
        }
        getBasePixel() {
            return this.getPixelForValue(this.getBaseValue())
        }
        getBaseValue() {
            const {min: t, max: e} = this;
            return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0
        }
        getContext(t) {
            const e = this.ticks || [];
            if (t >= 0 && t < e.length) {
                const i = e[t];
                return i.$context || (i.$context = function(t, e, i) {
                    return ih(t, {
                        tick: i,
                        index: e,
                        type: "tick"
                    })
                }(this.getContext(), t, i))
            }
            return this.$context || (this.$context = ih(this.chart.getContext(), {
                scale: this,
                type: "scale"
            }))
        }
        _tickSize() {
            const t = this.options.ticks
              , e = br(this.labelRotation)
              , i = Math.abs(Math.cos(e))
              , n = Math.abs(Math.sin(e))
              , s = this._getLabelSizes()
              , o = t.autoSkipPadding || 0
              , a = s ? s.widest.width + o : 0
              , r = s ? s.highest.height + o : 0;
            return this.isHorizontal() ? r * i > a * n ? a / i : r / n : r * n < a * i ? r / i : a / n
        }
        _isVisible() {
            const t = this.options.display;
            return "auto" !== t ? !!t : this.getMatchingVisibleMetas().length > 0
        }
        _computeGridLineItems(t) {
            const e = this.axis
              , i = this.chart
              , n = this.options
              , {grid: s, position: o} = n
              , a = s.offset
              , r = this.isHorizontal()
              , l = this.ticks.length + (a ? 1 : 0)
              , h = Bc(s)
              , c = []
              , d = s.setContext(this.getContext())
              , u = d.drawBorder ? d.borderWidth : 0
              , p = u / 2
              , f = function(t) {
                return Ll(i, t, u)
            };
            let g, m, _, b, v, y, x, w, C, k, S, T;
            if ("top" === o)
                g = f(this.bottom),
                y = this.bottom - h,
                w = g - p,
                k = f(t.top) + p,
                T = t.bottom;
            else if ("bottom" === o)
                g = f(this.top),
                k = t.top,
                T = f(t.bottom) - p,
                y = g + p,
                w = this.top + h;
            else if ("left" === o)
                g = f(this.right),
                v = this.right - h,
                x = g - p,
                C = f(t.left) + p,
                S = t.right;
            else if ("right" === o)
                g = f(this.left),
                C = t.left,
                S = f(t.right) - p,
                v = g + p,
                x = this.left + h;
            else if ("x" === e) {
                if ("center" === o)
                    g = f((t.top + t.bottom) / 2 + .5);
                else if (Ba(o)) {
                    const t = Object.keys(o)[0]
                      , e = o[t];
                    g = f(this.chart.scales[t].getPixelForValue(e))
                }
                k = t.top,
                T = t.bottom,
                y = g + p,
                w = y + h
            } else if ("y" === e) {
                if ("center" === o)
                    g = f((t.left + t.right) / 2);
                else if (Ba(o)) {
                    const t = Object.keys(o)[0]
                      , e = o[t];
                    g = f(this.chart.scales[t].getPixelForValue(e))
                }
                v = g - p,
                x = v - h,
                C = t.left,
                S = t.right
            }
            const A = za(n.ticks.maxTicksLimit, l)
              , E = Math.max(1, Math.ceil(l / A));
            for (m = 0; m < l; m += E) {
                const t = s.setContext(this.getContext(m))
                  , e = t.lineWidth
                  , n = t.color
                  , o = t.borderDash || []
                  , l = t.borderDashOffset
                  , h = t.tickWidth
                  , d = t.tickColor
                  , u = t.tickBorderDash || []
                  , p = t.tickBorderDashOffset;
                _ = Nc(this, m, a),
                void 0 !== _ && (b = Ll(i, _, e),
                r ? v = x = C = S = b : y = w = k = T = b,
                c.push({
                    tx1: v,
                    ty1: y,
                    tx2: x,
                    ty2: w,
                    x1: C,
                    y1: k,
                    x2: S,
                    y2: T,
                    width: e,
                    color: n,
                    borderDash: o,
                    borderDashOffset: l,
                    tickWidth: h,
                    tickColor: d,
                    tickBorderDash: u,
                    tickBorderDashOffset: p
                }))
            }
            return this._ticksLength = l,
            this._borderValue = g,
            c
        }
        _computeLabelItems(t) {
            const e = this.axis
              , i = this.options
              , {position: n, ticks: s} = i
              , o = this.isHorizontal()
              , a = this.ticks
              , {align: r, crossAlign: l, padding: h, mirror: c} = s
              , d = Bc(i.grid)
              , u = d + h
              , p = c ? -h : u
              , f = -br(this.labelRotation)
              , g = [];
            let m, _, b, v, y, x, w, C, k, S, T, A, E = "middle";
            if ("top" === n)
                x = this.bottom - p,
                w = this._getXAxisLabelAlignment();
            else if ("bottom" === n)
                x = this.top + p,
                w = this._getXAxisLabelAlignment();
            else if ("left" === n) {
                const t = this._getYAxisLabelAlignment(d);
                w = t.textAlign,
                y = t.x
            } else if ("right" === n) {
                const t = this._getYAxisLabelAlignment(d);
                w = t.textAlign,
                y = t.x
            } else if ("x" === e) {
                if ("center" === n)
                    x = (t.top + t.bottom) / 2 + u;
                else if (Ba(n)) {
                    const t = Object.keys(n)[0]
                      , e = n[t];
                    x = this.chart.scales[t].getPixelForValue(e) + u
                }
                w = this._getXAxisLabelAlignment()
            } else if ("y" === e) {
                if ("center" === n)
                    y = (t.left + t.right) / 2 - u;
                else if (Ba(n)) {
                    const t = Object.keys(n)[0]
                      , e = n[t];
                    y = this.chart.scales[t].getPixelForValue(e)
                }
                w = this._getYAxisLabelAlignment(d).textAlign
            }
            "y" === e && ("start" === r ? E = "top" : "end" === r && (E = "bottom"));
            const M = this._getLabelSizes();
            for (m = 0,
            _ = a.length; m < _; ++m) {
                b = a[m],
                v = b.label;
                const t = s.setContext(this.getContext(m));
                C = this.getPixelForTick(m) + s.labelOffset,
                k = this._resolveTickFontOptions(m),
                S = k.lineHeight,
                T = Na(v) ? v.length : 1;
                const e = T / 2
                  , i = t.color
                  , r = t.textStrokeColor
                  , h = t.textStrokeWidth;
                let d, u = w;
                if (o ? (y = C,
                "inner" === w && (u = m === _ - 1 ? this.options.reverse ? "left" : "right" : 0 === m ? this.options.reverse ? "right" : "left" : "center"),
                A = "top" === n ? "near" === l || 0 !== f ? -T * S + S / 2 : "center" === l ? -M.highest.height / 2 - e * S + S : -M.highest.height + S / 2 : "near" === l || 0 !== f ? S / 2 : "center" === l ? M.highest.height / 2 - e * S : M.highest.height - T * S,
                c && (A *= -1)) : (x = C,
                A = (1 - T) * S / 2),
                t.showLabelBackdrop) {
                    const e = Jl(t.backdropPadding)
                      , i = M.heights[m]
                      , n = M.widths[m];
                    let s = x + A - e.top
                      , o = y - e.left;
                    switch (E) {
                    case "middle":
                        s -= i / 2;
                        break;
                    case "bottom":
                        s -= i
                    }
                    switch (w) {
                    case "center":
                        o -= n / 2;
                        break;
                    case "right":
                        o -= n
                    }
                    d = {
                        left: o,
                        top: s,
                        width: n + e.width,
                        height: i + e.height,
                        color: t.backdropColor
                    }
                }
                g.push({
                    rotation: f,
                    label: v,
                    font: k,
                    color: i,
                    strokeColor: r,
                    strokeWidth: h,
                    textOffset: A,
                    textAlign: u,
                    textBaseline: E,
                    translation: [y, x],
                    backdrop: d
                })
            }
            return g
        }
        _getXAxisLabelAlignment() {
            const {position: t, ticks: e} = this.options;
            if (-br(this.labelRotation))
                return "top" === t ? "left" : "right";
            let i = "center";
            return "start" === e.align ? i = "left" : "end" === e.align ? i = "right" : "inner" === e.align && (i = "inner"),
            i
        }
        _getYAxisLabelAlignment(t) {
            const {position: e, ticks: {crossAlign: i, mirror: n, padding: s}} = this.options
              , o = t + s
              , a = this._getLabelSizes().widest.width;
            let r, l;
            return "left" === e ? n ? (l = this.right + s,
            "near" === i ? r = "left" : "center" === i ? (r = "center",
            l += a / 2) : (r = "right",
            l += a)) : (l = this.right - o,
            "near" === i ? r = "right" : "center" === i ? (r = "center",
            l -= a / 2) : (r = "left",
            l = this.left)) : "right" === e ? n ? (l = this.left + s,
            "near" === i ? r = "right" : "center" === i ? (r = "center",
            l -= a / 2) : (r = "left",
            l -= a)) : (l = this.left + o,
            "near" === i ? r = "left" : "center" === i ? (r = "center",
            l += a / 2) : (r = "right",
            l = this.right)) : r = "right",
            {
                textAlign: r,
                x: l
            }
        }
        _computeLabelArea() {
            if (this.options.ticks.mirror)
                return;
            const t = this.chart
              , e = this.options.position;
            return "left" === e || "right" === e ? {
                top: 0,
                left: this.left,
                bottom: t.height,
                right: this.right
            } : "top" === e || "bottom" === e ? {
                top: this.top,
                left: 0,
                bottom: this.bottom,
                right: t.width
            } : void 0
        }
        drawBackground() {
            const {ctx: t, options: {backgroundColor: e}, left: i, top: n, width: s, height: o} = this;
            e && (t.save(),
            t.fillStyle = e,
            t.fillRect(i, n, s, o),
            t.restore())
        }
        getLineWidthForValue(t) {
            const e = this.options.grid;
            if (!this._isVisible() || !e.display)
                return 0;
            const i = this.ticks.findIndex(e => e.value === t);
            if (i >= 0) {
                return e.setContext(this.getContext(i)).lineWidth
            }
            return 0
        }
        drawGrid(t) {
            const e = this.options.grid
              , i = this.ctx
              , n = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
            let s, o;
            const a = (t, e, n) => {
                n.width && n.color && (i.save(),
                i.lineWidth = n.width,
                i.strokeStyle = n.color,
                i.setLineDash(n.borderDash || []),
                i.lineDashOffset = n.borderDashOffset,
                i.beginPath(),
                i.moveTo(t.x, t.y),
                i.lineTo(e.x, e.y),
                i.stroke(),
                i.restore())
            }
            ;
            if (e.display)
                for (s = 0,
                o = n.length; s < o; ++s) {
                    const t = n[s];
                    e.drawOnChartArea && a({
                        x: t.x1,
                        y: t.y1
                    }, {
                        x: t.x2,
                        y: t.y2
                    }, t),
                    e.drawTicks && a({
                        x: t.tx1,
                        y: t.ty1
                    }, {
                        x: t.tx2,
                        y: t.ty2
                    }, {
                        color: t.tickColor,
                        width: t.tickWidth,
                        borderDash: t.tickBorderDash,
                        borderDashOffset: t.tickBorderDashOffset
                    })
                }
        }
        drawBorder() {
            const {chart: t, ctx: e, options: {grid: i}} = this
              , n = i.setContext(this.getContext())
              , s = i.drawBorder ? n.borderWidth : 0;
            if (!s)
                return;
            const o = i.setContext(this.getContext(0)).lineWidth
              , a = this._borderValue;
            let r, l, h, c;
            this.isHorizontal() ? (r = Ll(t, this.left, s) - s / 2,
            l = Ll(t, this.right, o) + o / 2,
            h = c = a) : (h = Ll(t, this.top, s) - s / 2,
            c = Ll(t, this.bottom, o) + o / 2,
            r = l = a),
            e.save(),
            e.lineWidth = n.borderWidth,
            e.strokeStyle = n.borderColor,
            e.beginPath(),
            e.moveTo(r, h),
            e.lineTo(l, c),
            e.stroke(),
            e.restore()
        }
        drawLabels(t) {
            if (!this.options.ticks.display)
                return;
            const e = this.ctx
              , i = this._computeLabelArea();
            i && Hl(e, i);
            const n = this._labelItems || (this._labelItems = this._computeLabelItems(t));
            let s, o;
            for (s = 0,
            o = n.length; s < o; ++s) {
                const t = n[s]
                  , i = t.font
                  , o = t.label;
                t.backdrop && (e.fillStyle = t.backdrop.color,
                e.fillRect(t.backdrop.left, t.backdrop.top, t.backdrop.width, t.backdrop.height)),
                Wl(e, o, 0, t.textOffset, i, t)
            }
            i && Fl(e)
        }
        drawTitle() {
            const {ctx: t, options: {position: e, title: i, reverse: n}} = this;
            if (!i.display)
                return;
            const s = th(i.font)
              , o = Jl(i.padding)
              , a = i.align;
            let r = s.lineHeight / 2;
            "bottom" === e || "center" === e || Ba(e) ? (r += o.bottom,
            Na(i.text) && (r += s.lineHeight * (i.text.length - 1))) : r += o.top;
            const {titleX: l, titleY: h, maxWidth: c, rotation: d} = function(t, e, i, n) {
                const {top: s, left: o, bottom: a, right: r, chart: l} = t
                  , {chartArea: h, scales: c} = l;
                let d, u, p, f = 0;
                const g = a - s
                  , m = r - o;
                if (t.isHorizontal()) {
                    if (u = Nr(n, o, r),
                    Ba(i)) {
                        const t = Object.keys(i)[0]
                          , n = i[t];
                        p = c[t].getPixelForValue(n) + g - e
                    } else
                        p = "center" === i ? (h.bottom + h.top) / 2 + g - e : Pc(t, i, e);
                    d = r - o
                } else {
                    if (Ba(i)) {
                        const t = Object.keys(i)[0]
                          , n = i[t];
                        u = c[t].getPixelForValue(n) - m + e
                    } else
                        u = "center" === i ? (h.left + h.right) / 2 - m + e : Pc(t, i, e);
                    p = Nr(n, a, s),
                    f = "left" === i ? -hr : hr
                }
                return {
                    titleX: u,
                    titleY: p,
                    maxWidth: d,
                    rotation: f
                }
            }(this, r, e, a);
            Wl(t, i.text, 0, 0, s, {
                color: i.color,
                maxWidth: c,
                rotation: d,
                textAlign: Fc(a, e, n),
                textBaseline: "middle",
                translation: [l, h]
            })
        }
        draw(t) {
            this._isVisible() && (this.drawBackground(),
            this.drawGrid(t),
            this.drawBorder(),
            this.drawTitle(),
            this.drawLabels(t))
        }
        _layers() {
            const t = this.options
              , e = t.ticks && t.ticks.z || 0
              , i = za(t.grid && t.grid.z, -1);
            return this._isVisible() && this.draw === zc.prototype.draw ? [{
                z: i,
                draw: t => {
                    this.drawBackground(),
                    this.drawGrid(t),
                    this.drawTitle()
                }
            }, {
                z: i + 1,
                draw: () => {
                    this.drawBorder()
                }
            }, {
                z: e,
                draw: t => {
                    this.drawLabels(t)
                }
            }] : [{
                z: e,
                draw: t => {
                    this.draw(t)
                }
            }]
        }
        getMatchingVisibleMetas(t) {
            const e = this.chart.getSortedVisibleDatasetMetas()
              , i = this.axis + "AxisID"
              , n = [];
            let s, o;
            for (s = 0,
            o = e.length; s < o; ++s) {
                const o = e[s];
                o[i] !== this.id || t && o.type !== t || n.push(o)
            }
            return n
        }
        _resolveTickFontOptions(t) {
            return th(this.options.ticks.setContext(this.getContext(t)).font)
        }
        _maxDigits() {
            const t = this._resolveTickFontOptions(0).lineHeight;
            return (this.isHorizontal() ? this.width : this.height) / t
        }
    }
    class jc {
        constructor(t, e, i) {
            this.type = t,
            this.scope = e,
            this.override = i,
            this.items = Object.create(null)
        }
        isForType(t) {
            return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype)
        }
        register(t) {
            const e = Object.getPrototypeOf(t);
            let i;
            (function(t) {
                return "id"in t && "defaults"in t
            }
            )(e) && (i = this.register(e));
            const n = this.items
              , s = t.id
              , o = this.scope + "." + s;
            if (!s)
                throw new Error("class does not have id: " + t);
            return s in n || (n[s] = t,
            function(t, e, i) {
                const n = qa(Object.create(null), [i ? Dl.get(i) : {}, Dl.get(e), t.defaults]);
                Dl.set(e, n),
                t.defaultRoutes && function(t, e) {
                    Object.keys(e).forEach(i => {
                        const n = i.split(".")
                          , s = n.pop()
                          , o = [t].concat(n).join(".")
                          , a = e[i].split(".")
                          , r = a.pop()
                          , l = a.join(".");
                        Dl.route(o, s, l, r)
                    }
                    )
                }(e, t.defaultRoutes);
                t.descriptors && Dl.describe(e, t.descriptors)
            }(t, o, i),
            this.override && Dl.override(t.id, t.overrides)),
            o
        }
        get(t) {
            return this.items[t]
        }
        unregister(t) {
            const e = this.items
              , i = t.id
              , n = this.scope;
            i in e && delete e[i],
            n && i in Dl[n] && (delete Dl[n][i],
            this.override && delete Al[i])
        }
    }
    var Wc = new class {
        constructor() {
            this.controllers = new jc(fc,"datasets",!0),
            this.elements = new jc(Oc,"elements"),
            this.plugins = new jc(Object,"plugins"),
            this.scales = new jc(zc,"scales"),
            this._typedRegistries = [this.controllers, this.scales, this.elements]
        }
        add(...t) {
            this._each("register", t)
        }
        remove(...t) {
            this._each("unregister", t)
        }
        addControllers(...t) {
            this._each("register", t, this.controllers)
        }
        addElements(...t) {
            this._each("register", t, this.elements)
        }
        addPlugins(...t) {
            this._each("register", t, this.plugins)
        }
        addScales(...t) {
            this._each("register", t, this.scales)
        }
        getController(t) {
            return this._get(t, this.controllers, "controller")
        }
        getElement(t) {
            return this._get(t, this.elements, "element")
        }
        getPlugin(t) {
            return this._get(t, this.plugins, "plugin")
        }
        getScale(t) {
            return this._get(t, this.scales, "scale")
        }
        removeControllers(...t) {
            this._each("unregister", t, this.controllers)
        }
        removeElements(...t) {
            this._each("unregister", t, this.elements)
        }
        removePlugins(...t) {
            this._each("unregister", t, this.plugins)
        }
        removeScales(...t) {
            this._each("unregister", t, this.scales)
        }
        _each(t, e, i) {
            [...e].forEach(e => {
                const n = i || this._getRegistryForType(e);
                i || n.isForType(e) || n === this.plugins && e.id ? this._exec(t, n, e) : Va(e, e => {
                    const n = i || this._getRegistryForType(e);
                    this._exec(t, n, e)
                }
                )
            }
            )
        }
        _exec(t, e, i) {
            const n = tr(t);
            Wa(i["before" + n], [], i),
            e[t](i),
            Wa(i["after" + n], [], i)
        }
        _getRegistryForType(t) {
            for (let e = 0; e < this._typedRegistries.length; e++) {
                const i = this._typedRegistries[e];
                if (i.isForType(t))
                    return i
            }
            return this.plugins
        }
        _get(t, e, i) {
            const n = e.get(t);
            if (void 0 === n)
                throw new Error('"' + t + '" is not a registered ' + i + ".");
            return n
        }
    }
    ;
    class Vc extends fc {
        update(t) {
            const e = this._cachedMeta
              , {data: i=[]} = e
              , n = this.chart._animationsDisabled;
            let {start: s, count: o} = Br(e, i, n);
            if (this._drawStart = s,
            this._drawCount = o,
            Hr(e) && (s = 0,
            o = i.length),
            this.options.showLine) {
                const {dataset: s, _dataset: o} = e;
                s._chart = this.chart,
                s._datasetIndex = this.index,
                s._decimated = !!o._decimated,
                s.points = i;
                const a = this.resolveDatasetElementOptions(t);
                a.segment = this.options.segment,
                this.updateElement(s, void 0, {
                    animated: !n,
                    options: a
                }, t)
            }
            this.updateElements(i, s, o, t)
        }
        addElements() {
            const {showLine: t} = this.options;
            !this.datasetElementType && t && (this.datasetElementType = Wc.getElement("line")),
            super.addElements()
        }
        updateElements(t, e, i, n) {
            const s = "reset" === n
              , {iScale: o, vScale: a, _stacked: r, _dataset: l} = this._cachedMeta
              , h = this.resolveDataElementOptions(e, n)
              , c = this.getSharedOptions(h)
              , d = this.includeOptions(n, c)
              , u = o.axis
              , p = a.axis
              , {spanGaps: f, segment: g} = this.options
              , m = gr(f) ? f : Number.POSITIVE_INFINITY
              , _ = this.chart._animationsDisabled || s || "none" === n;
            let b = e > 0 && this.getParsed(e - 1);
            for (let v = e; v < e + i; ++v) {
                const e = t[v]
                  , i = this.getParsed(v)
                  , h = _ ? e : {}
                  , f = Ra(i[p])
                  , y = h[u] = o.getPixelForValue(i[u], v)
                  , x = h[p] = s || f ? a.getBasePixel() : a.getPixelForValue(r ? this.applyStack(a, i, r) : i[p], v);
                h.skip = isNaN(y) || isNaN(x) || f,
                h.stop = v > 0 && Math.abs(i[u] - b[u]) > m,
                g && (h.parsed = i,
                h.raw = l.data[v]),
                d && (h.options = c || this.resolveDataElementOptions(v, e.active ? "active" : n)),
                _ || this.updateElement(e, v, h, n),
                b = i
            }
            this.updateSharedOptions(c, n, h)
        }
        getMaxOverflow() {
            const t = this._cachedMeta
              , e = t.data || [];
            if (!this.options.showLine) {
                let t = 0;
                for (let i = e.length - 1; i >= 0; --i)
                    t = Math.max(t, e[i].size(this.resolveDataElementOptions(i)) / 2);
                return t > 0 && t
            }
            const i = t.dataset
              , n = i.options && i.options.borderWidth || 0;
            if (!e.length)
                return n;
            const s = e[0].size(this.resolveDataElementOptions(0))
              , o = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));
            return Math.max(n, s, o) / 2
        }
    }
    function Yc() {
        throw new Error("This method is not implemented: Check that a complete date adapter is provided.")
    }
    Vc.id = "scatter",
    Vc.defaults = {
        datasetElementType: !1,
        dataElementType: "point",
        showLine: !1,
        fill: !1
    },
    Vc.overrides = {
        interaction: {
            mode: "point"
        },
        plugins: {
            tooltip: {
                callbacks: {
                    title: () => "",
                    label: t => "(" + t.label + ", " + t.formattedValue + ")"
                }
            }
        },
        scales: {
            x: {
                type: "linear"
            },
            y: {
                type: "linear"
            }
        }
    };
    class Xc {
        constructor(t) {
            this.options = t || {}
        }
        init(t) {}
        formats() {
            return Yc()
        }
        parse(t, e) {
            return Yc()
        }
        format(t, e) {
            return Yc()
        }
        add(t, e, i) {
            return Yc()
        }
        diff(t, e, i) {
            return Yc()
        }
        startOf(t, e, i) {
            return Yc()
        }
        endOf(t, e) {
            return Yc()
        }
    }
    Xc.override = function(t) {
        Object.assign(Xc.prototype, t)
    }
    ;
    var Kc = {
        _date: Xc
    };
    function Uc(t, e, i, n) {
        const {controller: s, data: o, _sorted: a} = t
          , r = s._cachedMeta.iScale;
        if (r && e === r.axis && "r" !== e && a && o.length) {
            const t = r._reversePixels ? Or : Mr;
            if (!n)
                return t(o, e, i);
            if (s._sharedOptions) {
                const n = o[0]
                  , s = "function" == typeof n.getRange && n.getRange(e);
                if (s) {
                    const n = t(o, e, i - s)
                      , a = t(o, e, i + s);
                    return {
                        lo: n.lo,
                        hi: a.hi
                    }
                }
            }
        }
        return {
            lo: 0,
            hi: o.length - 1
        }
    }
    function qc(t, e, i, n, s) {
        const o = t.getSortedVisibleDatasetMetas()
          , a = i[e];
        for (let r = 0, l = o.length; r < l; ++r) {
            const {index: t, data: i} = o[r]
              , {lo: l, hi: h} = Uc(o[r], e, a, s);
            for (let e = l; e <= h; ++e) {
                const s = i[e];
                s.skip || n(s, t, e)
            }
        }
    }
    function Zc(t, e, i, n, s) {
        const o = [];
        if (!s && !t.isPointInArea(e))
            return o;
        return qc(t, i, e, function(i, a, r) {
            (s || Bl(i, t.chartArea, 0)) && i.inRange(e.x, e.y, n) && o.push({
                element: i,
                datasetIndex: a,
                index: r
            })
        }, !0),
        o
    }
    function Gc(t, e, i, n, s, o) {
        let a = [];
        const r = function(t) {
            const e = -1 !== t.indexOf("x")
              , i = -1 !== t.indexOf("y");
            return function(t, n) {
                const s = e ? Math.abs(t.x - n.x) : 0
                  , o = i ? Math.abs(t.y - n.y) : 0;
                return Math.sqrt(Math.pow(s, 2) + Math.pow(o, 2))
            }
        }(i);
        let l = Number.POSITIVE_INFINITY;
        return qc(t, i, e, function(i, h, c) {
            const d = i.inRange(e.x, e.y, s);
            if (n && !d)
                return;
            const u = i.getCenterPoint(s);
            if (!(!!o || t.isPointInArea(u)) && !d)
                return;
            const p = r(e, u);
            p < l ? (a = [{
                element: i,
                datasetIndex: h,
                index: c
            }],
            l = p) : p === l && a.push({
                element: i,
                datasetIndex: h,
                index: c
            })
        }),
        a
    }
    function Qc(t, e, i, n, s, o) {
        return o || t.isPointInArea(e) ? "r" !== i || n ? Gc(t, e, i, n, s, o) : function(t, e, i, n) {
            let s = [];
            return qc(t, i, e, function(t, i, o) {
                const {startAngle: a, endAngle: r} = t.getProps(["startAngle", "endAngle"], n)
                  , {angle: l} = xr(t, {
                    x: e.x,
                    y: e.y
                });
                Sr(l, a, r) && s.push({
                    element: t,
                    datasetIndex: i,
                    index: o
                })
            }),
            s
        }(t, e, i, s) : []
    }
    function Jc(t, e, i, n, s) {
        const o = []
          , a = "x" === i ? "inXRange" : "inYRange";
        let r = !1;
        return qc(t, i, e, (t, n, l) => {
            t[a](e[i], s) && (o.push({
                element: t,
                datasetIndex: n,
                index: l
            }),
            r = r || t.inRange(e.x, e.y, s))
        }
        ),
        n && !r ? [] : o
    }
    var td = {
        evaluateInteractionItems: qc,
        modes: {
            index(t, e, i, n) {
                const s = Oh(e, t)
                  , o = i.axis || "x"
                  , a = i.includeInvisible || !1
                  , r = i.intersect ? Zc(t, s, o, n, a) : Qc(t, s, o, !1, n, a)
                  , l = [];
                return r.length ? (t.getSortedVisibleDatasetMetas().forEach(t => {
                    const e = r[0].index
                      , i = t.data[e];
                    i && !i.skip && l.push({
                        element: i,
                        datasetIndex: t.index,
                        index: e
                    })
                }
                ),
                l) : []
            },
            dataset(t, e, i, n) {
                const s = Oh(e, t)
                  , o = i.axis || "xy"
                  , a = i.includeInvisible || !1;
                let r = i.intersect ? Zc(t, s, o, n, a) : Qc(t, s, o, !1, n, a);
                if (r.length > 0) {
                    const e = r[0].datasetIndex
                      , i = t.getDatasetMeta(e).data;
                    r = [];
                    for (let t = 0; t < i.length; ++t)
                        r.push({
                            element: i[t],
                            datasetIndex: e,
                            index: t
                        })
                }
                return r
            },
            point: (t, e, i, n) => Zc(t, Oh(e, t), i.axis || "xy", n, i.includeInvisible || !1),
            nearest(t, e, i, n) {
                const s = Oh(e, t)
                  , o = i.axis || "xy"
                  , a = i.includeInvisible || !1;
                return Qc(t, s, o, i.intersect, n, a)
            },
            x: (t, e, i, n) => Jc(t, Oh(e, t), "x", i.intersect, n),
            y: (t, e, i, n) => Jc(t, Oh(e, t), "y", i.intersect, n)
        }
    };
    const ed = ["left", "top", "right", "bottom"];
    function id(t, e) {
        return t.filter(t => t.pos === e)
    }
    function nd(t, e) {
        return t.filter(t => -1 === ed.indexOf(t.pos) && t.box.axis === e)
    }
    function sd(t, e) {
        return t.sort( (t, i) => {
            const n = e ? i : t
              , s = e ? t : i;
            return n.weight === s.weight ? n.index - s.index : n.weight - s.weight
        }
        )
    }
    function od(t, e) {
        const i = function(t) {
            const e = {};
            for (const i of t) {
                const {stack: t, pos: n, stackWeight: s} = i;
                if (!t || !ed.includes(n))
                    continue;
                const o = e[t] || (e[t] = {
                    count: 0,
                    placed: 0,
                    weight: 0,
                    size: 0
                });
                o.count++,
                o.weight += s
            }
            return e
        }(t)
          , {vBoxMaxWidth: n, hBoxMaxHeight: s} = e;
        let o, a, r;
        for (o = 0,
        a = t.length; o < a; ++o) {
            r = t[o];
            const {fullSize: a} = r.box
              , l = i[r.stack]
              , h = l && r.stackWeight / l.weight;
            r.horizontal ? (r.width = h ? h * n : a && e.availableWidth,
            r.height = s) : (r.width = n,
            r.height = h ? h * s : a && e.availableHeight)
        }
        return i
    }
    function ad(t, e, i, n) {
        return Math.max(t[i], e[i]) + Math.max(t[n], e[n])
    }
    function rd(t, e) {
        t.top = Math.max(t.top, e.top),
        t.left = Math.max(t.left, e.left),
        t.bottom = Math.max(t.bottom, e.bottom),
        t.right = Math.max(t.right, e.right)
    }
    function ld(t, e, i, n) {
        const {pos: s, box: o} = i
          , a = t.maxPadding;
        if (!Ba(s)) {
            i.size && (t[s] -= i.size);
            const e = n[i.stack] || {
                size: 0,
                count: 1
            };
            e.size = Math.max(e.size, i.horizontal ? o.height : o.width),
            i.size = e.size / e.count,
            t[s] += i.size
        }
        o.getPadding && rd(a, o.getPadding());
        const r = Math.max(0, e.outerWidth - ad(a, t, "left", "right"))
          , l = Math.max(0, e.outerHeight - ad(a, t, "top", "bottom"))
          , h = r !== t.w
          , c = l !== t.h;
        return t.w = r,
        t.h = l,
        i.horizontal ? {
            same: h,
            other: c
        } : {
            same: c,
            other: h
        }
    }
    function hd(t, e) {
        const i = e.maxPadding;
        function n(t) {
            const n = {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            };
            return t.forEach(t => {
                n[t] = Math.max(e[t], i[t])
            }
            ),
            n
        }
        return n(t ? ["left", "right"] : ["top", "bottom"])
    }
    function cd(t, e, i, n) {
        const s = [];
        let o, a, r, l, h, c;
        for (o = 0,
        a = t.length,
        h = 0; o < a; ++o) {
            r = t[o],
            l = r.box,
            l.update(r.width || e.w, r.height || e.h, hd(r.horizontal, e));
            const {same: a, other: d} = ld(e, i, r, n);
            h |= a && s.length,
            c = c || d,
            l.fullSize || s.push(r)
        }
        return h && cd(s, e, i, n) || c
    }
    function dd(t, e, i, n, s) {
        t.top = i,
        t.left = e,
        t.right = e + n,
        t.bottom = i + s,
        t.width = n,
        t.height = s
    }
    function ud(t, e, i, n) {
        const s = i.padding;
        let {x: o, y: a} = e;
        for (const r of t) {
            const t = r.box
              , l = n[r.stack] || {
                count: 1,
                placed: 0,
                weight: 1
            }
              , h = r.stackWeight / l.weight || 1;
            if (r.horizontal) {
                const n = e.w * h
                  , o = l.size || t.height;
                er(l.start) && (a = l.start),
                t.fullSize ? dd(t, s.left, a, i.outerWidth - s.right - s.left, o) : dd(t, e.left + l.placed, a, n, o),
                l.start = a,
                l.placed += n,
                a = t.bottom
            } else {
                const n = e.h * h
                  , a = l.size || t.width;
                er(l.start) && (o = l.start),
                t.fullSize ? dd(t, o, s.top, a, i.outerHeight - s.bottom - s.top) : dd(t, o, e.top + l.placed, a, n),
                l.start = o,
                l.placed += n,
                o = t.right
            }
        }
        e.x = o,
        e.y = a
    }
    Dl.set("layout", {
        autoPadding: !0,
        padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }
    });
    var pd = {
        addBox(t, e) {
            t.boxes || (t.boxes = []),
            e.fullSize = e.fullSize || !1,
            e.position = e.position || "top",
            e.weight = e.weight || 0,
            e._layers = e._layers || function() {
                return [{
                    z: 0,
                    draw(t) {
                        e.draw(t)
                    }
                }]
            }
            ,
            t.boxes.push(e)
        },
        removeBox(t, e) {
            const i = t.boxes ? t.boxes.indexOf(e) : -1;
            -1 !== i && t.boxes.splice(i, 1)
        },
        configure(t, e, i) {
            e.fullSize = i.fullSize,
            e.position = i.position,
            e.weight = i.weight
        },
        update(t, e, i, n) {
            if (!t)
                return;
            const s = Jl(t.options.layout.padding)
              , o = Math.max(e - s.width, 0)
              , a = Math.max(i - s.height, 0)
              , r = function(t) {
                const e = function(t) {
                    const e = [];
                    let i, n, s, o, a, r;
                    for (i = 0,
                    n = (t || []).length; i < n; ++i)
                        s = t[i],
                        ({position: o, options: {stack: a, stackWeight: r=1}} = s),
                        e.push({
                            index: i,
                            box: s,
                            pos: o,
                            horizontal: s.isHorizontal(),
                            weight: s.weight,
                            stack: a && o + a,
                            stackWeight: r
                        });
                    return e
                }(t)
                  , i = sd(e.filter(t => t.box.fullSize), !0)
                  , n = sd(id(e, "left"), !0)
                  , s = sd(id(e, "right"))
                  , o = sd(id(e, "top"), !0)
                  , a = sd(id(e, "bottom"))
                  , r = nd(e, "x")
                  , l = nd(e, "y");
                return {
                    fullSize: i,
                    leftAndTop: n.concat(o),
                    rightAndBottom: s.concat(l).concat(a).concat(r),
                    chartArea: id(e, "chartArea"),
                    vertical: n.concat(s).concat(l),
                    horizontal: o.concat(a).concat(r)
                }
            }(t.boxes)
              , l = r.vertical
              , h = r.horizontal;
            Va(t.boxes, t => {
                "function" == typeof t.beforeLayout && t.beforeLayout()
            }
            );
            const c = l.reduce( (t, e) => e.box.options && !1 === e.box.options.display ? t : t + 1, 0) || 1
              , d = Object.freeze({
                outerWidth: e,
                outerHeight: i,
                padding: s,
                availableWidth: o,
                availableHeight: a,
                vBoxMaxWidth: o / 2 / c,
                hBoxMaxHeight: a / 2
            })
              , u = Object.assign({}, s);
            rd(u, Jl(n));
            const p = Object.assign({
                maxPadding: u,
                w: o,
                h: a,
                x: s.left,
                y: s.top
            }, s)
              , f = od(l.concat(h), d);
            cd(r.fullSize, p, d, f),
            cd(l, p, d, f),
            cd(h, p, d, f) && cd(l, p, d, f),
            function(t) {
                const e = t.maxPadding;
                function i(i) {
                    const n = Math.max(e[i] - t[i], 0);
                    return t[i] += n,
                    n
                }
                t.y += i("top"),
                t.x += i("left"),
                i("right"),
                i("bottom")
            }(p),
            ud(r.leftAndTop, p, d, f),
            p.x += p.w,
            p.y += p.h,
            ud(r.rightAndBottom, p, d, f),
            t.chartArea = {
                left: p.left,
                top: p.top,
                right: p.left + p.w,
                bottom: p.top + p.h,
                height: p.h,
                width: p.w
            },
            Va(r.chartArea, e => {
                const i = e.box;
                Object.assign(i, t.chartArea),
                i.update(p.w, p.h, {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0
                })
            }
            )
        }
    };
    class fd {
        acquireContext(t, e) {}
        releaseContext(t) {
            return !1
        }
        addEventListener(t, e, i) {}
        removeEventListener(t, e, i) {}
        getDevicePixelRatio() {
            return 1
        }
        getMaximumSize(t, e, i, n) {
            return e = Math.max(0, e || t.width),
            i = i || t.height,
            {
                width: e,
                height: Math.max(0, n ? Math.floor(e / n) : i)
            }
        }
        isAttached(t) {
            return !0
        }
        updateConfig(t) {}
    }
    class gd extends fd {
        acquireContext(t) {
            return t && t.getContext && t.getContext("2d") || null
        }
        updateConfig(t) {
            t.options.animation = !1
        }
    }
    const md = "$chartjs"
      , _d = {
        touchstart: "mousedown",
        touchmove: "mousemove",
        touchend: "mouseup",
        pointerenter: "mouseenter",
        pointerdown: "mousedown",
        pointermove: "mousemove",
        pointerup: "mouseup",
        pointerleave: "mouseout",
        pointerout: "mouseout"
    }
      , bd = t => null === t || "" === t;
    const vd = !!Lh && {
        passive: !0
    };
    function yd(t, e, i) {
        t.canvas.removeEventListener(e, i, vd)
    }
    function xd(t, e) {
        for (const i of t)
            if (i === e || i.contains(e))
                return !0
    }
    function wd(t, e, i) {
        const n = t.canvas
          , s = new MutationObserver(t => {
            let e = !1;
            for (const i of t)
                e = e || xd(i.addedNodes, n),
                e = e && !xd(i.removedNodes, n);
            e && i()
        }
        );
        return s.observe(document, {
            childList: !0,
            subtree: !0
        }),
        s
    }
    function Cd(t, e, i) {
        const n = t.canvas
          , s = new MutationObserver(t => {
            let e = !1;
            for (const i of t)
                e = e || xd(i.removedNodes, n),
                e = e && !xd(i.addedNodes, n);
            e && i()
        }
        );
        return s.observe(document, {
            childList: !0,
            subtree: !0
        }),
        s
    }
    const kd = new Map;
    let Sd = 0;
    function Td() {
        const t = window.devicePixelRatio;
        t !== Sd && (Sd = t,
        kd.forEach( (e, i) => {
            i.currentDevicePixelRatio !== t && e()
        }
        ))
    }
    function Ad(t, e, i) {
        const n = t.canvas
          , s = n && Sh(n);
        if (!s)
            return;
        const o = Pr( (t, e) => {
            const n = s.clientWidth;
            i(t, e),
            n < s.clientWidth && i()
        }
        , window)
          , a = new ResizeObserver(t => {
            const e = t[0]
              , i = e.contentRect.width
              , n = e.contentRect.height;
            0 === i && 0 === n || o(i, n)
        }
        );
        return a.observe(s),
        function(t, e) {
            kd.size || window.addEventListener("resize", Td),
            kd.set(t, e)
        }(t, o),
        a
    }
    function Ed(t, e, i) {
        i && i.disconnect(),
        "resize" === e && function(t) {
            kd.delete(t),
            kd.size || window.removeEventListener("resize", Td)
        }(t)
    }
    function Md(t, e, i) {
        const n = t.canvas
          , s = Pr(e => {
            null !== t.ctx && i(function(t, e) {
                const i = _d[t.type] || t.type
                  , {x: n, y: s} = Oh(t, e);
                return {
                    type: i,
                    chart: e,
                    native: t,
                    x: void 0 !== n ? n : null,
                    y: void 0 !== s ? s : null
                }
            }(e, t))
        }
        , t, t => {
            const e = t[0];
            return [e, e.offsetX, e.offsetY]
        }
        );
        return function(t, e, i) {
            t.addEventListener(e, i, vd)
        }(n, e, s),
        s
    }
    class Od extends fd {
        acquireContext(t, e) {
            const i = t && t.getContext && t.getContext("2d");
            return i && i.canvas === t ? (function(t, e) {
                const i = t.style
                  , n = t.getAttribute("height")
                  , s = t.getAttribute("width");
                if (t[md] = {
                    initial: {
                        height: n,
                        width: s,
                        style: {
                            display: i.display,
                            height: i.height,
                            width: i.width
                        }
                    }
                },
                i.display = i.display || "block",
                i.boxSizing = i.boxSizing || "border-box",
                bd(s)) {
                    const e = Ph(t, "width");
                    void 0 !== e && (t.width = e)
                }
                if (bd(n))
                    if ("" === t.style.height)
                        t.height = t.width / (e || 2);
                    else {
                        const e = Ph(t, "height");
                        void 0 !== e && (t.height = e)
                    }
            }(t, e),
            i) : null
        }
        releaseContext(t) {
            const e = t.canvas;
            if (!e[md])
                return !1;
            const i = e[md].initial;
            ["height", "width"].forEach(t => {
                const n = i[t];
                Ra(n) ? e.removeAttribute(t) : e.setAttribute(t, n)
            }
            );
            const n = i.style || {};
            return Object.keys(n).forEach(t => {
                e.style[t] = n[t]
            }
            ),
            e.width = e.width,
            delete e[md],
            !0
        }
        addEventListener(t, e, i) {
            this.removeEventListener(t, e);
            const n = t.$proxies || (t.$proxies = {})
              , s = {
                attach: wd,
                detach: Cd,
                resize: Ad
            }[e] || Md;
            n[e] = s(t, e, i)
        }
        removeEventListener(t, e) {
            const i = t.$proxies || (t.$proxies = {})
              , n = i[e];
            if (!n)
                return;
            ({
                attach: Ed,
                detach: Ed,
                resize: Ed
            }[e] || yd)(t, e, n),
            i[e] = void 0
        }
        getDevicePixelRatio() {
            return window.devicePixelRatio
        }
        getMaximumSize(t, e, i, n) {
            return $h(t, e, i, n)
        }
        isAttached(t) {
            const e = Sh(t);
            return !(!e || !e.isConnected)
        }
    }
    class Dd {
        constructor() {
            this._init = []
        }
        notify(t, e, i, n) {
            "beforeInit" === e && (this._init = this._createDescriptors(t, !0),
            this._notify(this._init, t, "install"));
            const s = n ? this._descriptors(t).filter(n) : this._descriptors(t)
              , o = this._notify(s, t, e, i);
            return "afterDestroy" === e && (this._notify(s, t, "stop"),
            this._notify(this._init, t, "uninstall")),
            o
        }
        _notify(t, e, i, n) {
            n = n || {};
            for (const s of t) {
                const t = s.plugin;
                if (!1 === Wa(t[i], [e, n, s.options], t) && n.cancelable)
                    return !1
            }
            return !0
        }
        invalidate() {
            Ra(this._cache) || (this._oldCache = this._cache,
            this._cache = void 0)
        }
        _descriptors(t) {
            if (this._cache)
                return this._cache;
            const e = this._cache = this._createDescriptors(t);
            return this._notifyStateChanges(t),
            e
        }
        _createDescriptors(t, e) {
            const i = t && t.config
              , n = za(i.options && i.options.plugins, {})
              , s = function(t) {
                const e = {}
                  , i = []
                  , n = Object.keys(Wc.plugins.items);
                for (let o = 0; o < n.length; o++)
                    i.push(Wc.getPlugin(n[o]));
                const s = t.plugins || [];
                for (let o = 0; o < s.length; o++) {
                    const t = s[o];
                    -1 === i.indexOf(t) && (i.push(t),
                    e[t.id] = !0)
                }
                return {
                    plugins: i,
                    localIds: e
                }
            }(i);
            return !1 !== n || e ? function(t, {plugins: e, localIds: i}, n, s) {
                const o = []
                  , a = t.getContext();
                for (const r of e) {
                    const e = r.id
                      , l = $d(n[e], s);
                    null !== l && o.push({
                        plugin: r,
                        options: Id(t.config, {
                            plugin: r,
                            local: i[e]
                        }, l, a)
                    })
                }
                return o
            }(t, s, n, e) : []
        }
        _notifyStateChanges(t) {
            const e = this._oldCache || []
              , i = this._cache
              , n = (t, e) => t.filter(t => !e.some(e => t.plugin.id === e.plugin.id));
            this._notify(n(e, i), t, "stop"),
            this._notify(n(i, e), t, "start")
        }
    }
    function $d(t, e) {
        return e || !1 !== t ? !0 === t ? {} : t : null
    }
    function Id(t, {plugin: e, local: i}, n, s) {
        const o = t.pluginScopeKeys(e)
          , a = t.getOptionScopes(n, o);
        return i && e.defaults && a.push(e.defaults),
        t.createResolver(a, s, [""], {
            scriptable: !1,
            indexable: !1,
            allKeys: !0
        })
    }
    function Ld(t, e) {
        const i = Dl.datasets[t] || {};
        return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || "x"
    }
    function Pd(t, e) {
        return "x" === t || "y" === t ? t : e.axis || ("top" === (i = e.position) || "bottom" === i ? "x" : "left" === i || "right" === i ? "y" : void 0) || t.charAt(0).toLowerCase();
        var i
    }
    function Rd(t) {
        const e = t.options || (t.options = {});
        e.plugins = za(e.plugins, {}),
        e.scales = function(t, e) {
            const i = Al[t.type] || {
                scales: {}
            }
              , n = e.scales || {}
              , s = Ld(t.type, e)
              , o = Object.create(null)
              , a = Object.create(null);
            return Object.keys(n).forEach(t => {
                const e = n[t];
                if (!Ba(e))
                    return console.error(`Invalid scale configuration for scale: ${t}`);
                if (e._proxy)
                    return console.warn(`Ignoring resolver passed as options for scale: ${t}`);
                const r = Pd(t, e)
                  , l = function(t, e) {
                    return t === e ? "_index_" : "_value_"
                }(r, s)
                  , h = i.scales || {};
                o[r] = o[r] || t,
                a[t] = Za(Object.create(null), [{
                    axis: r
                }, e, h[r], h[l]])
            }
            ),
            t.data.datasets.forEach(i => {
                const s = i.type || t.type
                  , r = i.indexAxis || Ld(s, e)
                  , l = (Al[s] || {}).scales || {};
                Object.keys(l).forEach(t => {
                    const e = function(t, e) {
                        let i = t;
                        return "_index_" === t ? i = e : "_value_" === t && (i = "x" === e ? "y" : "x"),
                        i
                    }(t, r)
                      , s = i[e + "AxisID"] || o[e] || e;
                    a[s] = a[s] || Object.create(null),
                    Za(a[s], [{
                        axis: e
                    }, n[s], l[t]])
                }
                )
            }
            ),
            Object.keys(a).forEach(t => {
                const e = a[t];
                Za(e, [Dl.scales[e.type], Dl.scale])
            }
            ),
            a
        }(t, e)
    }
    function Nd(t) {
        return (t = t || {}).datasets = t.datasets || [],
        t.labels = t.labels || [],
        t
    }
    const Bd = new Map
      , Hd = new Set;
    function Fd(t, e) {
        let i = Bd.get(t);
        return i || (i = e(),
        Bd.set(t, i),
        Hd.add(i)),
        i
    }
    const zd = (t, e, i) => {
        const n = Ja(e, i);
        void 0 !== n && t.add(n)
    }
    ;
    class jd {
        constructor(t) {
            this._config = function(t) {
                return (t = t || {}).data = Nd(t.data),
                Rd(t),
                t
            }(t),
            this._scopeCache = new Map,
            this._resolverCache = new Map
        }
        get platform() {
            return this._config.platform
        }
        get type() {
            return this._config.type
        }
        set type(t) {
            this._config.type = t
        }
        get data() {
            return this._config.data
        }
        set data(t) {
            this._config.data = Nd(t)
        }
        get options() {
            return this._config.options
        }
        set options(t) {
            this._config.options = t
        }
        get plugins() {
            return this._config.plugins
        }
        update() {
            const t = this._config;
            this.clearCache(),
            Rd(t)
        }
        clearCache() {
            this._scopeCache.clear(),
            this._resolverCache.clear()
        }
        datasetScopeKeys(t) {
            return Fd(t, () => [[`datasets.${t}`, ""]])
        }
        datasetAnimationScopeKeys(t, e) {
            return Fd(`${t}.transition.${e}`, () => [[`datasets.${t}.transitions.${e}`, `transitions.${e}`], [`datasets.${t}`, ""]])
        }
        datasetElementScopeKeys(t, e) {
            return Fd(`${t}-${e}`, () => [[`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, ""]])
        }
        pluginScopeKeys(t) {
            const e = t.id;
            return Fd(`${this.type}-plugin-${e}`, () => [[`plugins.${e}`, ...t.additionalOptionScopes || []]])
        }
        _cachedScopes(t, e) {
            const i = this._scopeCache;
            let n = i.get(t);
            return n && !e || (n = new Map,
            i.set(t, n)),
            n
        }
        getOptionScopes(t, e, i) {
            const {options: n, type: s} = this
              , o = this._cachedScopes(t, i)
              , a = o.get(e);
            if (a)
                return a;
            const r = new Set;
            e.forEach(e => {
                t && (r.add(t),
                e.forEach(e => zd(r, t, e))),
                e.forEach(t => zd(r, n, t)),
                e.forEach(t => zd(r, Al[s] || {}, t)),
                e.forEach(t => zd(r, Dl, t)),
                e.forEach(t => zd(r, El, t))
            }
            );
            const l = Array.from(r);
            return 0 === l.length && l.push(Object.create(null)),
            Hd.has(e) && o.set(e, l),
            l
        }
        chartOptionScopes() {
            const {options: t, type: e} = this;
            return [t, Al[e] || {}, Dl.datasets[e] || {}, {
                type: e
            }, Dl, El]
        }
        resolveNamedOptions(t, e, i, n=[""]) {
            const s = {
                $shared: !0
            }
              , {resolver: o, subPrefixes: a} = Wd(this._resolverCache, t, n);
            let r = o;
            if (function(t, e) {
                const {isScriptable: i, isIndexable: n} = oh(t);
                for (const s of e) {
                    const e = i(s)
                      , o = n(s)
                      , a = (o || e) && t[s];
                    if (e && (ir(a) || Vd(a)) || o && Na(a))
                        return !0
                }
                return !1
            }(o, e)) {
                s.$shared = !1;
                r = sh(o, i = ir(i) ? i() : i, this.createResolver(t, i, a))
            }
            for (const l of e)
                s[l] = r[l];
            return s
        }
        createResolver(t, e, i=[""], n) {
            const {resolver: s} = Wd(this._resolverCache, t, i);
            return Ba(e) ? sh(s, e, void 0, n) : s
        }
    }
    function Wd(t, e, i) {
        let n = t.get(e);
        n || (n = new Map,
        t.set(e, n));
        const s = i.join();
        let o = n.get(s);
        if (!o) {
            o = {
                resolver: nh(e, i),
                subPrefixes: i.filter(t => !t.toLowerCase().includes("hover"))
            },
            n.set(s, o)
        }
        return o
    }
    const Vd = t => Ba(t) && Object.getOwnPropertyNames(t).reduce( (e, i) => e || ir(t[i]), !1);
    const Yd = ["top", "bottom", "left", "right", "chartArea"];
    function Xd(t, e) {
        return "top" === t || "bottom" === t || -1 === Yd.indexOf(t) && "x" === e
    }
    function Kd(t, e) {
        return function(i, n) {
            return i[t] === n[t] ? i[e] - n[e] : i[t] - n[t]
        }
    }
    function Ud(t) {
        const e = t.chart
          , i = e.options.animation;
        e.notifyPlugins("afterRender"),
        Wa(i && i.onComplete, [t], e)
    }
    function qd(t) {
        const e = t.chart
          , i = e.options.animation;
        Wa(i && i.onProgress, [t], e)
    }
    function Zd(t) {
        return kh() && "string" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]),
        t && t.canvas && (t = t.canvas),
        t
    }
    const Gd = {}
      , Qd = t => {
        const e = Zd(t);
        return Object.values(Gd).filter(t => t.canvas === e).pop()
    }
    ;
    function Jd(t, e, i) {
        const n = Object.keys(t);
        for (const s of n) {
            const n = +s;
            if (n >= e) {
                const o = t[s];
                delete t[s],
                (i > 0 || n > e) && (t[n + i] = o)
            }
        }
    }
    let tu = class {
        constructor(t, e) {
            const i = this.config = new jd(e)
              , n = Zd(t)
              , s = Qd(n);
            if (s)
                throw new Error("Canvas is already in use. Chart with ID '" + s.id + "' must be destroyed before the canvas with ID '" + s.canvas.id + "' can be reused.");
            const o = i.createResolver(i.chartOptionScopes(), this.getContext());
            this.platform = new (i.platform || function(t) {
                return !kh() || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas ? gd : Od
            }(n)),
            this.platform.updateConfig(i);
            const a = this.platform.acquireContext(n, o.aspectRatio)
              , r = a && a.canvas
              , l = r && r.height
              , h = r && r.width;
            this.id = Pa(),
            this.ctx = a,
            this.canvas = r,
            this.width = h,
            this.height = l,
            this._options = o,
            this._aspectRatio = this.aspectRatio,
            this._layers = [],
            this._metasets = [],
            this._stacks = void 0,
            this.boxes = [],
            this.currentDevicePixelRatio = void 0,
            this.chartArea = void 0,
            this._active = [],
            this._lastEvent = void 0,
            this._listeners = {},
            this._responsiveListeners = void 0,
            this._sortedMetasets = [],
            this.scales = {},
            this._plugins = new Dd,
            this.$proxies = {},
            this._hiddenIndices = {},
            this.attached = !1,
            this._animationsDisabled = void 0,
            this.$context = void 0,
            this._doResize = function(t, e) {
                let i;
                return function(...n) {
                    return e ? (clearTimeout(i),
                    i = setTimeout(t, e, n)) : t.apply(this, n),
                    e
                }
            }(t => this.update(t), o.resizeDelay || 0),
            this._dataChanges = [],
            Gd[this.id] = this,
            a && r ? (Gh.listen(this, "complete", Ud),
            Gh.listen(this, "progress", qd),
            this._initialize(),
            this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item")
        }
        get aspectRatio() {
            const {options: {aspectRatio: t, maintainAspectRatio: e}, width: i, height: n, _aspectRatio: s} = this;
            return Ra(t) ? e && s ? s : n ? i / n : null : t
        }
        get data() {
            return this.config.data
        }
        set data(t) {
            this.config.data = t
        }
        get options() {
            return this._options
        }
        set options(t) {
            this.config.options = t
        }
        _initialize() {
            return this.notifyPlugins("beforeInit"),
            this.options.responsive ? this.resize() : Ih(this, this.options.devicePixelRatio),
            this.bindEvents(),
            this.notifyPlugins("afterInit"),
            this
        }
        clear() {
            return Pl(this.canvas, this.ctx),
            this
        }
        stop() {
            return Gh.stop(this),
            this
        }
        resize(t, e) {
            Gh.running(this) ? this._resizeBeforeDraw = {
                width: t,
                height: e
            } : this._resize(t, e)
        }
        _resize(t, e) {
            const i = this.options
              , n = this.canvas
              , s = i.maintainAspectRatio && this.aspectRatio
              , o = this.platform.getMaximumSize(n, t, e, s)
              , a = i.devicePixelRatio || this.platform.getDevicePixelRatio()
              , r = this.width ? "resize" : "attach";
            this.width = o.width,
            this.height = o.height,
            this._aspectRatio = this.aspectRatio,
            Ih(this, a, !0) && (this.notifyPlugins("resize", {
                size: o
            }),
            Wa(i.onResize, [this, o], this),
            this.attached && this._doResize(r) && this.render())
        }
        ensureScalesHaveIDs() {
            Va(this.options.scales || {}, (t, e) => {
                t.id = e
            }
            )
        }
        buildOrUpdateScales() {
            const t = this.options
              , e = t.scales
              , i = this.scales
              , n = Object.keys(i).reduce( (t, e) => (t[e] = !1,
            t), {});
            let s = [];
            e && (s = s.concat(Object.keys(e).map(t => {
                const i = e[t]
                  , n = Pd(t, i)
                  , s = "r" === n
                  , o = "x" === n;
                return {
                    options: i,
                    dposition: s ? "chartArea" : o ? "bottom" : "left",
                    dtype: s ? "radialLinear" : o ? "category" : "linear"
                }
            }
            ))),
            Va(s, e => {
                const s = e.options
                  , o = s.id
                  , a = Pd(o, s)
                  , r = za(s.type, e.dtype);
                void 0 !== s.position && Xd(s.position, a) === Xd(e.dposition) || (s.position = e.dposition),
                n[o] = !0;
                let l = null;
                if (o in i && i[o].type === r)
                    l = i[o];
                else {
                    l = new (Wc.getScale(r))({
                        id: o,
                        type: r,
                        ctx: this.ctx,
                        chart: this
                    }),
                    i[l.id] = l
                }
                l.init(s, t)
            }
            ),
            Va(n, (t, e) => {
                t || delete i[e]
            }
            ),
            Va(i, t => {
                pd.configure(this, t, t.options),
                pd.addBox(this, t)
            }
            )
        }
        _updateMetasets() {
            const t = this._metasets
              , e = this.data.datasets.length
              , i = t.length;
            if (t.sort( (t, e) => t.index - e.index),
            i > e) {
                for (let t = e; t < i; ++t)
                    this._destroyDatasetMeta(t);
                t.splice(e, i - e)
            }
            this._sortedMetasets = t.slice(0).sort(Kd("order", "index"))
        }
        _removeUnreferencedMetasets() {
            const {_metasets: t, data: {datasets: e}} = this;
            t.length > e.length && delete this._stacks,
            t.forEach( (t, i) => {
                0 === e.filter(e => e === t._dataset).length && this._destroyDatasetMeta(i)
            }
            )
        }
        buildOrUpdateControllers() {
            const t = []
              , e = this.data.datasets;
            let i, n;
            for (this._removeUnreferencedMetasets(),
            i = 0,
            n = e.length; i < n; i++) {
                const n = e[i];
                let s = this.getDatasetMeta(i);
                const o = n.type || this.config.type;
                if (s.type && s.type !== o && (this._destroyDatasetMeta(i),
                s = this.getDatasetMeta(i)),
                s.type = o,
                s.indexAxis = n.indexAxis || Ld(o, this.options),
                s.order = n.order || 0,
                s.index = i,
                s.label = "" + n.label,
                s.visible = this.isDatasetVisible(i),
                s.controller)
                    s.controller.updateIndex(i),
                    s.controller.linkScales();
                else {
                    const e = Wc.getController(o)
                      , {datasetElementType: n, dataElementType: a} = Dl.datasets[o];
                    Object.assign(e.prototype, {
                        dataElementType: Wc.getElement(a),
                        datasetElementType: n && Wc.getElement(n)
                    }),
                    s.controller = new e(this,i),
                    t.push(s.controller)
                }
            }
            return this._updateMetasets(),
            t
        }
        _resetElements() {
            Va(this.data.datasets, (t, e) => {
                this.getDatasetMeta(e).controller.reset()
            }
            , this)
        }
        reset() {
            this._resetElements(),
            this.notifyPlugins("reset")
        }
        update(t) {
            const e = this.config;
            e.update();
            const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext())
              , n = this._animationsDisabled = !i.animation;
            if (this._updateScales(),
            this._checkEventBindings(),
            this._updateHiddenIndices(),
            this._plugins.invalidate(),
            !1 === this.notifyPlugins("beforeUpdate", {
                mode: t,
                cancelable: !0
            }))
                return;
            const s = this.buildOrUpdateControllers();
            this.notifyPlugins("beforeElementsUpdate");
            let o = 0;
            for (let l = 0, h = this.data.datasets.length; l < h; l++) {
                const {controller: t} = this.getDatasetMeta(l)
                  , e = !n && -1 === s.indexOf(t);
                t.buildOrUpdateElements(e),
                o = Math.max(+t.getMaxOverflow(), o)
            }
            o = this._minPadding = i.layout.autoPadding ? o : 0,
            this._updateLayout(o),
            n || Va(s, t => {
                t.reset()
            }
            ),
            this._updateDatasets(t),
            this.notifyPlugins("afterUpdate", {
                mode: t
            }),
            this._layers.sort(Kd("z", "_idx"));
            const {_active: a, _lastEvent: r} = this;
            r ? this._eventHandler(r, !0) : a.length && this._updateHoverStyles(a, a, !0),
            this.render()
        }
        _updateScales() {
            Va(this.scales, t => {
                pd.removeBox(this, t)
            }
            ),
            this.ensureScalesHaveIDs(),
            this.buildOrUpdateScales()
        }
        _checkEventBindings() {
            const t = this.options
              , e = new Set(Object.keys(this._listeners))
              , i = new Set(t.events);
            nr(e, i) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(),
            this.bindEvents())
        }
        _updateHiddenIndices() {
            const {_hiddenIndices: t} = this
              , e = this._getUniformDataChanges() || [];
            for (const {method: i, start: n, count: s} of e) {
                Jd(t, n, "_removeElements" === i ? -s : s)
            }
        }
        _getUniformDataChanges() {
            const t = this._dataChanges;
            if (!t || !t.length)
                return;
            this._dataChanges = [];
            const e = this.data.datasets.length
              , i = e => new Set(t.filter(t => t[0] === e).map( (t, e) => e + "," + t.splice(1).join(",")))
              , n = i(0);
            for (let s = 1; s < e; s++)
                if (!nr(n, i(s)))
                    return;
            return Array.from(n).map(t => t.split(",")).map(t => ({
                method: t[1],
                start: +t[2],
                count: +t[3]
            }))
        }
        _updateLayout(t) {
            if (!1 === this.notifyPlugins("beforeLayout", {
                cancelable: !0
            }))
                return;
            pd.update(this, this.width, this.height, t);
            const e = this.chartArea
              , i = e.width <= 0 || e.height <= 0;
            this._layers = [],
            Va(this.boxes, t => {
                i && "chartArea" === t.position || (t.configure && t.configure(),
                this._layers.push(...t._layers()))
            }
            , this),
            this._layers.forEach( (t, e) => {
                t._idx = e
            }
            ),
            this.notifyPlugins("afterLayout")
        }
        _updateDatasets(t) {
            if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", {
                mode: t,
                cancelable: !0
            })) {
                for (let t = 0, e = this.data.datasets.length; t < e; ++t)
                    this.getDatasetMeta(t).controller.configure();
                for (let e = 0, i = this.data.datasets.length; e < i; ++e)
                    this._updateDataset(e, ir(t) ? t({
                        datasetIndex: e
                    }) : t);
                this.notifyPlugins("afterDatasetsUpdate", {
                    mode: t
                })
            }
        }
        _updateDataset(t, e) {
            const i = this.getDatasetMeta(t)
              , n = {
                meta: i,
                index: t,
                mode: e,
                cancelable: !0
            };
            !1 !== this.notifyPlugins("beforeDatasetUpdate", n) && (i.controller._update(e),
            n.cancelable = !1,
            this.notifyPlugins("afterDatasetUpdate", n))
        }
        render() {
            !1 !== this.notifyPlugins("beforeRender", {
                cancelable: !0
            }) && (Gh.has(this) ? this.attached && !Gh.running(this) && Gh.start(this) : (this.draw(),
            Ud({
                chart: this
            })))
        }
        draw() {
            let t;
            if (this._resizeBeforeDraw) {
                const {width: t, height: e} = this._resizeBeforeDraw;
                this._resize(t, e),
                this._resizeBeforeDraw = null
            }
            if (this.clear(),
            this.width <= 0 || this.height <= 0)
                return;
            if (!1 === this.notifyPlugins("beforeDraw", {
                cancelable: !0
            }))
                return;
            const e = this._layers;
            for (t = 0; t < e.length && e[t].z <= 0; ++t)
                e[t].draw(this.chartArea);
            for (this._drawDatasets(); t < e.length; ++t)
                e[t].draw(this.chartArea);
            this.notifyPlugins("afterDraw")
        }
        _getSortedDatasetMetas(t) {
            const e = this._sortedMetasets
              , i = [];
            let n, s;
            for (n = 0,
            s = e.length; n < s; ++n) {
                const s = e[n];
                t && !s.visible || i.push(s)
            }
            return i
        }
        getSortedVisibleDatasetMetas() {
            return this._getSortedDatasetMetas(!0)
        }
        _drawDatasets() {
            if (!1 === this.notifyPlugins("beforeDatasetsDraw", {
                cancelable: !0
            }))
                return;
            const t = this.getSortedVisibleDatasetMetas();
            for (let e = t.length - 1; e >= 0; --e)
                this._drawDataset(t[e]);
            this.notifyPlugins("afterDatasetsDraw")
        }
        _drawDataset(t) {
            const e = this.ctx
              , i = t._clip
              , n = !i.disabled
              , s = this.chartArea
              , o = {
                meta: t,
                index: t.index,
                cancelable: !0
            };
            !1 !== this.notifyPlugins("beforeDatasetDraw", o) && (n && Hl(e, {
                left: !1 === i.left ? 0 : s.left - i.left,
                right: !1 === i.right ? this.width : s.right + i.right,
                top: !1 === i.top ? 0 : s.top - i.top,
                bottom: !1 === i.bottom ? this.height : s.bottom + i.bottom
            }),
            t.controller.draw(),
            n && Fl(e),
            o.cancelable = !1,
            this.notifyPlugins("afterDatasetDraw", o))
        }
        isPointInArea(t) {
            return Bl(t, this.chartArea, this._minPadding)
        }
        getElementsAtEventForMode(t, e, i, n) {
            const s = td.modes[e];
            return "function" == typeof s ? s(this, t, i, n) : []
        }
        getDatasetMeta(t) {
            const e = this.data.datasets[t]
              , i = this._metasets;
            let n = i.filter(t => t && t._dataset === e).pop();
            return n || (n = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: e && e.order || 0,
                index: t,
                _dataset: e,
                _parsed: [],
                _sorted: !1
            },
            i.push(n)),
            n
        }
        getContext() {
            return this.$context || (this.$context = ih(null, {
                chart: this,
                type: "chart"
            }))
        }
        getVisibleDatasetCount() {
            return this.getSortedVisibleDatasetMetas().length
        }
        isDatasetVisible(t) {
            const e = this.data.datasets[t];
            if (!e)
                return !1;
            const i = this.getDatasetMeta(t);
            return "boolean" == typeof i.hidden ? !i.hidden : !e.hidden
        }
        setDatasetVisibility(t, e) {
            this.getDatasetMeta(t).hidden = !e
        }
        toggleDataVisibility(t) {
            this._hiddenIndices[t] = !this._hiddenIndices[t]
        }
        getDataVisibility(t) {
            return !this._hiddenIndices[t]
        }
        _updateVisibility(t, e, i) {
            const n = i ? "show" : "hide"
              , s = this.getDatasetMeta(t)
              , o = s.controller._resolveAnimations(void 0, n);
            er(e) ? (s.data[e].hidden = !i,
            this.update()) : (this.setDatasetVisibility(t, i),
            o.update(s, {
                visible: i
            }),
            this.update(e => e.datasetIndex === t ? n : void 0))
        }
        hide(t, e) {
            this._updateVisibility(t, e, !1)
        }
        show(t, e) {
            this._updateVisibility(t, e, !0)
        }
        _destroyDatasetMeta(t) {
            const e = this._metasets[t];
            e && e.controller && e.controller._destroy(),
            delete this._metasets[t]
        }
        _stop() {
            let t, e;
            for (this.stop(),
            Gh.remove(this),
            t = 0,
            e = this.data.datasets.length; t < e; ++t)
                this._destroyDatasetMeta(t)
        }
        destroy() {
            this.notifyPlugins("beforeDestroy");
            const {canvas: t, ctx: e} = this;
            this._stop(),
            this.config.clearCache(),
            t && (this.unbindEvents(),
            Pl(t, e),
            this.platform.releaseContext(e),
            this.canvas = null,
            this.ctx = null),
            this.notifyPlugins("destroy"),
            delete Gd[this.id],
            this.notifyPlugins("afterDestroy")
        }
        toBase64Image(...t) {
            return this.canvas.toDataURL(...t)
        }
        bindEvents() {
            this.bindUserEvents(),
            this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0
        }
        bindUserEvents() {
            const t = this._listeners
              , e = this.platform
              , i = (i, n) => {
                e.addEventListener(this, i, n),
                t[i] = n
            }
              , n = (t, e, i) => {
                t.offsetX = e,
                t.offsetY = i,
                this._eventHandler(t)
            }
            ;
            Va(this.options.events, t => i(t, n))
        }
        bindResponsiveEvents() {
            this._responsiveListeners || (this._responsiveListeners = {});
            const t = this._responsiveListeners
              , e = this.platform
              , i = (i, n) => {
                e.addEventListener(this, i, n),
                t[i] = n
            }
              , n = (i, n) => {
                t[i] && (e.removeEventListener(this, i, n),
                delete t[i])
            }
              , s = (t, e) => {
                this.canvas && this.resize(t, e)
            }
            ;
            let o;
            const a = () => {
                n("attach", a),
                this.attached = !0,
                this.resize(),
                i("resize", s),
                i("detach", o)
            }
            ;
            o = () => {
                this.attached = !1,
                n("resize", s),
                this._stop(),
                this._resize(0, 0),
                i("attach", a)
            }
            ,
            e.isAttached(this.canvas) ? a() : o()
        }
        unbindEvents() {
            Va(this._listeners, (t, e) => {
                this.platform.removeEventListener(this, e, t)
            }
            ),
            this._listeners = {},
            Va(this._responsiveListeners, (t, e) => {
                this.platform.removeEventListener(this, e, t)
            }
            ),
            this._responsiveListeners = void 0
        }
        updateHoverStyle(t, e, i) {
            const n = i ? "set" : "remove";
            let s, o, a, r;
            for ("dataset" === e && (s = this.getDatasetMeta(t[0].datasetIndex),
            s.controller["_" + n + "DatasetHoverStyle"]()),
            a = 0,
            r = t.length; a < r; ++a) {
                o = t[a];
                const e = o && this.getDatasetMeta(o.datasetIndex).controller;
                e && e[n + "HoverStyle"](o.element, o.datasetIndex, o.index)
            }
        }
        getActiveElements() {
            return this._active || []
        }
        setActiveElements(t) {
            const e = this._active || []
              , i = t.map( ({datasetIndex: t, index: e}) => {
                const i = this.getDatasetMeta(t);
                if (!i)
                    throw new Error("No dataset found at index " + t);
                return {
                    datasetIndex: t,
                    element: i.data[e],
                    index: e
                }
            }
            );
            !Ya(i, e) && (this._active = i,
            this._lastEvent = null,
            this._updateHoverStyles(i, e))
        }
        notifyPlugins(t, e, i) {
            return this._plugins.notify(this, t, e, i)
        }
        _updateHoverStyles(t, e, i) {
            const n = this.options.hover
              , s = (t, e) => t.filter(t => !e.some(e => t.datasetIndex === e.datasetIndex && t.index === e.index))
              , o = s(e, t)
              , a = i ? t : s(t, e);
            o.length && this.updateHoverStyle(o, n.mode, !1),
            a.length && n.mode && this.updateHoverStyle(a, n.mode, !0)
        }
        _eventHandler(t, e) {
            const i = {
                event: t,
                replay: e,
                cancelable: !0,
                inChartArea: this.isPointInArea(t)
            }
              , n = e => (e.options.events || this.options.events).includes(t.native.type);
            if (!1 === this.notifyPlugins("beforeEvent", i, n))
                return;
            const s = this._handleEvent(t, e, i.inChartArea);
            return i.cancelable = !1,
            this.notifyPlugins("afterEvent", i, n),
            (s || i.changed) && this.render(),
            this
        }
        _handleEvent(t, e, i) {
            const {_active: n=[], options: s} = this
              , o = e
              , a = this._getActiveElements(t, n, i, o)
              , r = function(t) {
                return "mouseup" === t.type || "click" === t.type || "contextmenu" === t.type
            }(t)
              , l = function(t, e, i, n) {
                return i && "mouseout" !== t.type ? n ? e : t : null
            }(t, this._lastEvent, i, r);
            i && (this._lastEvent = null,
            Wa(s.onHover, [t, a, this], this),
            r && Wa(s.onClick, [t, a, this], this));
            const h = !Ya(a, n);
            return (h || e) && (this._active = a,
            this._updateHoverStyles(a, n, e)),
            this._lastEvent = l,
            h
        }
        _getActiveElements(t, e, i, n) {
            if ("mouseout" === t.type)
                return [];
            if (!i)
                return e;
            const s = this.options.hover;
            return this.getElementsAtEventForMode(t, s.mode, s, n)
        }
    }
    ;
    const eu = () => Va(tu.instances, t => t._plugins.invalidate())
      , iu = !0;
    function nu(t, e, i) {
        const {startAngle: n, pixelMargin: s, x: o, y: a, outerRadius: r, innerRadius: l} = e;
        let h = s / r;
        t.beginPath(),
        t.arc(o, a, r, n - h, i + h),
        l > s ? (h = s / l,
        t.arc(o, a, l, i + h, n - h, !0)) : t.arc(o, a, s, i + hr, n - hr),
        t.closePath(),
        t.clip()
    }
    function su(t, e, i, n) {
        const s = Zl(t.options.borderRadius, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
        const o = (i - e) / 2
          , a = Math.min(o, n * e / 2)
          , r = t => {
            const e = (i - Math.min(o, t)) * n / 2;
            return Tr(t, 0, Math.min(o, e))
        }
        ;
        return {
            outerStart: r(s.outerStart),
            outerEnd: r(s.outerEnd),
            innerStart: Tr(s.innerStart, 0, a),
            innerEnd: Tr(s.innerEnd, 0, a)
        }
    }
    function ou(t, e, i, n) {
        return {
            x: i + t * Math.cos(e),
            y: n + t * Math.sin(e)
        }
    }
    function au(t, e, i, n, s, o) {
        const {x: a, y: r, startAngle: l, pixelMargin: h, innerRadius: c} = e
          , d = Math.max(e.outerRadius + n + i - h, 0)
          , u = c > 0 ? c + n + i + h : 0;
        let p = 0;
        const f = s - l;
        if (n) {
            const t = ((c > 0 ? c - n : 0) + (d > 0 ? d - n : 0)) / 2;
            p = (f - (0 !== t ? f * t / (t + n) : f)) / 2
        }
        const g = (f - Math.max(.001, f * d - i / sr) / d) / 2
          , m = l + g + p
          , _ = s - g - p
          , {outerStart: b, outerEnd: v, innerStart: y, innerEnd: x} = su(e, u, d, _ - m)
          , w = d - b
          , C = d - v
          , k = m + b / w
          , S = _ - v / C
          , T = u + y
          , A = u + x
          , E = m + y / T
          , M = _ - x / A;
        if (t.beginPath(),
        o) {
            if (t.arc(a, r, d, k, S),
            v > 0) {
                const e = ou(C, S, a, r);
                t.arc(e.x, e.y, v, S, _ + hr)
            }
            const e = ou(A, _, a, r);
            if (t.lineTo(e.x, e.y),
            x > 0) {
                const e = ou(A, M, a, r);
                t.arc(e.x, e.y, x, _ + hr, M + Math.PI)
            }
            if (t.arc(a, r, u, _ - x / u, m + y / u, !0),
            y > 0) {
                const e = ou(T, E, a, r);
                t.arc(e.x, e.y, y, E + Math.PI, m - hr)
            }
            const i = ou(w, m, a, r);
            if (t.lineTo(i.x, i.y),
            b > 0) {
                const e = ou(w, k, a, r);
                t.arc(e.x, e.y, b, m - hr, k)
            }
        } else {
            t.moveTo(a, r);
            const e = Math.cos(k) * d + a
              , i = Math.sin(k) * d + r;
            t.lineTo(e, i);
            const n = Math.cos(S) * d + a
              , s = Math.sin(S) * d + r;
            t.lineTo(n, s)
        }
        t.closePath()
    }
    function ru(t, e, i, n, s, o) {
        const {options: a} = e
          , {borderWidth: r, borderJoinStyle: l} = a
          , h = "inner" === a.borderAlign;
        r && (h ? (t.lineWidth = 2 * r,
        t.lineJoin = l || "round") : (t.lineWidth = r,
        t.lineJoin = l || "bevel"),
        e.fullCircles && function(t, e, i) {
            const {x: n, y: s, startAngle: o, pixelMargin: a, fullCircles: r} = e
              , l = Math.max(e.outerRadius - a, 0)
              , h = e.innerRadius + a;
            let c;
            for (i && nu(t, e, o + or),
            t.beginPath(),
            t.arc(n, s, h, o + or, o, !0),
            c = 0; c < r; ++c)
                t.stroke();
            for (t.beginPath(),
            t.arc(n, s, l, o, o + or),
            c = 0; c < r; ++c)
                t.stroke()
        }(t, e, h),
        h && nu(t, e, s),
        au(t, e, i, n, s, o),
        t.stroke())
    }
    Object.defineProperties(tu, {
        defaults: {
            enumerable: iu,
            value: Dl
        },
        instances: {
            enumerable: iu,
            value: Gd
        },
        overrides: {
            enumerable: iu,
            value: Al
        },
        registry: {
            enumerable: iu,
            value: Wc
        },
        version: {
            enumerable: iu,
            value: "3.9.1"
        },
        getChart: {
            enumerable: iu,
            value: Qd
        },
        register: {
            enumerable: iu,
            value: (...t) => {
                Wc.add(...t),
                eu()
            }
        },
        unregister: {
            enumerable: iu,
            value: (...t) => {
                Wc.remove(...t),
                eu()
            }
        }
    });
    class lu extends Oc {
        constructor(t) {
            super(),
            this.options = void 0,
            this.circumference = void 0,
            this.startAngle = void 0,
            this.endAngle = void 0,
            this.innerRadius = void 0,
            this.outerRadius = void 0,
            this.pixelMargin = 0,
            this.fullCircles = 0,
            t && Object.assign(this, t)
        }
        inRange(t, e, i) {
            const n = this.getProps(["x", "y"], i)
              , {angle: s, distance: o} = xr(n, {
                x: t,
                y: e
            })
              , {startAngle: a, endAngle: r, innerRadius: l, outerRadius: h, circumference: c} = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i)
              , d = this.options.spacing / 2
              , u = za(c, r - a) >= or || Sr(s, a, r)
              , p = Ar(o, l + d, h + d);
            return u && p
        }
        getCenterPoint(t) {
            const {x: e, y: i, startAngle: n, endAngle: s, innerRadius: o, outerRadius: a} = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], t)
              , {offset: r, spacing: l} = this.options
              , h = (n + s) / 2
              , c = (o + a + l + r) / 2;
            return {
                x: e + Math.cos(h) * c,
                y: i + Math.sin(h) * c
            }
        }
        tooltipPosition(t) {
            return this.getCenterPoint(t)
        }
        draw(t) {
            const {options: e, circumference: i} = this
              , n = (e.offset || 0) / 2
              , s = (e.spacing || 0) / 2
              , o = e.circular;
            if (this.pixelMargin = "inner" === e.borderAlign ? .33 : 0,
            this.fullCircles = i > or ? Math.floor(i / or) : 0,
            0 === i || this.innerRadius < 0 || this.outerRadius < 0)
                return;
            t.save();
            let a = 0;
            if (n) {
                a = n / 2;
                const e = (this.startAngle + this.endAngle) / 2;
                t.translate(Math.cos(e) * a, Math.sin(e) * a),
                this.circumference >= sr && (a = n)
            }
            t.fillStyle = e.backgroundColor,
            t.strokeStyle = e.borderColor;
            const r = function(t, e, i, n, s) {
                const {fullCircles: o, startAngle: a, circumference: r} = e;
                let l = e.endAngle;
                if (o) {
                    au(t, e, i, n, a + or, s);
                    for (let e = 0; e < o; ++e)
                        t.fill();
                    isNaN(r) || (l = a + r % or,
                    r % or === 0 && (l += or))
                }
                return au(t, e, i, n, l, s),
                t.fill(),
                l
            }(t, this, a, s, o);
            ru(t, this, a, s, r, o),
            t.restore()
        }
    }
    function hu(t, e, i=e) {
        t.lineCap = za(i.borderCapStyle, e.borderCapStyle),
        t.setLineDash(za(i.borderDash, e.borderDash)),
        t.lineDashOffset = za(i.borderDashOffset, e.borderDashOffset),
        t.lineJoin = za(i.borderJoinStyle, e.borderJoinStyle),
        t.lineWidth = za(i.borderWidth, e.borderWidth),
        t.strokeStyle = za(i.borderColor, e.borderColor)
    }
    function cu(t, e, i) {
        t.lineTo(i.x, i.y)
    }
    function du(t, e, i={}) {
        const n = t.length
          , {start: s=0, end: o=n - 1} = i
          , {start: a, end: r} = e
          , l = Math.max(s, a)
          , h = Math.min(o, r)
          , c = s < a && o < a || s > r && o > r;
        return {
            count: n,
            start: l,
            loop: e.loop,
            ilen: h < l && !c ? n + h - l : h - l
        }
    }
    function uu(t, e, i, n) {
        const {points: s, options: o} = e
          , {count: a, start: r, loop: l, ilen: h} = du(s, i, n)
          , c = function(t) {
            return t.stepped ? zl : t.tension || "monotone" === t.cubicInterpolationMode ? jl : cu
        }(o);
        let d, u, p, {move: f=!0, reverse: g} = n || {};
        for (d = 0; d <= h; ++d)
            u = s[(r + (g ? h - d : d)) % a],
            u.skip || (f ? (t.moveTo(u.x, u.y),
            f = !1) : c(t, p, u, g, o.stepped),
            p = u);
        return l && (u = s[(r + (g ? h : 0)) % a],
        c(t, p, u, g, o.stepped)),
        !!l
    }
    function pu(t, e, i, n) {
        const s = e.points
          , {count: o, start: a, ilen: r} = du(s, i, n)
          , {move: l=!0, reverse: h} = n || {};
        let c, d, u, p, f, g, m = 0, _ = 0;
        const b = t => (a + (h ? r - t : t)) % o
          , v = () => {
            p !== f && (t.lineTo(m, f),
            t.lineTo(m, p),
            t.lineTo(m, g))
        }
        ;
        for (l && (d = s[b(0)],
        t.moveTo(d.x, d.y)),
        c = 0; c <= r; ++c) {
            if (d = s[b(c)],
            d.skip)
                continue;
            const e = d.x
              , i = d.y
              , n = 0 | e;
            n === u ? (i < p ? p = i : i > f && (f = i),
            m = (_ * m + e) / ++_) : (v(),
            t.lineTo(e, i),
            u = n,
            _ = 0,
            p = f = i),
            g = i
        }
        v()
    }
    function fu(t) {
        const e = t.options
          , i = e.borderDash && e.borderDash.length;
        return !(t._decimated || t._loop || e.tension || "monotone" === e.cubicInterpolationMode || e.stepped || i) ? pu : uu
    }
    lu.id = "arc",
    lu.defaults = {
        borderAlign: "center",
        borderColor: "#fff",
        borderJoinStyle: void 0,
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        spacing: 0,
        angle: void 0,
        circular: !0
    },
    lu.defaultRoutes = {
        backgroundColor: "backgroundColor"
    };
    const gu = "function" == typeof Path2D;
    function mu(t, e, i, n) {
        gu && !e.options.segment ? function(t, e, i, n) {
            let s = e._path;
            s || (s = e._path = new Path2D,
            e.path(s, i, n) && s.closePath()),
            hu(t, e.options),
            t.stroke(s)
        }(t, e, i, n) : function(t, e, i, n) {
            const {segments: s, options: o} = e
              , a = fu(e);
            for (const r of s)
                hu(t, o, r.style),
                t.beginPath(),
                a(t, e, r, {
                    start: i,
                    end: i + n - 1
                }) && t.closePath(),
                t.stroke()
        }(t, e, i, n)
    }
    class _u extends Oc {
        constructor(t) {
            super(),
            this.animated = !0,
            this.options = void 0,
            this._chart = void 0,
            this._loop = void 0,
            this._fullLoop = void 0,
            this._path = void 0,
            this._points = void 0,
            this._segments = void 0,
            this._decimated = !1,
            this._pointsUpdated = !1,
            this._datasetIndex = void 0,
            t && Object.assign(this, t)
        }
        updateControlPoints(t, e) {
            const i = this.options;
            if ((i.tension || "monotone" === i.cubicInterpolationMode) && !i.stepped && !this._pointsUpdated) {
                const n = i.spanGaps ? this._loop : this._fullLoop;
                Ch(this._points, i, t, n, e),
                this._pointsUpdated = !0
            }
        }
        set points(t) {
            this._points = t,
            delete this._segments,
            delete this._path,
            this._pointsUpdated = !1
        }
        get points() {
            return this._points
        }
        get segments() {
            return this._segments || (this._segments = function(t, e) {
                const i = t.points
                  , n = t.options.spanGaps
                  , s = i.length;
                if (!s)
                    return [];
                const o = !!t._loop
                  , {start: a, end: r} = function(t, e, i, n) {
                    let s = 0
                      , o = e - 1;
                    if (i && !n)
                        for (; s < e && !t[s].skip; )
                            s++;
                    for (; s < e && t[s].skip; )
                        s++;
                    for (s %= e,
                    i && (o += s); o > s && t[o % e].skip; )
                        o--;
                    return o %= e,
                    {
                        start: s,
                        end: o
                    }
                }(i, s, o, n);
                return Uh(t, !0 === n ? [{
                    start: a,
                    end: r,
                    loop: o
                }] : function(t, e, i, n) {
                    const s = t.length
                      , o = [];
                    let a, r = e, l = t[e];
                    for (a = e + 1; a <= i; ++a) {
                        const i = t[a % s];
                        i.skip || i.stop ? l.skip || (n = !1,
                        o.push({
                            start: e % s,
                            end: (a - 1) % s,
                            loop: n
                        }),
                        e = r = i.stop ? a : null) : (r = a,
                        l.skip && (e = a)),
                        l = i
                    }
                    return null !== r && o.push({
                        start: e % s,
                        end: r % s,
                        loop: n
                    }),
                    o
                }(i, a, r < a ? r + s : r, !!t._fullLoop && 0 === a && r === s - 1), i, e)
            }(this, this.options.segment))
        }
        first() {
            const t = this.segments
              , e = this.points;
            return t.length && e[t[0].start]
        }
        last() {
            const t = this.segments
              , e = this.points
              , i = t.length;
            return i && e[t[i - 1].end]
        }
        interpolate(t, e) {
            const i = this.options
              , n = t[e]
              , s = this.points
              , o = Kh(this, {
                property: e,
                start: n,
                end: n
            });
            if (!o.length)
                return;
            const a = []
              , r = function(t) {
                return t.stepped ? Nh : t.tension || "monotone" === t.cubicInterpolationMode ? Bh : Rh
            }(i);
            let l, h;
            for (l = 0,
            h = o.length; l < h; ++l) {
                const {start: h, end: c} = o[l]
                  , d = s[h]
                  , u = s[c];
                if (d === u) {
                    a.push(d);
                    continue
                }
                const p = r(d, u, Math.abs((n - d[e]) / (u[e] - d[e])), i.stepped);
                p[e] = t[e],
                a.push(p)
            }
            return 1 === a.length ? a[0] : a
        }
        pathSegment(t, e, i) {
            return fu(this)(t, this, e, i)
        }
        path(t, e, i) {
            const n = this.segments
              , s = fu(this);
            let o = this._loop;
            e = e || 0,
            i = i || this.points.length - e;
            for (const a of n)
                o &= s(t, this, a, {
                    start: e,
                    end: e + i - 1
                });
            return !!o
        }
        draw(t, e, i, n) {
            const s = this.options || {};
            (this.points || []).length && s.borderWidth && (t.save(),
            mu(t, this, i, n),
            t.restore()),
            this.animated && (this._pointsUpdated = !1,
            this._path = void 0)
        }
    }
    function bu(t, e, i, n) {
        const s = t.options
          , {[i]: o} = t.getProps([i], n);
        return Math.abs(e - o) < s.radius + s.hitRadius
    }
    _u.id = "line",
    _u.defaults = {
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderWidth: 3,
        capBezierPoints: !0,
        cubicInterpolationMode: "default",
        fill: !1,
        spanGaps: !1,
        stepped: !1,
        tension: 0
    },
    _u.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    },
    _u.descriptors = {
        _scriptable: !0,
        _indexable: t => "borderDash" !== t && "fill" !== t
    };
    class vu extends Oc {
        constructor(t) {
            super(),
            this.options = void 0,
            this.parsed = void 0,
            this.skip = void 0,
            this.stop = void 0,
            t && Object.assign(this, t)
        }
        inRange(t, e, i) {
            const n = this.options
              , {x: s, y: o} = this.getProps(["x", "y"], i);
            return Math.pow(t - s, 2) + Math.pow(e - o, 2) < Math.pow(n.hitRadius + n.radius, 2)
        }
        inXRange(t, e) {
            return bu(this, t, "x", e)
        }
        inYRange(t, e) {
            return bu(this, t, "y", e)
        }
        getCenterPoint(t) {
            const {x: e, y: i} = this.getProps(["x", "y"], t);
            return {
                x: e,
                y: i
            }
        }
        size(t) {
            let e = (t = t || this.options || {}).radius || 0;
            e = Math.max(e, e && t.hoverRadius || 0);
            return 2 * (e + (e && t.borderWidth || 0))
        }
        draw(t, e) {
            const i = this.options;
            this.skip || i.radius < .1 || !Bl(this, e, this.size(i) / 2) || (t.strokeStyle = i.borderColor,
            t.lineWidth = i.borderWidth,
            t.fillStyle = i.backgroundColor,
            Rl(t, i, this.x, this.y))
        }
        getRange() {
            const t = this.options || {};
            return t.radius + t.hitRadius
        }
    }
    function yu(t, e) {
        const {x: i, y: n, base: s, width: o, height: a} = t.getProps(["x", "y", "base", "width", "height"], e);
        let r, l, h, c, d;
        return t.horizontal ? (d = a / 2,
        r = Math.min(i, s),
        l = Math.max(i, s),
        h = n - d,
        c = n + d) : (d = o / 2,
        r = i - d,
        l = i + d,
        h = Math.min(n, s),
        c = Math.max(n, s)),
        {
            left: r,
            top: h,
            right: l,
            bottom: c
        }
    }
    function xu(t, e, i, n) {
        return t ? 0 : Tr(e, i, n)
    }
    function wu(t) {
        const e = yu(t)
          , i = e.right - e.left
          , n = e.bottom - e.top
          , s = function(t, e, i) {
            const n = t.options.borderWidth
              , s = t.borderSkipped
              , o = Gl(n);
            return {
                t: xu(s.top, o.top, 0, i),
                r: xu(s.right, o.right, 0, e),
                b: xu(s.bottom, o.bottom, 0, i),
                l: xu(s.left, o.left, 0, e)
            }
        }(t, i / 2, n / 2)
          , o = function(t, e, i) {
            const {enableBorderRadius: n} = t.getProps(["enableBorderRadius"])
              , s = t.options.borderRadius
              , o = Ql(s)
              , a = Math.min(e, i)
              , r = t.borderSkipped
              , l = n || Ba(s);
            return {
                topLeft: xu(!l || r.top || r.left, o.topLeft, 0, a),
                topRight: xu(!l || r.top || r.right, o.topRight, 0, a),
                bottomLeft: xu(!l || r.bottom || r.left, o.bottomLeft, 0, a),
                bottomRight: xu(!l || r.bottom || r.right, o.bottomRight, 0, a)
            }
        }(t, i / 2, n / 2);
        return {
            outer: {
                x: e.left,
                y: e.top,
                w: i,
                h: n,
                radius: o
            },
            inner: {
                x: e.left + s.l,
                y: e.top + s.t,
                w: i - s.l - s.r,
                h: n - s.t - s.b,
                radius: {
                    topLeft: Math.max(0, o.topLeft - Math.max(s.t, s.l)),
                    topRight: Math.max(0, o.topRight - Math.max(s.t, s.r)),
                    bottomLeft: Math.max(0, o.bottomLeft - Math.max(s.b, s.l)),
                    bottomRight: Math.max(0, o.bottomRight - Math.max(s.b, s.r))
                }
            }
        }
    }
    function Cu(t, e, i, n) {
        const s = null === e
          , o = null === i
          , a = t && !(s && o) && yu(t, n);
        return a && (s || Ar(e, a.left, a.right)) && (o || Ar(i, a.top, a.bottom))
    }
    function ku(t, e) {
        t.rect(e.x, e.y, e.w, e.h)
    }
    function Su(t, e, i={}) {
        const n = t.x !== i.x ? -e : 0
          , s = t.y !== i.y ? -e : 0
          , o = (t.x + t.w !== i.x + i.w ? e : 0) - n
          , a = (t.y + t.h !== i.y + i.h ? e : 0) - s;
        return {
            x: t.x + n,
            y: t.y + s,
            w: t.w + o,
            h: t.h + a,
            radius: t.radius
        }
    }
    vu.id = "point",
    vu.defaults = {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: "circle",
        radius: 3,
        rotation: 0
    },
    vu.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    };
    class Tu extends Oc {
        constructor(t) {
            super(),
            this.options = void 0,
            this.horizontal = void 0,
            this.base = void 0,
            this.width = void 0,
            this.height = void 0,
            this.inflateAmount = void 0,
            t && Object.assign(this, t)
        }
        draw(t) {
            const {inflateAmount: e, options: {borderColor: i, backgroundColor: n}} = this
              , {inner: s, outer: o} = wu(this)
              , a = (r = o.radius).topLeft || r.topRight || r.bottomLeft || r.bottomRight ? Yl : ku;
            var r;
            t.save(),
            o.w === s.w && o.h === s.h || (t.beginPath(),
            a(t, Su(o, e, s)),
            t.clip(),
            a(t, Su(s, -e, o)),
            t.fillStyle = i,
            t.fill("evenodd")),
            t.beginPath(),
            a(t, Su(s, e)),
            t.fillStyle = n,
            t.fill(),
            t.restore()
        }
        inRange(t, e, i) {
            return Cu(this, t, e, i)
        }
        inXRange(t, e) {
            return Cu(this, t, null, e)
        }
        inYRange(t, e) {
            return Cu(this, null, t, e)
        }
        getCenterPoint(t) {
            const {x: e, y: i, base: n, horizontal: s} = this.getProps(["x", "y", "base", "horizontal"], t);
            return {
                x: s ? (e + n) / 2 : e,
                y: s ? i : (i + n) / 2
            }
        }
        getRange(t) {
            return "x" === t ? this.width / 2 : this.height / 2
        }
    }
    function Au(t) {
        if (t._decimated) {
            const e = t._data;
            delete t._decimated,
            delete t._data,
            Object.defineProperty(t, "data", {
                value: e
            })
        }
    }
    function Eu(t) {
        t.data.datasets.forEach(t => {
            Au(t)
        }
        )
    }
    Tu.id = "bar",
    Tu.defaults = {
        borderSkipped: "start",
        borderWidth: 0,
        borderRadius: 0,
        inflateAmount: "auto",
        pointStyle: void 0
    },
    Tu.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    };
    var Mu = {
        id: "decimation",
        defaults: {
            algorithm: "min-max",
            enabled: !1
        },
        beforeElementsUpdate: (t, e, i) => {
            if (!i.enabled)
                return void Eu(t);
            const n = t.width;
            t.data.datasets.forEach( (e, s) => {
                const {_data: o, indexAxis: a} = e
                  , r = t.getDatasetMeta(s)
                  , l = o || e.data;
                if ("y" === eh([a, t.options.indexAxis]))
                    return;
                if (!r.controller.supportsDecimation)
                    return;
                const h = t.scales[r.xAxisID];
                if ("linear" !== h.type && "time" !== h.type)
                    return;
                if (t.options.parsing)
                    return;
                let {start: c, count: d} = function(t, e) {
                    const i = e.length;
                    let n, s = 0;
                    const {iScale: o} = t
                      , {min: a, max: r, minDefined: l, maxDefined: h} = o.getUserBounds();
                    return l && (s = Tr(Mr(e, o.axis, a).lo, 0, i - 1)),
                    n = h ? Tr(Mr(e, o.axis, r).hi + 1, s, i) - s : i - s,
                    {
                        start: s,
                        count: n
                    }
                }(r, l);
                if (d <= (i.threshold || 4 * n))
                    return void Au(e);
                let u;
                switch (Ra(o) && (e._data = l,
                delete e.data,
                Object.defineProperty(e, "data", {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        return this._decimated
                    },
                    set: function(t) {
                        this._data = t
                    }
                })),
                i.algorithm) {
                case "lttb":
                    u = function(t, e, i, n, s) {
                        const o = s.samples || n;
                        if (o >= i)
                            return t.slice(e, e + i);
                        const a = []
                          , r = (i - 2) / (o - 2);
                        let l = 0;
                        const h = e + i - 1;
                        let c, d, u, p, f, g = e;
                        for (a[l++] = t[g],
                        c = 0; c < o - 2; c++) {
                            let n, s = 0, o = 0;
                            const h = Math.floor((c + 1) * r) + 1 + e
                              , m = Math.min(Math.floor((c + 2) * r) + 1, i) + e
                              , _ = m - h;
                            for (n = h; n < m; n++)
                                s += t[n].x,
                                o += t[n].y;
                            s /= _,
                            o /= _;
                            const b = Math.floor(c * r) + 1 + e
                              , v = Math.min(Math.floor((c + 1) * r) + 1, i) + e
                              , {x: y, y: x} = t[g];
                            for (u = p = -1,
                            n = b; n < v; n++)
                                p = .5 * Math.abs((y - s) * (t[n].y - x) - (y - t[n].x) * (o - x)),
                                p > u && (u = p,
                                d = t[n],
                                f = n);
                            a[l++] = d,
                            g = f
                        }
                        return a[l++] = t[h],
                        a
                    }(l, c, d, n, i);
                    break;
                case "min-max":
                    u = function(t, e, i, n) {
                        let s, o, a, r, l, h, c, d, u, p, f = 0, g = 0;
                        const m = []
                          , _ = e + i - 1
                          , b = t[e].x
                          , v = t[_].x - b;
                        for (s = e; s < e + i; ++s) {
                            o = t[s],
                            a = (o.x - b) / v * n,
                            r = o.y;
                            const e = 0 | a;
                            if (e === l)
                                r < u ? (u = r,
                                h = s) : r > p && (p = r,
                                c = s),
                                f = (g * f + o.x) / ++g;
                            else {
                                const i = s - 1;
                                if (!Ra(h) && !Ra(c)) {
                                    const e = Math.min(h, c)
                                      , n = Math.max(h, c);
                                    e !== d && e !== i && m.push({
                                        ...t[e],
                                        x: f
                                    }),
                                    n !== d && n !== i && m.push({
                                        ...t[n],
                                        x: f
                                    })
                                }
                                s > 0 && i !== d && m.push(t[i]),
                                m.push(o),
                                l = e,
                                g = 0,
                                u = p = r,
                                h = c = d = s
                            }
                        }
                        return m
                    }(l, c, d, n);
                    break;
                default:
                    throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`)
                }
                e._decimated = u
            }
            )
        }
        ,
        destroy(t) {
            Eu(t)
        }
    };
    function Ou(t, e, i, n) {
        if (n)
            return;
        let s = e[t]
          , o = i[t];
        return "angle" === t && (s = kr(s),
        o = kr(o)),
        {
            property: t,
            start: s,
            end: o
        }
    }
    function Du(t, e, i) {
        for (; e > t; e--) {
            const t = i[e];
            if (!isNaN(t.x) && !isNaN(t.y))
                break
        }
        return e
    }
    function $u(t, e, i, n) {
        return t && e ? n(t[i], e[i]) : t ? t[i] : e ? e[i] : 0
    }
    function Iu(t, e) {
        let i = []
          , n = !1;
        return Na(t) ? (n = !0,
        i = t) : i = function(t, e) {
            const {x: i=null, y: n=null} = t || {}
              , s = e.points
              , o = [];
            return e.segments.forEach( ({start: t, end: e}) => {
                e = Du(t, e, s);
                const a = s[t]
                  , r = s[e];
                null !== n ? (o.push({
                    x: a.x,
                    y: n
                }),
                o.push({
                    x: r.x,
                    y: n
                })) : null !== i && (o.push({
                    x: i,
                    y: a.y
                }),
                o.push({
                    x: i,
                    y: r.y
                }))
            }
            ),
            o
        }(t, e),
        i.length ? new _u({
            points: i,
            options: {
                tension: 0
            },
            _loop: n,
            _fullLoop: n
        }) : null
    }
    function Lu(t) {
        return t && !1 !== t.fill
    }
    function Pu(t, e, i) {
        let n = t[e].fill;
        const s = [e];
        let o;
        if (!i)
            return n;
        for (; !1 !== n && -1 === s.indexOf(n); ) {
            if (!Ha(n))
                return n;
            if (o = t[n],
            !o)
                return !1;
            if (o.visible)
                return n;
            s.push(n),
            n = o.fill
        }
        return !1
    }
    function Ru(t, e, i) {
        const n = function(t) {
            const e = t.options
              , i = e.fill;
            let n = za(i && i.target, i);
            void 0 === n && (n = !!e.backgroundColor);
            if (!1 === n || null === n)
                return !1;
            if (!0 === n)
                return "origin";
            return n
        }(t);
        if (Ba(n))
            return !isNaN(n.value) && n;
        let s = parseFloat(n);
        return Ha(s) && Math.floor(s) === s ? function(t, e, i, n) {
            "-" !== t && "+" !== t || (i = e + i);
            if (i === e || i < 0 || i >= n)
                return !1;
            return i
        }(n[0], e, s, i) : ["origin", "start", "end", "stack", "shape"].indexOf(n) >= 0 && n
    }
    function Nu(t, e, i) {
        const n = [];
        for (let s = 0; s < i.length; s++) {
            const o = i[s]
              , {first: a, last: r, point: l} = Bu(o, e, "x");
            if (!(!l || a && r))
                if (a)
                    n.unshift(l);
                else if (t.push(l),
                !r)
                    break
        }
        t.push(...n)
    }
    function Bu(t, e, i) {
        const n = t.interpolate(e, i);
        if (!n)
            return {};
        const s = n[i]
          , o = t.segments
          , a = t.points;
        let r = !1
          , l = !1;
        for (let h = 0; h < o.length; h++) {
            const t = o[h]
              , e = a[t.start][i]
              , n = a[t.end][i];
            if (Ar(s, e, n)) {
                r = s === e,
                l = s === n;
                break
            }
        }
        return {
            first: r,
            last: l,
            point: n
        }
    }
    class Hu {
        constructor(t) {
            this.x = t.x,
            this.y = t.y,
            this.radius = t.radius
        }
        pathSegment(t, e, i) {
            const {x: n, y: s, radius: o} = this;
            return e = e || {
                start: 0,
                end: or
            },
            t.arc(n, s, o, e.end, e.start, !0),
            !i.bounds
        }
        interpolate(t) {
            const {x: e, y: i, radius: n} = this
              , s = t.angle;
            return {
                x: e + Math.cos(s) * n,
                y: i + Math.sin(s) * n,
                angle: s
            }
        }
    }
    function Fu(t) {
        const {chart: e, fill: i, line: n} = t;
        if (Ha(i))
            return function(t, e) {
                const i = t.getDatasetMeta(e)
                  , n = i && t.isDatasetVisible(e);
                return n ? i.dataset : null
            }(e, i);
        if ("stack" === i)
            return function(t) {
                const {scale: e, index: i, line: n} = t
                  , s = []
                  , o = n.segments
                  , a = n.points
                  , r = function(t, e) {
                    const i = []
                      , n = t.getMatchingVisibleMetas("line");
                    for (let s = 0; s < n.length; s++) {
                        const t = n[s];
                        if (t.index === e)
                            break;
                        t.hidden || i.unshift(t.dataset)
                    }
                    return i
                }(e, i);
                r.push(Iu({
                    x: null,
                    y: e.bottom
                }, n));
                for (let l = 0; l < o.length; l++) {
                    const t = o[l];
                    for (let e = t.start; e <= t.end; e++)
                        Nu(s, a[e], r)
                }
                return new _u({
                    points: s,
                    options: {}
                })
            }(t);
        if ("shape" === i)
            return !0;
        const s = function(t) {
            const e = t.scale || {};
            if (e.getPointPositionForValue)
                return function(t) {
                    const {scale: e, fill: i} = t
                      , n = e.options
                      , s = e.getLabels().length
                      , o = n.reverse ? e.max : e.min
                      , a = function(t, e, i) {
                        let n;
                        return n = "start" === t ? i : "end" === t ? e.options.reverse ? e.min : e.max : Ba(t) ? t.value : e.getBaseValue(),
                        n
                    }(i, e, o)
                      , r = [];
                    if (n.grid.circular) {
                        const t = e.getPointPositionForValue(0, o);
                        return new Hu({
                            x: t.x,
                            y: t.y,
                            radius: e.getDistanceFromCenterForValue(a)
                        })
                    }
                    for (let l = 0; l < s; ++l)
                        r.push(e.getPointPositionForValue(l, a));
                    return r
                }(t);
            return function(t) {
                const {scale: e={}, fill: i} = t
                  , n = function(t, e) {
                    let i = null;
                    return "start" === t ? i = e.bottom : "end" === t ? i = e.top : Ba(t) ? i = e.getPixelForValue(t.value) : e.getBasePixel && (i = e.getBasePixel()),
                    i
                }(i, e);
                if (Ha(n)) {
                    const t = e.isHorizontal();
                    return {
                        x: t ? n : null,
                        y: t ? null : n
                    }
                }
                return null
            }(t)
        }(t);
        return s instanceof Hu ? s : Iu(s, n)
    }
    function zu(t, e, i) {
        const n = Fu(e)
          , {line: s, scale: o, axis: a} = e
          , r = s.options
          , l = r.fill
          , h = r.backgroundColor
          , {above: c=h, below: d=h} = l || {};
        n && s.points.length && (Hl(t, i),
        function(t, e) {
            const {line: i, target: n, above: s, below: o, area: a, scale: r} = e
              , l = i._loop ? "angle" : e.axis;
            t.save(),
            "x" === l && o !== s && (ju(t, n, a.top),
            Wu(t, {
                line: i,
                target: n,
                color: s,
                scale: r,
                property: l
            }),
            t.restore(),
            t.save(),
            ju(t, n, a.bottom));
            Wu(t, {
                line: i,
                target: n,
                color: o,
                scale: r,
                property: l
            }),
            t.restore()
        }(t, {
            line: s,
            target: n,
            above: c,
            below: d,
            area: i,
            scale: o,
            axis: a
        }),
        Fl(t))
    }
    function ju(t, e, i) {
        const {segments: n, points: s} = e;
        let o = !0
          , a = !1;
        t.beginPath();
        for (const r of n) {
            const {start: n, end: l} = r
              , h = s[n]
              , c = s[Du(n, l, s)];
            o ? (t.moveTo(h.x, h.y),
            o = !1) : (t.lineTo(h.x, i),
            t.lineTo(h.x, h.y)),
            a = !!e.pathSegment(t, r, {
                move: a
            }),
            a ? t.closePath() : t.lineTo(c.x, i)
        }
        t.lineTo(e.first().x, i),
        t.closePath(),
        t.clip()
    }
    function Wu(t, e) {
        const {line: i, target: n, property: s, color: o, scale: a} = e
          , r = function(t, e, i) {
            const n = t.segments
              , s = t.points
              , o = e.points
              , a = [];
            for (const r of n) {
                let {start: t, end: n} = r;
                n = Du(t, n, s);
                const l = Ou(i, s[t], s[n], r.loop);
                if (!e.segments) {
                    a.push({
                        source: r,
                        target: l,
                        start: s[t],
                        end: s[n]
                    });
                    continue
                }
                const h = Kh(e, l);
                for (const e of h) {
                    const t = Ou(i, o[e.start], o[e.end], e.loop)
                      , n = Xh(r, s, t);
                    for (const s of n)
                        a.push({
                            source: s,
                            target: e,
                            start: {
                                [i]: $u(l, t, "start", Math.max)
                            },
                            end: {
                                [i]: $u(l, t, "end", Math.min)
                            }
                        })
                }
            }
            return a
        }(i, n, s);
        for (const {source: l, target: h, start: c, end: d} of r) {
            const {style: {backgroundColor: e=o}={}} = l
              , r = !0 !== n;
            t.save(),
            t.fillStyle = e,
            Vu(t, a, r && Ou(s, c, d)),
            t.beginPath();
            const u = !!i.pathSegment(t, l);
            let p;
            if (r) {
                u ? t.closePath() : Yu(t, n, d, s);
                const e = !!n.pathSegment(t, h, {
                    move: u,
                    reverse: !0
                });
                p = u && e,
                p || Yu(t, n, c, s)
            }
            t.closePath(),
            t.fill(p ? "evenodd" : "nonzero"),
            t.restore()
        }
    }
    function Vu(t, e, i) {
        const {top: n, bottom: s} = e.chart.chartArea
          , {property: o, start: a, end: r} = i || {};
        "x" === o && (t.beginPath(),
        t.rect(a, n, r - a, s - n),
        t.clip())
    }
    function Yu(t, e, i, n) {
        const s = e.interpolate(i, n);
        s && t.lineTo(s.x, s.y)
    }
    var Xu = {
        id: "filler",
        afterDatasetsUpdate(t, e, i) {
            const n = (t.data.datasets || []).length
              , s = [];
            let o, a, r, l;
            for (a = 0; a < n; ++a)
                o = t.getDatasetMeta(a),
                r = o.dataset,
                l = null,
                r && r.options && r instanceof _u && (l = {
                    visible: t.isDatasetVisible(a),
                    index: a,
                    fill: Ru(r, a, n),
                    chart: t,
                    axis: o.controller.options.indexAxis,
                    scale: o.vScale,
                    line: r
                }),
                o.$filler = l,
                s.push(l);
            for (a = 0; a < n; ++a)
                l = s[a],
                l && !1 !== l.fill && (l.fill = Pu(s, a, i.propagate))
        },
        beforeDraw(t, e, i) {
            const n = "beforeDraw" === i.drawTime
              , s = t.getSortedVisibleDatasetMetas()
              , o = t.chartArea;
            for (let a = s.length - 1; a >= 0; --a) {
                const e = s[a].$filler;
                e && (e.line.updateControlPoints(o, e.axis),
                n && e.fill && zu(t.ctx, e, o))
            }
        },
        beforeDatasetsDraw(t, e, i) {
            if ("beforeDatasetsDraw" !== i.drawTime)
                return;
            const n = t.getSortedVisibleDatasetMetas();
            for (let s = n.length - 1; s >= 0; --s) {
                const e = n[s].$filler;
                Lu(e) && zu(t.ctx, e, t.chartArea)
            }
        },
        beforeDatasetDraw(t, e, i) {
            const n = e.meta.$filler;
            Lu(n) && "beforeDatasetDraw" === i.drawTime && zu(t.ctx, n, t.chartArea)
        },
        defaults: {
            propagate: !0,
            drawTime: "beforeDatasetDraw"
        }
    };
    const Ku = (t, e) => {
        let {boxHeight: i=e, boxWidth: n=e} = t;
        return t.usePointStyle && (i = Math.min(i, e),
        n = t.pointStyleWidth || Math.min(n, e)),
        {
            boxWidth: n,
            boxHeight: i,
            itemHeight: Math.max(e, i)
        }
    }
    ;
    class Uu extends Oc {
        constructor(t) {
            super(),
            this._added = !1,
            this.legendHitBoxes = [],
            this._hoveredItem = null,
            this.doughnutMode = !1,
            this.chart = t.chart,
            this.options = t.options,
            this.ctx = t.ctx,
            this.legendItems = void 0,
            this.columnSizes = void 0,
            this.lineWidths = void 0,
            this.maxHeight = void 0,
            this.maxWidth = void 0,
            this.top = void 0,
            this.bottom = void 0,
            this.left = void 0,
            this.right = void 0,
            this.height = void 0,
            this.width = void 0,
            this._margins = void 0,
            this.position = void 0,
            this.weight = void 0,
            this.fullSize = void 0
        }
        update(t, e, i) {
            this.maxWidth = t,
            this.maxHeight = e,
            this._margins = i,
            this.setDimensions(),
            this.buildLabels(),
            this.fit()
        }
        setDimensions() {
            this.isHorizontal() ? (this.width = this.maxWidth,
            this.left = this._margins.left,
            this.right = this.width) : (this.height = this.maxHeight,
            this.top = this._margins.top,
            this.bottom = this.height)
        }
        buildLabels() {
            const t = this.options.labels || {};
            let e = Wa(t.generateLabels, [this.chart], this) || [];
            t.filter && (e = e.filter(e => t.filter(e, this.chart.data))),
            t.sort && (e = e.sort( (e, i) => t.sort(e, i, this.chart.data))),
            this.options.reverse && e.reverse(),
            this.legendItems = e
        }
        fit() {
            const {options: t, ctx: e} = this;
            if (!t.display)
                return void (this.width = this.height = 0);
            const i = t.labels
              , n = th(i.font)
              , s = n.size
              , o = this._computeTitleHeight()
              , {boxWidth: a, itemHeight: r} = Ku(i, s);
            let l, h;
            e.font = n.string,
            this.isHorizontal() ? (l = this.maxWidth,
            h = this._fitRows(o, s, a, r) + 10) : (h = this.maxHeight,
            l = this._fitCols(o, s, a, r) + 10),
            this.width = Math.min(l, t.maxWidth || this.maxWidth),
            this.height = Math.min(h, t.maxHeight || this.maxHeight)
        }
        _fitRows(t, e, i, n) {
            const {ctx: s, maxWidth: o, options: {labels: {padding: a}}} = this
              , r = this.legendHitBoxes = []
              , l = this.lineWidths = [0]
              , h = n + a;
            let c = t;
            s.textAlign = "left",
            s.textBaseline = "middle";
            let d = -1
              , u = -h;
            return this.legendItems.forEach( (t, p) => {
                const f = i + e / 2 + s.measureText(t.text).width;
                (0 === p || l[l.length - 1] + f + 2 * a > o) && (c += h,
                l[l.length - (p > 0 ? 0 : 1)] = 0,
                u += h,
                d++),
                r[p] = {
                    left: 0,
                    top: u,
                    row: d,
                    width: f,
                    height: n
                },
                l[l.length - 1] += f + a
            }
            ),
            c
        }
        _fitCols(t, e, i, n) {
            const {ctx: s, maxHeight: o, options: {labels: {padding: a}}} = this
              , r = this.legendHitBoxes = []
              , l = this.columnSizes = []
              , h = o - t;
            let c = a
              , d = 0
              , u = 0
              , p = 0
              , f = 0;
            return this.legendItems.forEach( (t, o) => {
                const g = i + e / 2 + s.measureText(t.text).width;
                o > 0 && u + n + 2 * a > h && (c += d + a,
                l.push({
                    width: d,
                    height: u
                }),
                p += d + a,
                f++,
                d = u = 0),
                r[o] = {
                    left: p,
                    top: u,
                    col: f,
                    width: g,
                    height: n
                },
                d = Math.max(d, g),
                u += n + a
            }
            ),
            c += d,
            l.push({
                width: d,
                height: u
            }),
            c
        }
        adjustHitBoxes() {
            if (!this.options.display)
                return;
            const t = this._computeTitleHeight()
              , {legendHitBoxes: e, options: {align: i, labels: {padding: n}, rtl: s}} = this
              , o = zh(s, this.left, this.width);
            if (this.isHorizontal()) {
                let s = 0
                  , a = Nr(i, this.left + n, this.right - this.lineWidths[s]);
                for (const r of e)
                    s !== r.row && (s = r.row,
                    a = Nr(i, this.left + n, this.right - this.lineWidths[s])),
                    r.top += this.top + t + n,
                    r.left = o.leftForLtr(o.x(a), r.width),
                    a += r.width + n
            } else {
                let s = 0
                  , a = Nr(i, this.top + t + n, this.bottom - this.columnSizes[s].height);
                for (const r of e)
                    r.col !== s && (s = r.col,
                    a = Nr(i, this.top + t + n, this.bottom - this.columnSizes[s].height)),
                    r.top = a,
                    r.left += this.left + n,
                    r.left = o.leftForLtr(o.x(r.left), r.width),
                    a += r.height + n
            }
        }
        isHorizontal() {
            return "top" === this.options.position || "bottom" === this.options.position
        }
        draw() {
            if (this.options.display) {
                const t = this.ctx;
                Hl(t, this),
                this._draw(),
                Fl(t)
            }
        }
        _draw() {
            const {options: t, columnSizes: e, lineWidths: i, ctx: n} = this
              , {align: s, labels: o} = t
              , a = Dl.color
              , r = zh(t.rtl, this.left, this.width)
              , l = th(o.font)
              , {color: h, padding: c} = o
              , d = l.size
              , u = d / 2;
            let p;
            this.drawTitle(),
            n.textAlign = r.textAlign("left"),
            n.textBaseline = "middle",
            n.lineWidth = .5,
            n.font = l.string;
            const {boxWidth: f, boxHeight: g, itemHeight: m} = Ku(o, d)
              , _ = this.isHorizontal()
              , b = this._computeTitleHeight();
            p = _ ? {
                x: Nr(s, this.left + c, this.right - i[0]),
                y: this.top + c + b,
                line: 0
            } : {
                x: this.left + c,
                y: Nr(s, this.top + b + c, this.bottom - e[0].height),
                line: 0
            },
            jh(this.ctx, t.textDirection);
            const v = m + c;
            this.legendItems.forEach( (y, x) => {
                n.strokeStyle = y.fontColor || h,
                n.fillStyle = y.fontColor || h;
                const w = n.measureText(y.text).width
                  , C = r.textAlign(y.textAlign || (y.textAlign = o.textAlign))
                  , k = f + u + w;
                let S = p.x
                  , T = p.y;
                r.setWidth(this.width),
                _ ? x > 0 && S + k + c > this.right && (T = p.y += v,
                p.line++,
                S = p.x = Nr(s, this.left + c, this.right - i[p.line])) : x > 0 && T + v > this.bottom && (S = p.x = S + e[p.line].width + c,
                p.line++,
                T = p.y = Nr(s, this.top + b + c, this.bottom - e[p.line].height));
                !function(t, e, i) {
                    if (isNaN(f) || f <= 0 || isNaN(g) || g < 0)
                        return;
                    n.save();
                    const s = za(i.lineWidth, 1);
                    if (n.fillStyle = za(i.fillStyle, a),
                    n.lineCap = za(i.lineCap, "butt"),
                    n.lineDashOffset = za(i.lineDashOffset, 0),
                    n.lineJoin = za(i.lineJoin, "miter"),
                    n.lineWidth = s,
                    n.strokeStyle = za(i.strokeStyle, a),
                    n.setLineDash(za(i.lineDash, [])),
                    o.usePointStyle) {
                        const a = {
                            radius: g * Math.SQRT2 / 2,
                            pointStyle: i.pointStyle,
                            rotation: i.rotation,
                            borderWidth: s
                        }
                          , l = r.xPlus(t, f / 2);
                        Nl(n, a, l, e + u, o.pointStyleWidth && f)
                    } else {
                        const o = e + Math.max((d - g) / 2, 0)
                          , a = r.leftForLtr(t, f)
                          , l = Ql(i.borderRadius);
                        n.beginPath(),
                        Object.values(l).some(t => 0 !== t) ? Yl(n, {
                            x: a,
                            y: o,
                            w: f,
                            h: g,
                            radius: l
                        }) : n.rect(a, o, f, g),
                        n.fill(),
                        0 !== s && n.stroke()
                    }
                    n.restore()
                }(r.x(S), T, y),
                S = ( (t, e, i, n) => t === (n ? "left" : "right") ? i : "center" === t ? (e + i) / 2 : e)(C, S + f + u, _ ? S + k : this.right, t.rtl),
                function(t, e, i) {
                    Wl(n, i.text, t, e + m / 2, l, {
                        strikethrough: i.hidden,
                        textAlign: r.textAlign(i.textAlign)
                    })
                }(r.x(S), T, y),
                _ ? p.x += k + c : p.y += v
            }
            ),
            Wh(this.ctx, t.textDirection)
        }
        drawTitle() {
            const t = this.options
              , e = t.title
              , i = th(e.font)
              , n = Jl(e.padding);
            if (!e.display)
                return;
            const s = zh(t.rtl, this.left, this.width)
              , o = this.ctx
              , a = e.position
              , r = i.size / 2
              , l = n.top + r;
            let h, c = this.left, d = this.width;
            if (this.isHorizontal())
                d = Math.max(...this.lineWidths),
                h = this.top + l,
                c = Nr(t.align, c, this.right - d);
            else {
                const e = this.columnSizes.reduce( (t, e) => Math.max(t, e.height), 0);
                h = l + Nr(t.align, this.top, this.bottom - e - t.labels.padding - this._computeTitleHeight())
            }
            const u = Nr(a, c, c + d);
            o.textAlign = s.textAlign(Rr(a)),
            o.textBaseline = "middle",
            o.strokeStyle = e.color,
            o.fillStyle = e.color,
            o.font = i.string,
            Wl(o, e.text, u, h, i)
        }
        _computeTitleHeight() {
            const t = this.options.title
              , e = th(t.font)
              , i = Jl(t.padding);
            return t.display ? e.lineHeight + i.height : 0
        }
        _getLegendItemAt(t, e) {
            let i, n, s;
            if (Ar(t, this.left, this.right) && Ar(e, this.top, this.bottom))
                for (s = this.legendHitBoxes,
                i = 0; i < s.length; ++i)
                    if (n = s[i],
                    Ar(t, n.left, n.left + n.width) && Ar(e, n.top, n.top + n.height))
                        return this.legendItems[i];
            return null
        }
        handleEvent(t) {
            const e = this.options;
            if (!function(t, e) {
                if (("mousemove" === t || "mouseout" === t) && (e.onHover || e.onLeave))
                    return !0;
                if (e.onClick && ("click" === t || "mouseup" === t))
                    return !0;
                return !1
            }(t.type, e))
                return;
            const i = this._getLegendItemAt(t.x, t.y);
            if ("mousemove" === t.type || "mouseout" === t.type) {
                const o = this._hoveredItem
                  , a = (s = i,
                null !== (n = o) && null !== s && n.datasetIndex === s.datasetIndex && n.index === s.index);
                o && !a && Wa(e.onLeave, [t, o, this], this),
                this._hoveredItem = i,
                i && !a && Wa(e.onHover, [t, i, this], this)
            } else
                i && Wa(e.onClick, [t, i, this], this);
            var n, s
        }
    }
    var qu = {
        id: "legend",
        _element: Uu,
        start(t, e, i) {
            const n = t.legend = new Uu({
                ctx: t.ctx,
                options: i,
                chart: t
            });
            pd.configure(t, n, i),
            pd.addBox(t, n)
        },
        stop(t) {
            pd.removeBox(t, t.legend),
            delete t.legend
        },
        beforeUpdate(t, e, i) {
            const n = t.legend;
            pd.configure(t, n, i),
            n.options = i
        },
        afterUpdate(t) {
            const e = t.legend;
            e.buildLabels(),
            e.adjustHitBoxes()
        },
        afterEvent(t, e) {
            e.replay || t.legend.handleEvent(e.event)
        },
        defaults: {
            display: !0,
            position: "top",
            align: "center",
            fullSize: !0,
            reverse: !1,
            weight: 1e3,
            onClick(t, e, i) {
                const n = e.datasetIndex
                  , s = i.chart;
                s.isDatasetVisible(n) ? (s.hide(n),
                e.hidden = !0) : (s.show(n),
                e.hidden = !1)
            },
            onHover: null,
            onLeave: null,
            labels: {
                color: t => t.chart.options.color,
                boxWidth: 40,
                padding: 10,
                generateLabels(t) {
                    const e = t.data.datasets
                      , {labels: {usePointStyle: i, pointStyle: n, textAlign: s, color: o}} = t.legend.options;
                    return t._getSortedDatasetMetas().map(t => {
                        const a = t.controller.getStyle(i ? 0 : void 0)
                          , r = Jl(a.borderWidth);
                        return {
                            text: e[t.index].label,
                            fillStyle: a.backgroundColor,
                            fontColor: o,
                            hidden: !t.visible,
                            lineCap: a.borderCapStyle,
                            lineDash: a.borderDash,
                            lineDashOffset: a.borderDashOffset,
                            lineJoin: a.borderJoinStyle,
                            lineWidth: (r.width + r.height) / 4,
                            strokeStyle: a.borderColor,
                            pointStyle: n || a.pointStyle,
                            rotation: a.rotation,
                            textAlign: s || a.textAlign,
                            borderRadius: 0,
                            datasetIndex: t.index
                        }
                    }
                    , this)
                }
            },
            title: {
                color: t => t.chart.options.color,
                display: !1,
                position: "center",
                text: ""
            }
        },
        descriptors: {
            _scriptable: t => !t.startsWith("on"),
            labels: {
                _scriptable: t => !["generateLabels", "filter", "sort"].includes(t)
            }
        }
    };
    class Zu extends Oc {
        constructor(t) {
            super(),
            this.chart = t.chart,
            this.options = t.options,
            this.ctx = t.ctx,
            this._padding = void 0,
            this.top = void 0,
            this.bottom = void 0,
            this.left = void 0,
            this.right = void 0,
            this.width = void 0,
            this.height = void 0,
            this.position = void 0,
            this.weight = void 0,
            this.fullSize = void 0
        }
        update(t, e) {
            const i = this.options;
            if (this.left = 0,
            this.top = 0,
            !i.display)
                return void (this.width = this.height = this.right = this.bottom = 0);
            this.width = this.right = t,
            this.height = this.bottom = e;
            const n = Na(i.text) ? i.text.length : 1;
            this._padding = Jl(i.padding);
            const s = n * th(i.font).lineHeight + this._padding.height;
            this.isHorizontal() ? this.height = s : this.width = s
        }
        isHorizontal() {
            const t = this.options.position;
            return "top" === t || "bottom" === t
        }
        _drawArgs(t) {
            const {top: e, left: i, bottom: n, right: s, options: o} = this
              , a = o.align;
            let r, l, h, c = 0;
            return this.isHorizontal() ? (l = Nr(a, i, s),
            h = e + t,
            r = s - i) : ("left" === o.position ? (l = i + t,
            h = Nr(a, n, e),
            c = -.5 * sr) : (l = s - t,
            h = Nr(a, e, n),
            c = .5 * sr),
            r = n - e),
            {
                titleX: l,
                titleY: h,
                maxWidth: r,
                rotation: c
            }
        }
        draw() {
            const t = this.ctx
              , e = this.options;
            if (!e.display)
                return;
            const i = th(e.font)
              , n = i.lineHeight / 2 + this._padding.top
              , {titleX: s, titleY: o, maxWidth: a, rotation: r} = this._drawArgs(n);
            Wl(t, e.text, 0, 0, i, {
                color: e.color,
                maxWidth: a,
                rotation: r,
                textAlign: Rr(e.align),
                textBaseline: "middle",
                translation: [s, o]
            })
        }
    }
    var Gu = {
        id: "title",
        _element: Zu,
        start(t, e, i) {
            !function(t, e) {
                const i = new Zu({
                    ctx: t.ctx,
                    options: e,
                    chart: t
                });
                pd.configure(t, i, e),
                pd.addBox(t, i),
                t.titleBlock = i
            }(t, i)
        },
        stop(t) {
            const e = t.titleBlock;
            pd.removeBox(t, e),
            delete t.titleBlock
        },
        beforeUpdate(t, e, i) {
            const n = t.titleBlock;
            pd.configure(t, n, i),
            n.options = i
        },
        defaults: {
            align: "center",
            display: !1,
            font: {
                weight: "bold"
            },
            fullSize: !0,
            padding: 10,
            position: "top",
            text: "",
            weight: 2e3
        },
        defaultRoutes: {
            color: "color"
        },
        descriptors: {
            _scriptable: !0,
            _indexable: !1
        }
    };
    const Qu = new WeakMap;
    var Ju = {
        id: "subtitle",
        start(t, e, i) {
            const n = new Zu({
                ctx: t.ctx,
                options: i,
                chart: t
            });
            pd.configure(t, n, i),
            pd.addBox(t, n),
            Qu.set(t, n)
        },
        stop(t) {
            pd.removeBox(t, Qu.get(t)),
            Qu.delete(t)
        },
        beforeUpdate(t, e, i) {
            const n = Qu.get(t);
            pd.configure(t, n, i),
            n.options = i
        },
        defaults: {
            align: "center",
            display: !1,
            font: {
                weight: "normal"
            },
            fullSize: !0,
            padding: 0,
            position: "top",
            text: "",
            weight: 1500
        },
        defaultRoutes: {
            color: "color"
        },
        descriptors: {
            _scriptable: !0,
            _indexable: !1
        }
    };
    const tp = {
        average(t) {
            if (!t.length)
                return !1;
            let e, i, n = 0, s = 0, o = 0;
            for (e = 0,
            i = t.length; e < i; ++e) {
                const i = t[e].element;
                if (i && i.hasValue()) {
                    const t = i.tooltipPosition();
                    n += t.x,
                    s += t.y,
                    ++o
                }
            }
            return {
                x: n / o,
                y: s / o
            }
        },
        nearest(t, e) {
            if (!t.length)
                return !1;
            let i, n, s, o = e.x, a = e.y, r = Number.POSITIVE_INFINITY;
            for (i = 0,
            n = t.length; i < n; ++i) {
                const n = t[i].element;
                if (n && n.hasValue()) {
                    const t = wr(e, n.getCenterPoint());
                    t < r && (r = t,
                    s = n)
                }
            }
            if (s) {
                const t = s.tooltipPosition();
                o = t.x,
                a = t.y
            }
            return {
                x: o,
                y: a
            }
        }
    };
    function ep(t, e) {
        return e && (Na(e) ? Array.prototype.push.apply(t, e) : t.push(e)),
        t
    }
    function ip(t) {
        return ("string" == typeof t || t instanceof String) && t.indexOf("\n") > -1 ? t.split("\n") : t
    }
    function np(t, e) {
        const {element: i, datasetIndex: n, index: s} = e
          , o = t.getDatasetMeta(n).controller
          , {label: a, value: r} = o.getLabelAndValue(s);
        return {
            chart: t,
            label: a,
            parsed: o.getParsed(s),
            raw: t.data.datasets[n].data[s],
            formattedValue: r,
            dataset: o.getDataset(),
            dataIndex: s,
            datasetIndex: n,
            element: i
        }
    }
    function sp(t, e) {
        const i = t.chart.ctx
          , {body: n, footer: s, title: o} = t
          , {boxWidth: a, boxHeight: r} = e
          , l = th(e.bodyFont)
          , h = th(e.titleFont)
          , c = th(e.footerFont)
          , d = o.length
          , u = s.length
          , p = n.length
          , f = Jl(e.padding);
        let g = f.height
          , m = 0
          , _ = n.reduce( (t, e) => t + e.before.length + e.lines.length + e.after.length, 0);
        if (_ += t.beforeBody.length + t.afterBody.length,
        d && (g += d * h.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom),
        _) {
            g += p * (e.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight) + (_ - p) * l.lineHeight + (_ - 1) * e.bodySpacing
        }
        u && (g += e.footerMarginTop + u * c.lineHeight + (u - 1) * e.footerSpacing);
        let b = 0;
        const v = function(t) {
            m = Math.max(m, i.measureText(t).width + b)
        };
        return i.save(),
        i.font = h.string,
        Va(t.title, v),
        i.font = l.string,
        Va(t.beforeBody.concat(t.afterBody), v),
        b = e.displayColors ? a + 2 + e.boxPadding : 0,
        Va(n, t => {
            Va(t.before, v),
            Va(t.lines, v),
            Va(t.after, v)
        }
        ),
        b = 0,
        i.font = c.string,
        Va(t.footer, v),
        i.restore(),
        m += f.width,
        {
            width: m,
            height: g
        }
    }
    function op(t, e, i, n) {
        const {x: s, width: o} = i
          , {width: a, chartArea: {left: r, right: l}} = t;
        let h = "center";
        return "center" === n ? h = s <= (r + l) / 2 ? "left" : "right" : s <= o / 2 ? h = "left" : s >= a - o / 2 && (h = "right"),
        function(t, e, i, n) {
            const {x: s, width: o} = n
              , a = i.caretSize + i.caretPadding;
            return "left" === t && s + o + a > e.width || "right" === t && s - o - a < 0 || void 0
        }(h, t, e, i) && (h = "center"),
        h
    }
    function ap(t, e, i) {
        const n = i.yAlign || e.yAlign || function(t, e) {
            const {y: i, height: n} = e;
            return i < n / 2 ? "top" : i > t.height - n / 2 ? "bottom" : "center"
        }(t, i);
        return {
            xAlign: i.xAlign || e.xAlign || op(t, e, i, n),
            yAlign: n
        }
    }
    function rp(t, e, i, n) {
        const {caretSize: s, caretPadding: o, cornerRadius: a} = t
          , {xAlign: r, yAlign: l} = i
          , h = s + o
          , {topLeft: c, topRight: d, bottomLeft: u, bottomRight: p} = Ql(a);
        let f = function(t, e) {
            let {x: i, width: n} = t;
            return "right" === e ? i -= n : "center" === e && (i -= n / 2),
            i
        }(e, r);
        const g = function(t, e, i) {
            let {y: n, height: s} = t;
            return "top" === e ? n += i : n -= "bottom" === e ? s + i : s / 2,
            n
        }(e, l, h);
        return "center" === l ? "left" === r ? f += h : "right" === r && (f -= h) : "left" === r ? f -= Math.max(c, u) + s : "right" === r && (f += Math.max(d, p) + s),
        {
            x: Tr(f, 0, n.width - e.width),
            y: Tr(g, 0, n.height - e.height)
        }
    }
    function lp(t, e, i) {
        const n = Jl(i.padding);
        return "center" === e ? t.x + t.width / 2 : "right" === e ? t.x + t.width - n.right : t.x + n.left
    }
    function hp(t) {
        return ep([], ip(t))
    }
    function cp(t, e) {
        const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
        return i ? t.override(i) : t
    }
    class dp extends Oc {
        constructor(t) {
            super(),
            this.opacity = 0,
            this._active = [],
            this._eventPosition = void 0,
            this._size = void 0,
            this._cachedAnimations = void 0,
            this._tooltipItems = [],
            this.$animations = void 0,
            this.$context = void 0,
            this.chart = t.chart || t._chart,
            this._chart = this.chart,
            this.options = t.options,
            this.dataPoints = void 0,
            this.title = void 0,
            this.beforeBody = void 0,
            this.body = void 0,
            this.afterBody = void 0,
            this.footer = void 0,
            this.xAlign = void 0,
            this.yAlign = void 0,
            this.x = void 0,
            this.y = void 0,
            this.height = void 0,
            this.width = void 0,
            this.caretX = void 0,
            this.caretY = void 0,
            this.labelColors = void 0,
            this.labelPointStyles = void 0,
            this.labelTextColors = void 0
        }
        initialize(t) {
            this.options = t,
            this._cachedAnimations = void 0,
            this.$context = void 0
        }
        _resolveAnimations() {
            const t = this._cachedAnimations;
            if (t)
                return t;
            const e = this.chart
              , i = this.options.setContext(this.getContext())
              , n = i.enabled && e.options.animation && i.animations
              , s = new ic(this.chart,n);
            return n._cacheable && (this._cachedAnimations = Object.freeze(s)),
            s
        }
        getContext() {
            return this.$context || (this.$context = (t = this.chart.getContext(),
            e = this,
            i = this._tooltipItems,
            ih(t, {
                tooltip: e,
                tooltipItems: i,
                type: "tooltip"
            })));
            var t, e, i
        }
        getTitle(t, e) {
            const {callbacks: i} = e
              , n = i.beforeTitle.apply(this, [t])
              , s = i.title.apply(this, [t])
              , o = i.afterTitle.apply(this, [t]);
            let a = [];
            return a = ep(a, ip(n)),
            a = ep(a, ip(s)),
            a = ep(a, ip(o)),
            a
        }
        getBeforeBody(t, e) {
            return hp(e.callbacks.beforeBody.apply(this, [t]))
        }
        getBody(t, e) {
            const {callbacks: i} = e
              , n = [];
            return Va(t, t => {
                const e = {
                    before: [],
                    lines: [],
                    after: []
                }
                  , s = cp(i, t);
                ep(e.before, ip(s.beforeLabel.call(this, t))),
                ep(e.lines, s.label.call(this, t)),
                ep(e.after, ip(s.afterLabel.call(this, t))),
                n.push(e)
            }
            ),
            n
        }
        getAfterBody(t, e) {
            return hp(e.callbacks.afterBody.apply(this, [t]))
        }
        getFooter(t, e) {
            const {callbacks: i} = e
              , n = i.beforeFooter.apply(this, [t])
              , s = i.footer.apply(this, [t])
              , o = i.afterFooter.apply(this, [t]);
            let a = [];
            return a = ep(a, ip(n)),
            a = ep(a, ip(s)),
            a = ep(a, ip(o)),
            a
        }
        _createItems(t) {
            const e = this._active
              , i = this.chart.data
              , n = []
              , s = []
              , o = [];
            let a, r, l = [];
            for (a = 0,
            r = e.length; a < r; ++a)
                l.push(np(this.chart, e[a]));
            return t.filter && (l = l.filter( (e, n, s) => t.filter(e, n, s, i))),
            t.itemSort && (l = l.sort( (e, n) => t.itemSort(e, n, i))),
            Va(l, e => {
                const i = cp(t.callbacks, e);
                n.push(i.labelColor.call(this, e)),
                s.push(i.labelPointStyle.call(this, e)),
                o.push(i.labelTextColor.call(this, e))
            }
            ),
            this.labelColors = n,
            this.labelPointStyles = s,
            this.labelTextColors = o,
            this.dataPoints = l,
            l
        }
        update(t, e) {
            const i = this.options.setContext(this.getContext())
              , n = this._active;
            let s, o = [];
            if (n.length) {
                const t = tp[i.position].call(this, n, this._eventPosition);
                o = this._createItems(i),
                this.title = this.getTitle(o, i),
                this.beforeBody = this.getBeforeBody(o, i),
                this.body = this.getBody(o, i),
                this.afterBody = this.getAfterBody(o, i),
                this.footer = this.getFooter(o, i);
                const e = this._size = sp(this, i)
                  , a = Object.assign({}, t, e)
                  , r = ap(this.chart, i, a)
                  , l = rp(i, a, r, this.chart);
                this.xAlign = r.xAlign,
                this.yAlign = r.yAlign,
                s = {
                    opacity: 1,
                    x: l.x,
                    y: l.y,
                    width: e.width,
                    height: e.height,
                    caretX: t.x,
                    caretY: t.y
                }
            } else
                0 !== this.opacity && (s = {
                    opacity: 0
                });
            this._tooltipItems = o,
            this.$context = void 0,
            s && this._resolveAnimations().update(this, s),
            t && i.external && i.external.call(this, {
                chart: this.chart,
                tooltip: this,
                replay: e
            })
        }
        drawCaret(t, e, i, n) {
            const s = this.getCaretPosition(t, i, n);
            e.lineTo(s.x1, s.y1),
            e.lineTo(s.x2, s.y2),
            e.lineTo(s.x3, s.y3)
        }
        getCaretPosition(t, e, i) {
            const {xAlign: n, yAlign: s} = this
              , {caretSize: o, cornerRadius: a} = i
              , {topLeft: r, topRight: l, bottomLeft: h, bottomRight: c} = Ql(a)
              , {x: d, y: u} = t
              , {width: p, height: f} = e;
            let g, m, _, b, v, y;
            return "center" === s ? (v = u + f / 2,
            "left" === n ? (g = d,
            m = g - o,
            b = v + o,
            y = v - o) : (g = d + p,
            m = g + o,
            b = v - o,
            y = v + o),
            _ = g) : (m = "left" === n ? d + Math.max(r, h) + o : "right" === n ? d + p - Math.max(l, c) - o : this.caretX,
            "top" === s ? (b = u,
            v = b - o,
            g = m - o,
            _ = m + o) : (b = u + f,
            v = b + o,
            g = m + o,
            _ = m - o),
            y = b),
            {
                x1: g,
                x2: m,
                x3: _,
                y1: b,
                y2: v,
                y3: y
            }
        }
        drawTitle(t, e, i) {
            const n = this.title
              , s = n.length;
            let o, a, r;
            if (s) {
                const l = zh(i.rtl, this.x, this.width);
                for (t.x = lp(this, i.titleAlign, i),
                e.textAlign = l.textAlign(i.titleAlign),
                e.textBaseline = "middle",
                o = th(i.titleFont),
                a = i.titleSpacing,
                e.fillStyle = i.titleColor,
                e.font = o.string,
                r = 0; r < s; ++r)
                    e.fillText(n[r], l.x(t.x), t.y + o.lineHeight / 2),
                    t.y += o.lineHeight + a,
                    r + 1 === s && (t.y += i.titleMarginBottom - a)
            }
        }
        _drawColorBox(t, e, i, n, s) {
            const o = this.labelColors[i]
              , a = this.labelPointStyles[i]
              , {boxHeight: r, boxWidth: l, boxPadding: h} = s
              , c = th(s.bodyFont)
              , d = lp(this, "left", s)
              , u = n.x(d)
              , p = r < c.lineHeight ? (c.lineHeight - r) / 2 : 0
              , f = e.y + p;
            if (s.usePointStyle) {
                const e = {
                    radius: Math.min(l, r) / 2,
                    pointStyle: a.pointStyle,
                    rotation: a.rotation,
                    borderWidth: 1
                }
                  , i = n.leftForLtr(u, l) + l / 2
                  , h = f + r / 2;
                t.strokeStyle = s.multiKeyBackground,
                t.fillStyle = s.multiKeyBackground,
                Rl(t, e, i, h),
                t.strokeStyle = o.borderColor,
                t.fillStyle = o.backgroundColor,
                Rl(t, e, i, h)
            } else {
                t.lineWidth = Ba(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1,
                t.strokeStyle = o.borderColor,
                t.setLineDash(o.borderDash || []),
                t.lineDashOffset = o.borderDashOffset || 0;
                const e = n.leftForLtr(u, l - h)
                  , i = n.leftForLtr(n.xPlus(u, 1), l - h - 2)
                  , a = Ql(o.borderRadius);
                Object.values(a).some(t => 0 !== t) ? (t.beginPath(),
                t.fillStyle = s.multiKeyBackground,
                Yl(t, {
                    x: e,
                    y: f,
                    w: l,
                    h: r,
                    radius: a
                }),
                t.fill(),
                t.stroke(),
                t.fillStyle = o.backgroundColor,
                t.beginPath(),
                Yl(t, {
                    x: i,
                    y: f + 1,
                    w: l - 2,
                    h: r - 2,
                    radius: a
                }),
                t.fill()) : (t.fillStyle = s.multiKeyBackground,
                t.fillRect(e, f, l, r),
                t.strokeRect(e, f, l, r),
                t.fillStyle = o.backgroundColor,
                t.fillRect(i, f + 1, l - 2, r - 2))
            }
            t.fillStyle = this.labelTextColors[i]
        }
        drawBody(t, e, i) {
            const {body: n} = this
              , {bodySpacing: s, bodyAlign: o, displayColors: a, boxHeight: r, boxWidth: l, boxPadding: h} = i
              , c = th(i.bodyFont);
            let d = c.lineHeight
              , u = 0;
            const p = zh(i.rtl, this.x, this.width)
              , f = function(i) {
                e.fillText(i, p.x(t.x + u), t.y + d / 2),
                t.y += d + s
            }
              , g = p.textAlign(o);
            let m, _, b, v, y, x, w;
            for (e.textAlign = o,
            e.textBaseline = "middle",
            e.font = c.string,
            t.x = lp(this, g, i),
            e.fillStyle = i.bodyColor,
            Va(this.beforeBody, f),
            u = a && "right" !== g ? "center" === o ? l / 2 + h : l + 2 + h : 0,
            v = 0,
            x = n.length; v < x; ++v) {
                for (m = n[v],
                _ = this.labelTextColors[v],
                e.fillStyle = _,
                Va(m.before, f),
                b = m.lines,
                a && b.length && (this._drawColorBox(e, t, v, p, i),
                d = Math.max(c.lineHeight, r)),
                y = 0,
                w = b.length; y < w; ++y)
                    f(b[y]),
                    d = c.lineHeight;
                Va(m.after, f)
            }
            u = 0,
            d = c.lineHeight,
            Va(this.afterBody, f),
            t.y -= s
        }
        drawFooter(t, e, i) {
            const n = this.footer
              , s = n.length;
            let o, a;
            if (s) {
                const r = zh(i.rtl, this.x, this.width);
                for (t.x = lp(this, i.footerAlign, i),
                t.y += i.footerMarginTop,
                e.textAlign = r.textAlign(i.footerAlign),
                e.textBaseline = "middle",
                o = th(i.footerFont),
                e.fillStyle = i.footerColor,
                e.font = o.string,
                a = 0; a < s; ++a)
                    e.fillText(n[a], r.x(t.x), t.y + o.lineHeight / 2),
                    t.y += o.lineHeight + i.footerSpacing
            }
        }
        drawBackground(t, e, i, n) {
            const {xAlign: s, yAlign: o} = this
              , {x: a, y: r} = t
              , {width: l, height: h} = i
              , {topLeft: c, topRight: d, bottomLeft: u, bottomRight: p} = Ql(n.cornerRadius);
            e.fillStyle = n.backgroundColor,
            e.strokeStyle = n.borderColor,
            e.lineWidth = n.borderWidth,
            e.beginPath(),
            e.moveTo(a + c, r),
            "top" === o && this.drawCaret(t, e, i, n),
            e.lineTo(a + l - d, r),
            e.quadraticCurveTo(a + l, r, a + l, r + d),
            "center" === o && "right" === s && this.drawCaret(t, e, i, n),
            e.lineTo(a + l, r + h - p),
            e.quadraticCurveTo(a + l, r + h, a + l - p, r + h),
            "bottom" === o && this.drawCaret(t, e, i, n),
            e.lineTo(a + u, r + h),
            e.quadraticCurveTo(a, r + h, a, r + h - u),
            "center" === o && "left" === s && this.drawCaret(t, e, i, n),
            e.lineTo(a, r + c),
            e.quadraticCurveTo(a, r, a + c, r),
            e.closePath(),
            e.fill(),
            n.borderWidth > 0 && e.stroke()
        }
        _updateAnimationTarget(t) {
            const e = this.chart
              , i = this.$animations
              , n = i && i.x
              , s = i && i.y;
            if (n || s) {
                const i = tp[t.position].call(this, this._active, this._eventPosition);
                if (!i)
                    return;
                const o = this._size = sp(this, t)
                  , a = Object.assign({}, i, this._size)
                  , r = ap(e, t, a)
                  , l = rp(t, a, r, e);
                n._to === l.x && s._to === l.y || (this.xAlign = r.xAlign,
                this.yAlign = r.yAlign,
                this.width = o.width,
                this.height = o.height,
                this.caretX = i.x,
                this.caretY = i.y,
                this._resolveAnimations().update(this, l))
            }
        }
        _willRender() {
            return !!this.opacity
        }
        draw(t) {
            const e = this.options.setContext(this.getContext());
            let i = this.opacity;
            if (!i)
                return;
            this._updateAnimationTarget(e);
            const n = {
                width: this.width,
                height: this.height
            }
              , s = {
                x: this.x,
                y: this.y
            };
            i = Math.abs(i) < .001 ? 0 : i;
            const o = Jl(e.padding)
              , a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
            e.enabled && a && (t.save(),
            t.globalAlpha = i,
            this.drawBackground(s, t, n, e),
            jh(t, e.textDirection),
            s.y += o.top,
            this.drawTitle(s, t, e),
            this.drawBody(s, t, e),
            this.drawFooter(s, t, e),
            Wh(t, e.textDirection),
            t.restore())
        }
        getActiveElements() {
            return this._active || []
        }
        setActiveElements(t, e) {
            const i = this._active
              , n = t.map( ({datasetIndex: t, index: e}) => {
                const i = this.chart.getDatasetMeta(t);
                if (!i)
                    throw new Error("Cannot find a dataset at index " + t);
                return {
                    datasetIndex: t,
                    element: i.data[e],
                    index: e
                }
            }
            )
              , s = !Ya(i, n)
              , o = this._positionChanged(n, e);
            (s || o) && (this._active = n,
            this._eventPosition = e,
            this._ignoreReplayEvents = !0,
            this.update(!0))
        }
        handleEvent(t, e, i=!0) {
            if (e && this._ignoreReplayEvents)
                return !1;
            this._ignoreReplayEvents = !1;
            const n = this.options
              , s = this._active || []
              , o = this._getActiveElements(t, s, e, i)
              , a = this._positionChanged(o, t)
              , r = e || !Ya(o, s) || a;
            return r && (this._active = o,
            (n.enabled || n.external) && (this._eventPosition = {
                x: t.x,
                y: t.y
            },
            this.update(!0, e))),
            r
        }
        _getActiveElements(t, e, i, n) {
            const s = this.options;
            if ("mouseout" === t.type)
                return [];
            if (!n)
                return e;
            const o = this.chart.getElementsAtEventForMode(t, s.mode, s, i);
            return s.reverse && o.reverse(),
            o
        }
        _positionChanged(t, e) {
            const {caretX: i, caretY: n, options: s} = this
              , o = tp[s.position].call(this, t, e);
            return !1 !== o && (i !== o.x || n !== o.y)
        }
    }
    dp.positioners = tp;
    var up = {
        id: "tooltip",
        _element: dp,
        positioners: tp,
        afterInit(t, e, i) {
            i && (t.tooltip = new dp({
                chart: t,
                options: i
            }))
        },
        beforeUpdate(t, e, i) {
            t.tooltip && t.tooltip.initialize(i)
        },
        reset(t, e, i) {
            t.tooltip && t.tooltip.initialize(i)
        },
        afterDraw(t) {
            const e = t.tooltip;
            if (e && e._willRender()) {
                const i = {
                    tooltip: e
                };
                if (!1 === t.notifyPlugins("beforeTooltipDraw", i))
                    return;
                e.draw(t.ctx),
                t.notifyPlugins("afterTooltipDraw", i)
            }
        },
        afterEvent(t, e) {
            if (t.tooltip) {
                const i = e.replay;
                t.tooltip.handleEvent(e.event, i, e.inChartArea) && (e.changed = !0)
            }
        },
        defaults: {
            enabled: !0,
            external: null,
            position: "average",
            backgroundColor: "rgba(0,0,0,0.8)",
            titleColor: "#fff",
            titleFont: {
                weight: "bold"
            },
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleAlign: "left",
            bodyColor: "#fff",
            bodySpacing: 2,
            bodyFont: {},
            bodyAlign: "left",
            footerColor: "#fff",
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFont: {
                weight: "bold"
            },
            footerAlign: "left",
            padding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            boxHeight: (t, e) => e.bodyFont.size,
            boxWidth: (t, e) => e.bodyFont.size,
            multiKeyBackground: "#fff",
            displayColors: !0,
            boxPadding: 0,
            borderColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            animation: {
                duration: 400,
                easing: "easeOutQuart"
            },
            animations: {
                numbers: {
                    type: "number",
                    properties: ["x", "y", "width", "height", "caretX", "caretY"]
                },
                opacity: {
                    easing: "linear",
                    duration: 200
                }
            },
            callbacks: {
                beforeTitle: La,
                title(t) {
                    if (t.length > 0) {
                        const e = t[0]
                          , i = e.chart.data.labels
                          , n = i ? i.length : 0;
                        if (this && this.options && "dataset" === this.options.mode)
                            return e.dataset.label || "";
                        if (e.label)
                            return e.label;
                        if (n > 0 && e.dataIndex < n)
                            return i[e.dataIndex]
                    }
                    return ""
                },
                afterTitle: La,
                beforeBody: La,
                beforeLabel: La,
                label(t) {
                    if (this && this.options && "dataset" === this.options.mode)
                        return t.label + ": " + t.formattedValue || t.formattedValue;
                    let e = t.dataset.label || "";
                    e && (e += ": ");
                    const i = t.formattedValue;
                    return Ra(i) || (e += i),
                    e
                },
                labelColor(t) {
                    const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
                    return {
                        borderColor: e.borderColor,
                        backgroundColor: e.backgroundColor,
                        borderWidth: e.borderWidth,
                        borderDash: e.borderDash,
                        borderDashOffset: e.borderDashOffset,
                        borderRadius: 0
                    }
                },
                labelTextColor() {
                    return this.options.bodyColor
                },
                labelPointStyle(t) {
                    const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
                    return {
                        pointStyle: e.pointStyle,
                        rotation: e.rotation
                    }
                },
                afterLabel: La,
                afterBody: La,
                beforeFooter: La,
                footer: La,
                afterFooter: La
            }
        },
        defaultRoutes: {
            bodyFont: "font",
            footerFont: "font",
            titleFont: "font"
        },
        descriptors: {
            _scriptable: t => "filter" !== t && "itemSort" !== t && "external" !== t,
            _indexable: !1,
            callbacks: {
                _scriptable: !1,
                _indexable: !1
            },
            animation: {
                _fallback: !1
            },
            animations: {
                _fallback: "animation"
            }
        },
        additionalOptionScopes: ["interaction"]
    };
    function pp(t, e, i, n) {
        const s = t.indexOf(e);
        if (-1 === s)
            return ( (t, e, i, n) => ("string" == typeof e ? (i = t.push(e) - 1,
            n.unshift({
                index: i,
                label: e
            })) : isNaN(e) && (i = null),
            i))(t, e, i, n);
        return s !== t.lastIndexOf(e) ? i : s
    }
    class fp extends zc {
        constructor(t) {
            super(t),
            this._startValue = void 0,
            this._valueRange = 0,
            this._addedLabels = []
        }
        init(t) {
            const e = this._addedLabels;
            if (e.length) {
                const t = this.getLabels();
                for (const {index: i, label: n} of e)
                    t[i] === n && t.splice(i, 1);
                this._addedLabels = []
            }
            super.init(t)
        }
        parse(t, e) {
            if (Ra(t))
                return null;
            const i = this.getLabels();
            return ( (t, e) => null === t ? null : Tr(Math.round(t), 0, e))(e = isFinite(e) && i[e] === t ? e : pp(i, t, za(e, t), this._addedLabels), i.length - 1)
        }
        determineDataLimits() {
            const {minDefined: t, maxDefined: e} = this.getUserBounds();
            let {min: i, max: n} = this.getMinMax(!0);
            "ticks" === this.options.bounds && (t || (i = 0),
            e || (n = this.getLabels().length - 1)),
            this.min = i,
            this.max = n
        }
        buildTicks() {
            const t = this.min
              , e = this.max
              , i = this.options.offset
              , n = [];
            let s = this.getLabels();
            s = 0 === t && e === s.length - 1 ? s : s.slice(t, e + 1),
            this._valueRange = Math.max(s.length - (i ? 0 : 1), 1),
            this._startValue = this.min - (i ? .5 : 0);
            for (let o = t; o <= e; o++)
                n.push({
                    value: o
                });
            return n
        }
        getLabelForValue(t) {
            const e = this.getLabels();
            return t >= 0 && t < e.length ? e[t] : t
        }
        configure() {
            super.configure(),
            this.isHorizontal() || (this._reversePixels = !this._reversePixels)
        }
        getPixelForValue(t) {
            return "number" != typeof t && (t = this.parse(t)),
            null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
        }
        getPixelForTick(t) {
            const e = this.ticks;
            return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
        }
        getValueForPixel(t) {
            return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange)
        }
        getBasePixel() {
            return this.bottom
        }
    }
    function gp(t, e) {
        const i = []
          , {bounds: n, step: s, min: o, max: a, precision: r, count: l, maxTicks: h, maxDigits: c, includeBounds: d} = t
          , u = s || 1
          , p = h - 1
          , {min: f, max: g} = e
          , m = !Ra(o)
          , _ = !Ra(a)
          , b = !Ra(l)
          , v = (g - f) / (c + 1);
        let y, x, w, C, k = fr((g - f) / p / u) * u;
        if (k < 1e-14 && !m && !_)
            return [{
                value: f
            }, {
                value: g
            }];
        C = Math.ceil(g / k) - Math.floor(f / k),
        C > p && (k = fr(C * k / p / u) * u),
        Ra(r) || (y = Math.pow(10, r),
        k = Math.ceil(k * y) / y),
        "ticks" === n ? (x = Math.floor(f / k) * k,
        w = Math.ceil(g / k) * k) : (x = f,
        w = g),
        m && _ && s && function(t, e) {
            const i = Math.round(t);
            return i - e <= t && i + e >= t
        }((a - o) / s, k / 1e3) ? (C = Math.round(Math.min((a - o) / k, h)),
        k = (a - o) / C,
        x = o,
        w = a) : b ? (x = m ? o : x,
        w = _ ? a : w,
        C = l - 1,
        k = (w - x) / C) : (C = (w - x) / k,
        C = mr(C, Math.round(C), k / 1e3) ? Math.round(C) : Math.ceil(C));
        const S = Math.max(yr(k), yr(x));
        y = Math.pow(10, Ra(r) ? S : r),
        x = Math.round(x * y) / y,
        w = Math.round(w * y) / y;
        let T = 0;
        for (m && (d && x !== o ? (i.push({
            value: o
        }),
        x < o && T++,
        mr(Math.round((x + T * k) * y) / y, o, mp(o, v, t)) && T++) : x < o && T++); T < C; ++T)
            i.push({
                value: Math.round((x + T * k) * y) / y
            });
        return _ && d && w !== a ? i.length && mr(i[i.length - 1].value, a, mp(a, v, t)) ? i[i.length - 1].value = a : i.push({
            value: a
        }) : _ && w !== a || i.push({
            value: w
        }),
        i
    }
    function mp(t, e, {horizontal: i, minRotation: n}) {
        const s = br(n)
          , o = (i ? Math.sin(s) : Math.cos(s)) || .001
          , a = .75 * e * ("" + t).length;
        return Math.min(e / o, a)
    }
    fp.id = "category",
    fp.defaults = {
        ticks: {
            callback: fp.prototype.getLabelForValue
        }
    };
    class _p extends zc {
        constructor(t) {
            super(t),
            this.start = void 0,
            this.end = void 0,
            this._startValue = void 0,
            this._endValue = void 0,
            this._valueRange = 0
        }
        parse(t, e) {
            return Ra(t) || ("number" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t
        }
        handleTickRangeOptions() {
            const {beginAtZero: t} = this.options
              , {minDefined: e, maxDefined: i} = this.getUserBounds();
            let {min: n, max: s} = this;
            const o = t => n = e ? n : t
              , a = t => s = i ? s : t;
            if (t) {
                const t = pr(n)
                  , e = pr(s);
                t < 0 && e < 0 ? a(0) : t > 0 && e > 0 && o(0)
            }
            if (n === s) {
                let e = 1;
                (s >= Number.MAX_SAFE_INTEGER || n <= Number.MIN_SAFE_INTEGER) && (e = Math.abs(.05 * s)),
                a(s + e),
                t || o(n - e)
            }
            this.min = n,
            this.max = s
        }
        getTickLimit() {
            const t = this.options.ticks;
            let e, {maxTicksLimit: i, stepSize: n} = t;
            return n ? (e = Math.ceil(this.max / n) - Math.floor(this.min / n) + 1,
            e > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${n} would result generating up to ${e} ticks. Limiting to 1000.`),
            e = 1e3)) : (e = this.computeTickLimit(),
            i = i || 11),
            i && (e = Math.min(i, e)),
            e
        }
        computeTickLimit() {
            return Number.POSITIVE_INFINITY
        }
        buildTicks() {
            const t = this.options
              , e = t.ticks;
            let i = this.getTickLimit();
            i = Math.max(2, i);
            const n = gp({
                maxTicks: i,
                bounds: t.bounds,
                min: t.min,
                max: t.max,
                precision: e.precision,
                step: e.stepSize,
                count: e.count,
                maxDigits: this._maxDigits(),
                horizontal: this.isHorizontal(),
                minRotation: e.minRotation || 0,
                includeBounds: !1 !== e.includeBounds
            }, this._range || this);
            return "ticks" === t.bounds && _r(n, this, "value"),
            t.reverse ? (n.reverse(),
            this.start = this.max,
            this.end = this.min) : (this.start = this.min,
            this.end = this.max),
            n
        }
        configure() {
            const t = this.ticks;
            let e = this.min
              , i = this.max;
            if (super.configure(),
            this.options.offset && t.length) {
                const n = (i - e) / Math.max(t.length - 1, 1) / 2;
                e -= n,
                i += n
            }
            this._startValue = e,
            this._endValue = i,
            this._valueRange = i - e
        }
        getLabelForValue(t) {
            return Fh(t, this.chart.options.locale, this.options.ticks.format)
        }
    }
    class bp extends _p {
        determineDataLimits() {
            const {min: t, max: e} = this.getMinMax(!0);
            this.min = Ha(t) ? t : 0,
            this.max = Ha(e) ? e : 1,
            this.handleTickRangeOptions()
        }
        computeTickLimit() {
            const t = this.isHorizontal()
              , e = t ? this.width : this.height
              , i = br(this.options.ticks.minRotation)
              , n = (t ? Math.sin(i) : Math.cos(i)) || .001
              , s = this._resolveTickFontOptions(0);
            return Math.ceil(e / Math.min(40, s.lineHeight / n))
        }
        getPixelForValue(t) {
            return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
        }
        getValueForPixel(t) {
            return this._startValue + this.getDecimalForPixel(t) * this._valueRange
        }
    }
    function vp(t) {
        return 1 === t / Math.pow(10, Math.floor(ur(t)))
    }
    bp.id = "linear",
    bp.defaults = {
        ticks: {
            callback: $c.formatters.numeric
        }
    };
    class yp extends zc {
        constructor(t) {
            super(t),
            this.start = void 0,
            this.end = void 0,
            this._startValue = void 0,
            this._valueRange = 0
        }
        parse(t, e) {
            const i = _p.prototype.parse.apply(this, [t, e]);
            if (0 !== i)
                return Ha(i) && i > 0 ? i : null;
            this._zero = !0
        }
        determineDataLimits() {
            const {min: t, max: e} = this.getMinMax(!0);
            this.min = Ha(t) ? Math.max(0, t) : null,
            this.max = Ha(e) ? Math.max(0, e) : null,
            this.options.beginAtZero && (this._zero = !0),
            this.handleTickRangeOptions()
        }
        handleTickRangeOptions() {
            const {minDefined: t, maxDefined: e} = this.getUserBounds();
            let i = this.min
              , n = this.max;
            const s = e => i = t ? i : e
              , o = t => n = e ? n : t
              , a = (t, e) => Math.pow(10, Math.floor(ur(t)) + e);
            i === n && (i <= 0 ? (s(1),
            o(10)) : (s(a(i, -1)),
            o(a(n, 1)))),
            i <= 0 && s(a(n, -1)),
            n <= 0 && o(a(i, 1)),
            this._zero && this.min !== this._suggestedMin && i === a(this.min, 0) && s(a(i, -1)),
            this.min = i,
            this.max = n
        }
        buildTicks() {
            const t = this.options
              , e = function(t, e) {
                const i = Math.floor(ur(e.max))
                  , n = Math.ceil(e.max / Math.pow(10, i))
                  , s = [];
                let o = Fa(t.min, Math.pow(10, Math.floor(ur(e.min))))
                  , a = Math.floor(ur(o))
                  , r = Math.floor(o / Math.pow(10, a))
                  , l = a < 0 ? Math.pow(10, Math.abs(a)) : 1;
                do {
                    s.push({
                        value: o,
                        major: vp(o)
                    }),
                    ++r,
                    10 === r && (r = 1,
                    ++a,
                    l = a >= 0 ? 1 : l),
                    o = Math.round(r * Math.pow(10, a) * l) / l
                } while (a < i || a === i && r < n);
                const h = Fa(t.max, o);
                return s.push({
                    value: h,
                    major: vp(o)
                }),
                s
            }({
                min: this._userMin,
                max: this._userMax
            }, this);
            return "ticks" === t.bounds && _r(e, this, "value"),
            t.reverse ? (e.reverse(),
            this.start = this.max,
            this.end = this.min) : (this.start = this.min,
            this.end = this.max),
            e
        }
        getLabelForValue(t) {
            return void 0 === t ? "0" : Fh(t, this.chart.options.locale, this.options.ticks.format)
        }
        configure() {
            const t = this.min;
            super.configure(),
            this._startValue = ur(t),
            this._valueRange = ur(this.max) - ur(t)
        }
        getPixelForValue(t) {
            return void 0 !== t && 0 !== t || (t = this.min),
            null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (ur(t) - this._startValue) / this._valueRange)
        }
        getValueForPixel(t) {
            const e = this.getDecimalForPixel(t);
            return Math.pow(10, this._startValue + e * this._valueRange)
        }
    }
    function xp(t) {
        const e = t.ticks;
        if (e.display && t.display) {
            const t = Jl(e.backdropPadding);
            return za(e.font && e.font.size, Dl.font.size) + t.height
        }
        return 0
    }
    function wp(t, e, i) {
        return i = Na(i) ? i : [i],
        {
            w: Il(t, e.string, i),
            h: i.length * e.lineHeight
        }
    }
    function Cp(t, e, i, n, s) {
        return t === n || t === s ? {
            start: e - i / 2,
            end: e + i / 2
        } : t < n || t > s ? {
            start: e - i,
            end: e
        } : {
            start: e,
            end: e + i
        }
    }
    function kp(t) {
        const e = {
            l: t.left + t._padding.left,
            r: t.right - t._padding.right,
            t: t.top + t._padding.top,
            b: t.bottom - t._padding.bottom
        }
          , i = Object.assign({}, e)
          , n = []
          , s = []
          , o = t._pointLabels.length
          , a = t.options.pointLabels
          , r = a.centerPointLabels ? sr / o : 0;
        for (let l = 0; l < o; l++) {
            const o = a.setContext(t.getPointLabelContext(l));
            s[l] = o.padding;
            const h = t.getPointPosition(l, t.drawingArea + s[l], r)
              , c = th(o.font)
              , d = wp(t.ctx, c, t._pointLabels[l]);
            n[l] = d;
            const u = kr(t.getIndexAngle(l) + r)
              , p = Math.round(vr(u));
            Sp(i, e, u, Cp(p, h.x, d.w, 0, 180), Cp(p, h.y, d.h, 90, 270))
        }
        t.setCenterPoint(e.l - i.l, i.r - e.r, e.t - i.t, i.b - e.b),
        t._pointLabelItems = function(t, e, i) {
            const n = []
              , s = t._pointLabels.length
              , o = t.options
              , a = xp(o) / 2
              , r = t.drawingArea
              , l = o.pointLabels.centerPointLabels ? sr / s : 0;
            for (let h = 0; h < s; h++) {
                const s = t.getPointPosition(h, r + a + i[h], l)
                  , o = Math.round(vr(kr(s.angle + hr)))
                  , c = e[h]
                  , d = Ep(s.y, c.h, o)
                  , u = Tp(o)
                  , p = Ap(s.x, c.w, u);
                n.push({
                    x: s.x,
                    y: d,
                    textAlign: u,
                    left: p,
                    top: d,
                    right: p + c.w,
                    bottom: d + c.h
                })
            }
            return n
        }(t, n, s)
    }
    function Sp(t, e, i, n, s) {
        const o = Math.abs(Math.sin(i))
          , a = Math.abs(Math.cos(i));
        let r = 0
          , l = 0;
        n.start < e.l ? (r = (e.l - n.start) / o,
        t.l = Math.min(t.l, e.l - r)) : n.end > e.r && (r = (n.end - e.r) / o,
        t.r = Math.max(t.r, e.r + r)),
        s.start < e.t ? (l = (e.t - s.start) / a,
        t.t = Math.min(t.t, e.t - l)) : s.end > e.b && (l = (s.end - e.b) / a,
        t.b = Math.max(t.b, e.b + l))
    }
    function Tp(t) {
        return 0 === t || 180 === t ? "center" : t < 180 ? "left" : "right"
    }
    function Ap(t, e, i) {
        return "right" === i ? t -= e : "center" === i && (t -= e / 2),
        t
    }
    function Ep(t, e, i) {
        return 90 === i || 270 === i ? t -= e / 2 : (i > 270 || i < 90) && (t -= e),
        t
    }
    function Mp(t, e, i, n) {
        const {ctx: s} = t;
        if (i)
            s.arc(t.xCenter, t.yCenter, e, 0, or);
        else {
            let i = t.getPointPosition(0, e);
            s.moveTo(i.x, i.y);
            for (let o = 1; o < n; o++)
                i = t.getPointPosition(o, e),
                s.lineTo(i.x, i.y)
        }
    }
    yp.id = "logarithmic",
    yp.defaults = {
        ticks: {
            callback: $c.formatters.logarithmic,
            major: {
                enabled: !0
            }
        }
    };
    class Op extends _p {
        constructor(t) {
            super(t),
            this.xCenter = void 0,
            this.yCenter = void 0,
            this.drawingArea = void 0,
            this._pointLabels = [],
            this._pointLabelItems = []
        }
        setDimensions() {
            const t = this._padding = Jl(xp(this.options) / 2)
              , e = this.width = this.maxWidth - t.width
              , i = this.height = this.maxHeight - t.height;
            this.xCenter = Math.floor(this.left + e / 2 + t.left),
            this.yCenter = Math.floor(this.top + i / 2 + t.top),
            this.drawingArea = Math.floor(Math.min(e, i) / 2)
        }
        determineDataLimits() {
            const {min: t, max: e} = this.getMinMax(!1);
            this.min = Ha(t) && !isNaN(t) ? t : 0,
            this.max = Ha(e) && !isNaN(e) ? e : 0,
            this.handleTickRangeOptions()
        }
        computeTickLimit() {
            return Math.ceil(this.drawingArea / xp(this.options))
        }
        generateTickLabels(t) {
            _p.prototype.generateTickLabels.call(this, t),
            this._pointLabels = this.getLabels().map( (t, e) => {
                const i = Wa(this.options.pointLabels.callback, [t, e], this);
                return i || 0 === i ? i : ""
            }
            ).filter( (t, e) => this.chart.getDataVisibility(e))
        }
        fit() {
            const t = this.options;
            t.display && t.pointLabels.display ? kp(this) : this.setCenterPoint(0, 0, 0, 0)
        }
        setCenterPoint(t, e, i, n) {
            this.xCenter += Math.floor((t - e) / 2),
            this.yCenter += Math.floor((i - n) / 2),
            this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, n))
        }
        getIndexAngle(t) {
            return kr(t * (or / (this._pointLabels.length || 1)) + br(this.options.startAngle || 0))
        }
        getDistanceFromCenterForValue(t) {
            if (Ra(t))
                return NaN;
            const e = this.drawingArea / (this.max - this.min);
            return this.options.reverse ? (this.max - t) * e : (t - this.min) * e
        }
        getValueForDistanceFromCenter(t) {
            if (Ra(t))
                return NaN;
            const e = t / (this.drawingArea / (this.max - this.min));
            return this.options.reverse ? this.max - e : this.min + e
        }
        getPointLabelContext(t) {
            const e = this._pointLabels || [];
            if (t >= 0 && t < e.length) {
                const i = e[t];
                return function(t, e, i) {
                    return ih(t, {
                        label: i,
                        index: e,
                        type: "pointLabel"
                    })
                }(this.getContext(), t, i)
            }
        }
        getPointPosition(t, e, i=0) {
            const n = this.getIndexAngle(t) - hr + i;
            return {
                x: Math.cos(n) * e + this.xCenter,
                y: Math.sin(n) * e + this.yCenter,
                angle: n
            }
        }
        getPointPositionForValue(t, e) {
            return this.getPointPosition(t, this.getDistanceFromCenterForValue(e))
        }
        getBasePosition(t) {
            return this.getPointPositionForValue(t || 0, this.getBaseValue())
        }
        getPointLabelPosition(t) {
            const {left: e, top: i, right: n, bottom: s} = this._pointLabelItems[t];
            return {
                left: e,
                top: i,
                right: n,
                bottom: s
            }
        }
        drawBackground() {
            const {backgroundColor: t, grid: {circular: e}} = this.options;
            if (t) {
                const i = this.ctx;
                i.save(),
                i.beginPath(),
                Mp(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length),
                i.closePath(),
                i.fillStyle = t,
                i.fill(),
                i.restore()
            }
        }
        drawGrid() {
            const t = this.ctx
              , e = this.options
              , {angleLines: i, grid: n} = e
              , s = this._pointLabels.length;
            let o, a, r;
            if (e.pointLabels.display && function(t, e) {
                const {ctx: i, options: {pointLabels: n}} = t;
                for (let s = e - 1; s >= 0; s--) {
                    const e = n.setContext(t.getPointLabelContext(s))
                      , o = th(e.font)
                      , {x: a, y: r, textAlign: l, left: h, top: c, right: d, bottom: u} = t._pointLabelItems[s]
                      , {backdropColor: p} = e;
                    if (!Ra(p)) {
                        const t = Ql(e.borderRadius)
                          , n = Jl(e.backdropPadding);
                        i.fillStyle = p;
                        const s = h - n.left
                          , o = c - n.top
                          , a = d - h + n.width
                          , r = u - c + n.height;
                        Object.values(t).some(t => 0 !== t) ? (i.beginPath(),
                        Yl(i, {
                            x: s,
                            y: o,
                            w: a,
                            h: r,
                            radius: t
                        }),
                        i.fill()) : i.fillRect(s, o, a, r)
                    }
                    Wl(i, t._pointLabels[s], a, r + o.lineHeight / 2, o, {
                        color: e.color,
                        textAlign: l,
                        textBaseline: "middle"
                    })
                }
            }(this, s),
            n.display && this.ticks.forEach( (t, e) => {
                if (0 !== e) {
                    a = this.getDistanceFromCenterForValue(t.value);
                    !function(t, e, i, n) {
                        const s = t.ctx
                          , o = e.circular
                          , {color: a, lineWidth: r} = e;
                        !o && !n || !a || !r || i < 0 || (s.save(),
                        s.strokeStyle = a,
                        s.lineWidth = r,
                        s.setLineDash(e.borderDash),
                        s.lineDashOffset = e.borderDashOffset,
                        s.beginPath(),
                        Mp(t, i, o, n),
                        s.closePath(),
                        s.stroke(),
                        s.restore())
                    }(this, n.setContext(this.getContext(e - 1)), a, s)
                }
            }
            ),
            i.display) {
                for (t.save(),
                o = s - 1; o >= 0; o--) {
                    const n = i.setContext(this.getPointLabelContext(o))
                      , {color: s, lineWidth: l} = n;
                    l && s && (t.lineWidth = l,
                    t.strokeStyle = s,
                    t.setLineDash(n.borderDash),
                    t.lineDashOffset = n.borderDashOffset,
                    a = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max),
                    r = this.getPointPosition(o, a),
                    t.beginPath(),
                    t.moveTo(this.xCenter, this.yCenter),
                    t.lineTo(r.x, r.y),
                    t.stroke())
                }
                t.restore()
            }
        }
        drawBorder() {}
        drawLabels() {
            const t = this.ctx
              , e = this.options
              , i = e.ticks;
            if (!i.display)
                return;
            const n = this.getIndexAngle(0);
            let s, o;
            t.save(),
            t.translate(this.xCenter, this.yCenter),
            t.rotate(n),
            t.textAlign = "center",
            t.textBaseline = "middle",
            this.ticks.forEach( (n, a) => {
                if (0 === a && !e.reverse)
                    return;
                const r = i.setContext(this.getContext(a))
                  , l = th(r.font);
                if (s = this.getDistanceFromCenterForValue(this.ticks[a].value),
                r.showLabelBackdrop) {
                    t.font = l.string,
                    o = t.measureText(n.label).width,
                    t.fillStyle = r.backdropColor;
                    const e = Jl(r.backdropPadding);
                    t.fillRect(-o / 2 - e.left, -s - l.size / 2 - e.top, o + e.width, l.size + e.height)
                }
                Wl(t, n.label, 0, -s, l, {
                    color: r.color
                })
            }
            ),
            t.restore()
        }
        drawTitle() {}
    }
    Op.id = "radialLinear",
    Op.defaults = {
        display: !0,
        animate: !0,
        position: "chartArea",
        angleLines: {
            display: !0,
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0
        },
        grid: {
            circular: !1
        },
        startAngle: 0,
        ticks: {
            showLabelBackdrop: !0,
            callback: $c.formatters.numeric
        },
        pointLabels: {
            backdropColor: void 0,
            backdropPadding: 2,
            display: !0,
            font: {
                size: 10
            },
            callback: t => t,
            padding: 5,
            centerPointLabels: !1
        }
    },
    Op.defaultRoutes = {
        "angleLines.color": "borderColor",
        "pointLabels.color": "color",
        "ticks.color": "color"
    },
    Op.descriptors = {
        angleLines: {
            _fallback: "grid"
        }
    };
    const Dp = {
        millisecond: {
            common: !0,
            size: 1,
            steps: 1e3
        },
        second: {
            common: !0,
            size: 1e3,
            steps: 60
        },
        minute: {
            common: !0,
            size: 6e4,
            steps: 60
        },
        hour: {
            common: !0,
            size: 36e5,
            steps: 24
        },
        day: {
            common: !0,
            size: 864e5,
            steps: 30
        },
        week: {
            common: !1,
            size: 6048e5,
            steps: 4
        },
        month: {
            common: !0,
            size: 2628e6,
            steps: 12
        },
        quarter: {
            common: !1,
            size: 7884e6,
            steps: 4
        },
        year: {
            common: !0,
            size: 3154e7
        }
    }
      , $p = Object.keys(Dp);
    function Ip(t, e) {
        return t - e
    }
    function Lp(t, e) {
        if (Ra(e))
            return null;
        const i = t._adapter
          , {parser: n, round: s, isoWeekday: o} = t._parseOpts;
        let a = e;
        return "function" == typeof n && (a = n(a)),
        Ha(a) || (a = "string" == typeof n ? i.parse(a, n) : i.parse(a)),
        null === a ? null : (s && (a = "week" !== s || !gr(o) && !0 !== o ? i.startOf(a, s) : i.startOf(a, "isoWeek", o)),
        +a)
    }
    function Pp(t, e, i, n) {
        const s = $p.length;
        for (let o = $p.indexOf(t); o < s - 1; ++o) {
            const t = Dp[$p[o]]
              , s = t.steps ? t.steps : Number.MAX_SAFE_INTEGER;
            if (t.common && Math.ceil((i - e) / (s * t.size)) <= n)
                return $p[o]
        }
        return $p[s - 1]
    }
    function Rp(t, e, i) {
        if (i) {
            if (i.length) {
                const {lo: n, hi: s} = Er(i, e);
                t[i[n] >= e ? i[n] : i[s]] = !0
            }
        } else
            t[e] = !0
    }
    function Np(t, e, i) {
        const n = []
          , s = {}
          , o = e.length;
        let a, r;
        for (a = 0; a < o; ++a)
            r = e[a],
            s[r] = a,
            n.push({
                value: r,
                major: !1
            });
        return 0 !== o && i ? function(t, e, i, n) {
            const s = t._adapter
              , o = +s.startOf(e[0].value, n)
              , a = e[e.length - 1].value;
            let r, l;
            for (r = o; r <= a; r = +s.add(r, 1, n))
                l = i[r],
                l >= 0 && (e[l].major = !0);
            return e
        }(t, n, s, i) : n
    }
    class Bp extends zc {
        constructor(t) {
            super(t),
            this._cache = {
                data: [],
                labels: [],
                all: []
            },
            this._unit = "day",
            this._majorUnit = void 0,
            this._offsets = {},
            this._normalized = !1,
            this._parseOpts = void 0
        }
        init(t, e) {
            const i = t.time || (t.time = {})
              , n = this._adapter = new Kc._date(t.adapters.date);
            n.init(e),
            Za(i.displayFormats, n.formats()),
            this._parseOpts = {
                parser: i.parser,
                round: i.round,
                isoWeekday: i.isoWeekday
            },
            super.init(t),
            this._normalized = e.normalized
        }
        parse(t, e) {
            return void 0 === t ? null : Lp(this, t)
        }
        beforeLayout() {
            super.beforeLayout(),
            this._cache = {
                data: [],
                labels: [],
                all: []
            }
        }
        determineDataLimits() {
            const t = this.options
              , e = this._adapter
              , i = t.time.unit || "day";
            let {min: n, max: s, minDefined: o, maxDefined: a} = this.getUserBounds();
            function r(t) {
                o || isNaN(t.min) || (n = Math.min(n, t.min)),
                a || isNaN(t.max) || (s = Math.max(s, t.max))
            }
            o && a || (r(this._getLabelBounds()),
            "ticks" === t.bounds && "labels" === t.ticks.source || r(this.getMinMax(!1))),
            n = Ha(n) && !isNaN(n) ? n : +e.startOf(Date.now(), i),
            s = Ha(s) && !isNaN(s) ? s : +e.endOf(Date.now(), i) + 1,
            this.min = Math.min(n, s - 1),
            this.max = Math.max(n + 1, s)
        }
        _getLabelBounds() {
            const t = this.getLabelTimestamps();
            let e = Number.POSITIVE_INFINITY
              , i = Number.NEGATIVE_INFINITY;
            return t.length && (e = t[0],
            i = t[t.length - 1]),
            {
                min: e,
                max: i
            }
        }
        buildTicks() {
            const t = this.options
              , e = t.time
              , i = t.ticks
              , n = "labels" === i.source ? this.getLabelTimestamps() : this._generate();
            "ticks" === t.bounds && n.length && (this.min = this._userMin || n[0],
            this.max = this._userMax || n[n.length - 1]);
            const s = this.min
              , o = function(t, e, i) {
                let n = 0
                  , s = t.length;
                for (; n < s && t[n] < e; )
                    n++;
                for (; s > n && t[s - 1] > i; )
                    s--;
                return n > 0 || s < t.length ? t.slice(n, s) : t
            }(n, s, this.max);
            return this._unit = e.unit || (i.autoSkip ? Pp(e.minUnit, this.min, this.max, this._getLabelCapacity(s)) : function(t, e, i, n, s) {
                for (let o = $p.length - 1; o >= $p.indexOf(i); o--) {
                    const i = $p[o];
                    if (Dp[i].common && t._adapter.diff(s, n, i) >= e - 1)
                        return i
                }
                return $p[i ? $p.indexOf(i) : 0]
            }(this, o.length, e.minUnit, this.min, this.max)),
            this._majorUnit = i.major.enabled && "year" !== this._unit ? function(t) {
                for (let e = $p.indexOf(t) + 1, i = $p.length; e < i; ++e)
                    if (Dp[$p[e]].common)
                        return $p[e]
            }(this._unit) : void 0,
            this.initOffsets(n),
            t.reverse && o.reverse(),
            Np(this, o, this._majorUnit)
        }
        afterAutoSkip() {
            this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(t => +t.value))
        }
        initOffsets(t) {
            let e, i, n = 0, s = 0;
            this.options.offset && t.length && (e = this.getDecimalForValue(t[0]),
            n = 1 === t.length ? 1 - e : (this.getDecimalForValue(t[1]) - e) / 2,
            i = this.getDecimalForValue(t[t.length - 1]),
            s = 1 === t.length ? i : (i - this.getDecimalForValue(t[t.length - 2])) / 2);
            const o = t.length < 3 ? .5 : .25;
            n = Tr(n, 0, o),
            s = Tr(s, 0, o),
            this._offsets = {
                start: n,
                end: s,
                factor: 1 / (n + 1 + s)
            }
        }
        _generate() {
            const t = this._adapter
              , e = this.min
              , i = this.max
              , n = this.options
              , s = n.time
              , o = s.unit || Pp(s.minUnit, e, i, this._getLabelCapacity(e))
              , a = za(s.stepSize, 1)
              , r = "week" === o && s.isoWeekday
              , l = gr(r) || !0 === r
              , h = {};
            let c, d, u = e;
            if (l && (u = +t.startOf(u, "isoWeek", r)),
            u = +t.startOf(u, l ? "day" : o),
            t.diff(i, e, o) > 1e5 * a)
                throw new Error(e + " and " + i + " are too far apart with stepSize of " + a + " " + o);
            const p = "data" === n.ticks.source && this.getDataTimestamps();
            for (c = u,
            d = 0; c < i; c = +t.add(c, a, o),
            d++)
                Rp(h, c, p);
            return c !== i && "ticks" !== n.bounds && 1 !== d || Rp(h, c, p),
            Object.keys(h).sort( (t, e) => t - e).map(t => +t)
        }
        getLabelForValue(t) {
            const e = this._adapter
              , i = this.options.time;
            return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime)
        }
        _tickFormatFunction(t, e, i, n) {
            const s = this.options
              , o = s.time.displayFormats
              , a = this._unit
              , r = this._majorUnit
              , l = a && o[a]
              , h = r && o[r]
              , c = i[e]
              , d = r && h && c && c.major
              , u = this._adapter.format(t, n || (d ? h : l))
              , p = s.ticks.callback;
            return p ? Wa(p, [u, e, i], this) : u
        }
        generateTickLabels(t) {
            let e, i, n;
            for (e = 0,
            i = t.length; e < i; ++e)
                n = t[e],
                n.label = this._tickFormatFunction(n.value, e, t)
        }
        getDecimalForValue(t) {
            return null === t ? NaN : (t - this.min) / (this.max - this.min)
        }
        getPixelForValue(t) {
            const e = this._offsets
              , i = this.getDecimalForValue(t);
            return this.getPixelForDecimal((e.start + i) * e.factor)
        }
        getValueForPixel(t) {
            const e = this._offsets
              , i = this.getDecimalForPixel(t) / e.factor - e.end;
            return this.min + i * (this.max - this.min)
        }
        _getLabelSize(t) {
            const e = this.options.ticks
              , i = this.ctx.measureText(t).width
              , n = br(this.isHorizontal() ? e.maxRotation : e.minRotation)
              , s = Math.cos(n)
              , o = Math.sin(n)
              , a = this._resolveTickFontOptions(0).size;
            return {
                w: i * s + a * o,
                h: i * o + a * s
            }
        }
        _getLabelCapacity(t) {
            const e = this.options.time
              , i = e.displayFormats
              , n = i[e.unit] || i.millisecond
              , s = this._tickFormatFunction(t, 0, Np(this, [t], this._majorUnit), n)
              , o = this._getLabelSize(s)
              , a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;
            return a > 0 ? a : 1
        }
        getDataTimestamps() {
            let t, e, i = this._cache.data || [];
            if (i.length)
                return i;
            const n = this.getMatchingVisibleMetas();
            if (this._normalized && n.length)
                return this._cache.data = n[0].controller.getAllParsedValues(this);
            for (t = 0,
            e = n.length; t < e; ++t)
                i = i.concat(n[t].controller.getAllParsedValues(this));
            return this._cache.data = this.normalize(i)
        }
        getLabelTimestamps() {
            const t = this._cache.labels || [];
            let e, i;
            if (t.length)
                return t;
            const n = this.getLabels();
            for (e = 0,
            i = n.length; e < i; ++e)
                t.push(Lp(this, n[e]));
            return this._cache.labels = this._normalized ? t : this.normalize(t)
        }
        normalize(t) {
            return Ir(t.sort(Ip))
        }
    }
    function Hp(t, e, i) {
        let n, s, o, a, r = 0, l = t.length - 1;
        i ? (e >= t[r].pos && e <= t[l].pos && ({lo: r, hi: l} = Mr(t, "pos", e)),
        ({pos: n, time: o} = t[r]),
        ({pos: s, time: a} = t[l])) : (e >= t[r].time && e <= t[l].time && ({lo: r, hi: l} = Mr(t, "time", e)),
        ({time: n, pos: o} = t[r]),
        ({time: s, pos: a} = t[l]));
        const h = s - n;
        return h ? o + (a - o) * (e - n) / h : o
    }
    Bp.id = "time",
    Bp.defaults = {
        bounds: "data",
        adapters: {},
        time: {
            parser: !1,
            unit: !1,
            round: !1,
            isoWeekday: !1,
            minUnit: "millisecond",
            displayFormats: {}
        },
        ticks: {
            source: "auto",
            major: {
                enabled: !1
            }
        }
    };
    class Fp extends Bp {
        constructor(t) {
            super(t),
            this._table = [],
            this._minPos = void 0,
            this._tableRange = void 0
        }
        initOffsets() {
            const t = this._getTimestampsForTable()
              , e = this._table = this.buildLookupTable(t);
            this._minPos = Hp(e, this.min),
            this._tableRange = Hp(e, this.max) - this._minPos,
            super.initOffsets(t)
        }
        buildLookupTable(t) {
            const {min: e, max: i} = this
              , n = []
              , s = [];
            let o, a, r, l, h;
            for (o = 0,
            a = t.length; o < a; ++o)
                l = t[o],
                l >= e && l <= i && n.push(l);
            if (n.length < 2)
                return [{
                    time: e,
                    pos: 0
                }, {
                    time: i,
                    pos: 1
                }];
            for (o = 0,
            a = n.length; o < a; ++o)
                h = n[o + 1],
                r = n[o - 1],
                l = n[o],
                Math.round((h + r) / 2) !== l && s.push({
                    time: l,
                    pos: o / (a - 1)
                });
            return s
        }
        _getTimestampsForTable() {
            let t = this._cache.all || [];
            if (t.length)
                return t;
            const e = this.getDataTimestamps()
              , i = this.getLabelTimestamps();
            return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i,
            t = this._cache.all = t,
            t
        }
        getDecimalForValue(t) {
            return (Hp(this._table, t) - this._minPos) / this._tableRange
        }
        getValueForPixel(t) {
            const e = this._offsets
              , i = this.getDecimalForPixel(t) / e.factor - e.end;
            return Hp(this._table, i * this._tableRange + this._minPos, !0)
        }
    }
    function zp(t) {
        return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
    }
    Fp.id = "timeseries",
    Fp.defaults = Bp.defaults;
    var jp = function(t) {
        return function(t) {
            return !!t && "object" == typeof t
        }(t) && !function(t) {
            var e = Object.prototype.toString.call(t);
            return "[object RegExp]" === e || "[object Date]" === e || function(t) {
                return t.$$typeof === Wp
            }(t)
        }(t)
    };
    var Wp = "function" == typeof Symbol && Symbol.for ? Symbol.for("react.element") : 60103;
    function Vp(t, e) {
        return !1 !== e.clone && e.isMergeableObject(t) ? qp((i = t,
        Array.isArray(i) ? [] : {}), t, e) : t;
        var i
    }
    function Yp(t, e, i) {
        return t.concat(e).map(function(t) {
            return Vp(t, i)
        })
    }
    function Xp(t) {
        return Object.keys(t).concat(function(t) {
            return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(t).filter(function(e) {
                return Object.propertyIsEnumerable.call(t, e)
            }) : []
        }(t))
    }
    function Kp(t, e) {
        try {
            return e in t
        } catch (i) {
            return !1
        }
    }
    function Up(t, e, i) {
        var n = {};
        return i.isMergeableObject(t) && Xp(t).forEach(function(e) {
            n[e] = Vp(t[e], i)
        }),
        Xp(e).forEach(function(s) {
            (function(t, e) {
                return Kp(t, e) && !(Object.hasOwnProperty.call(t, e) && Object.propertyIsEnumerable.call(t, e))
            }
            )(t, s) || (Kp(t, s) && i.isMergeableObject(e[s]) ? n[s] = function(t, e) {
                if (!e.customMerge)
                    return qp;
                var i = e.customMerge(t);
                return "function" == typeof i ? i : qp
            }(s, i)(t[s], e[s], i) : n[s] = Vp(e[s], i))
        }),
        n
    }
    function qp(t, e, i) {
        (i = i || {}).arrayMerge = i.arrayMerge || Yp,
        i.isMergeableObject = i.isMergeableObject || jp,
        i.cloneUnlessOtherwiseSpecified = Vp;
        var n = Array.isArray(e);
        return n === Array.isArray(t) ? n ? i.arrayMerge(t, e, i) : Up(t, e, i) : Vp(e, i)
    }
    qp.all = function(t, e) {
        if (!Array.isArray(t))
            throw new Error("first argument should be an array");
        return t.reduce(function(t, i) {
            return qp(t, i, e)
        }, {})
    }
    ;
    const Zp = zp(qp)
      , Gp = {
        plugins: {
            legend: {
                labels: {
                    color: "rgb(102,102,102)"
                }
            }
        }
    }
      , Qp = {
        line: {
            options: {
                ...Gp,
                elements: {
                    line: {
                        backgroundColor: "rgba(59, 112, 202, 0.0)",
                        borderColor: "rgb(59, 112, 202)",
                        borderWidth: 2,
                        tension: 0
                    },
                    point: {
                        borderColor: "rgb(59, 112, 202)",
                        backgroundColor: "rgb(59, 112, 202)"
                    }
                },
                responsive: !0,
                legend: {
                    display: !0
                },
                tooltips: {
                    intersect: !1,
                    mode: "index"
                },
                datasets: {
                    borderColor: "red"
                },
                scales: {
                    x: {
                        stacked: !0,
                        grid: {
                            display: !1
                        },
                        ticks: {
                            fontColor: "rgba(0,0,0, 0.5)"
                        }
                    },
                    y: {
                        stacked: !1,
                        grid: {
                            borderDash: [2],
                            drawBorder: !1,
                            zeroLineColor: "rgba(0,0,0,0)",
                            zeroLineBorderDash: [2],
                            zeroLineBorderDashOffset: [2]
                        },
                        ticks: {
                            fontColor: "rgba(0,0,0, 0.5)"
                        }
                    }
                }
            }
        },
        bar: {
            options: {
                ...Gp,
                backgroundColor: "rgb(59, 112, 202)",
                borderWidth: 0,
                responsive: !0,
                legend: {
                    display: !0
                },
                tooltips: {
                    intersect: !1,
                    mode: "index"
                },
                scales: {
                    x: {
                        stacked: !0,
                        grid: {
                            display: !1
                        },
                        ticks: {
                            fontColor: "rgba(0,0,0, 0.5)"
                        }
                    },
                    y: {
                        stacked: !0,
                        grid: {
                            borderDash: [2],
                            drawBorder: !1,
                            zeroLineColor: "rgba(0,0,0,0)",
                            zeroLineBorderDash: [2],
                            zeroLineBorderDashOffset: [2]
                        },
                        ticks: {
                            fontColor: "rgba(0,0,0, 0.5)"
                        }
                    }
                }
            }
        },
        pie: {
            options: {
                ...Gp,
                elements: {
                    arc: {
                        backgroundColor: "rgb(59, 112, 202)"
                    }
                },
                responsive: !0,
                legend: {
                    display: !0
                }
            }
        },
        doughnut: {
            options: {
                ...Gp,
                elements: {
                    arc: {
                        backgroundColor: "rgb(59, 112, 202)"
                    }
                },
                responsive: !0,
                legend: {
                    display: !0
                }
            }
        },
        polarArea: {
            options: {
                ...Gp,
                elements: {
                    arc: {
                        backgroundColor: "rgba(59, 112, 202, 0.5)"
                    }
                },
                responsive: !0,
                legend: {
                    display: !0
                }
            }
        },
        radar: {
            options: {
                ...Gp,
                elements: {
                    line: {
                        backgroundColor: "rgba(59, 112, 202, 0.5)",
                        borderColor: "rgb(59, 112, 202)",
                        borderWidth: 2
                    },
                    point: {
                        borderColor: "rgb(59, 112, 202)",
                        backgroundColor: "rgb(59, 112, 202)"
                    }
                },
                responsive: !0,
                legend: {
                    display: !0
                }
            }
        },
        scatter: {
            options: {
                ...Gp,
                elements: {
                    line: {
                        backgroundColor: "rgba(59, 112, 202, 0.5)",
                        borderColor: "rgb(59, 112, 202)",
                        borderWidth: 2,
                        tension: 0
                    },
                    point: {
                        borderColor: "rgb(59, 112, 202)",
                        backgroundColor: "rgba(59, 112, 202, 0.5)"
                    }
                },
                responsive: !0,
                legend: {
                    display: !0
                },
                tooltips: {
                    intersect: !1,
                    mode: "index"
                },
                datasets: {
                    borderColor: "red"
                },
                scales: {
                    x: {
                        stacked: !0,
                        grid: {
                            display: !1
                        },
                        ticks: {
                            fontColor: "rgba(0,0,0, 0.5)"
                        }
                    },
                    y: {
                        stacked: !1,
                        grid: {
                            borderDash: [2],
                            drawBorder: !1,
                            zeroLineColor: "rgba(0,0,0,0)",
                            zeroLineBorderDash: [2],
                            zeroLineBorderDashOffset: [2]
                        },
                        ticks: {
                            fontColor: "rgba(0,0,0, 0.5)"
                        }
                    }
                }
            }
        },
        bubble: {
            options: {
                ...Gp,
                elements: {
                    point: {
                        borderColor: "rgb(59, 112, 202)",
                        backgroundColor: "rgba(59, 112, 202, 0.5)"
                    }
                },
                responsive: !0,
                legend: {
                    display: !0
                },
                scales: {
                    x: {
                        grid: {
                            display: !1
                        },
                        ticks: {
                            fontColor: "rgba(0,0,0, 0.5)"
                        }
                    },
                    y: {
                        grid: {
                            borderDash: [2],
                            drawBorder: !1,
                            zeroLineColor: "rgba(0,0,0,0)",
                            zeroLineBorderDash: [2],
                            zeroLineBorderDashOffset: [2]
                        },
                        ticks: {
                            fontColor: "rgba(0,0,0, 0.5)"
                        }
                    }
                }
            }
        }
    };
    tu.register(lu, _u, Tu, vu, Cc, kc, Sc, Tc, Ec, Ac, Mc, Vc, fp, bp, yp, Op, Bp, Fp, Mu, Xu, qu, Gu, up, Ju);
    const Jp = "chart"
      , tf = "mdb.chart"
      , ef = (t, e, i) => Zp(i[e], t, {
        arrayMerge: (t, e, i) => {
            const n = t.slice();
            return e.forEach( (e, s) => {
                void 0 === n[s] ? n[s] = i.cloneUnlessOtherwiseSpecified(e, i) : i.isMergeableObject(e) ? n[s] = Zp(t[s], e, i) : -1 === t.indexOf(e) && n.push(e)
            }
            ),
            n
        }
    })
      , nf = {
        darkTicksColor: "#fff",
        darkLabelColor: "#fff",
        darkGridLinesColor: "#555",
        darkmodeOff: "undefined",
        darkMode: null,
        darkBgColor: "#262626",
        darkBgColorLight: "#fff",
        options: null
    }
      , sf = {
        darkTicksColor: "string",
        darkLabelColor: "string",
        darkGridLinesColor: "string",
        darkmodeOff: "(string|null)",
        darkMode: "(string|null)",
        darkBgColor: "string",
        darkBgColorLight: "string",
        options: "(object|null)"
    };
    class of extends ao {
        constructor(t, e, i={}, n={}) {
            if (super(t),
            this._data = e,
            this._options = i,
            this._type = e.type,
            this._canvas = null,
            this._chart = null,
            this._darkOptions = this._getDarkConfig(n),
            this._darkModeClassContainer = document.querySelector("html"),
            this._prevConfig = i,
            this._observer = null,
            this._element && (N.addClass(this._element, "chart"),
            this._chartConstructor(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)),
            this._element && null !== this._darkOptions.darkmodeOff) {
                let t;
                switch (this._darkOptions.darkMode) {
                case "dark":
                    t = "dark";
                    break;
                case "light":
                    t = "light";
                    break;
                default:
                    t = this.systemColorMode
                }
                this._handleMode(t),
                this._observer = new MutationObserver(this._observerCallback.bind(this)),
                this._observer.observe(this._darkModeClassContainer, {
                    attributes: !0
                })
            }
        }
        static get NAME() {
            return Jp
        }
        get systemColorMode() {
            return localStorage.theme || N.getDataAttribute(this._darkModeClassContainer, "theme") || "light"
        }
        static get BarController() {
            return Cc
        }
        static get BubbleController() {
            return kc
        }
        static get DoughnutController() {
            return Sc
        }
        static get LineController() {
            return Tc
        }
        static get PieController() {
            return Ec
        }
        static get PolarAreaController() {
            return Ac
        }
        static get RadarController() {
            return Mc
        }
        static get ScatterController() {
            return Vc
        }
        dispose() {
            this._observer.disconnect(),
            s.removeData(this._element, tf),
            this._chart.destroy(),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        update(t, e={}) {
            t && (this._data = {
                ...this._data,
                ...t
            },
            this._chart.data = this._data);
            const i = Object.prototype.hasOwnProperty.call(e, "options") ? e : {
                options: {
                    ...e
                }
            };
            this._options = Zp(this._options, i),
            this._chart.options = ef(this._options, this._type, Qp).options,
            this._chart.update()
        }
        static register(t) {
            tu.register(t)
        }
        setTheme(t) {
            "dark" !== t && "light" !== t || !this._data || this._handleMode(t)
        }
        _getDarkConfig(t) {
            let e = {};
            const i = N.getDataAttributes(this._element);
            Object.keys(i).forEach(t => t.startsWith("dark") && (e[t] = i[t])),
            e = {
                ...nf,
                ...e
            };
            const n = {
                y: {
                    ticks: {
                        color: e.darkTicksColor
                    },
                    grid: {
                        color: e.darkGridLinesColor
                    }
                },
                x: {
                    ticks: {
                        color: e.darkTicksColor
                    },
                    grid: {
                        color: e.darkGridLinesColor
                    }
                }
            }
              , s = {
                r: {
                    ticks: {
                        color: e.darkTicksColor,
                        backdropColor: e.darkBgColor
                    },
                    grid: {
                        color: e.darkGridLinesColor
                    },
                    pointLabels: {
                        color: e.darkTicksColor
                    }
                }
            };
            let o = {};
            ["pie", "doughnut", "polarArea", "radar"].includes(this._type) ? ["polarArea", "radar"].includes(this._type) && (o = s) : o = n;
            const a = {
                scales: o,
                plugins: {
                    legend: {
                        labels: {
                            color: e.darkLabelColor
                        }
                    }
                }
            };
            return t = {
                ...e,
                options: {
                    ...a
                },
                ...t
            },
            d(Jp, t, sf),
            t
        }
        _getLightTheme(t) {
            const e = Qp[`${t}`] ? Qp[`${t}`].options : {}
              , i = this._prevConfig || {};
            return Zp(e, i)
        }
        _chartConstructor() {
            if (this._data) {
                this._createCanvas();
                const t = ef(this._options, this._type, Qp);
                this._chart = new tu(this._canvas,{
                    ...this._data,
                    ...t
                })
            }
        }
        _createCanvas() {
            this._canvas || ("CANVAS" === this._element.nodeName ? this._canvas = this._element : (this._canvas = _("canvas"),
            this._element.appendChild(this._canvas)))
        }
        _handleMode(t) {
            "dark" === t ? (this._changeDatasetBorderColor(),
            this.update(null, this._darkOptions.options)) : (this._changeDatasetBorderColor(!1),
            this._options = null,
            this.update(null, this._getLightTheme(this._type)))
        }
        _observerCallback(t) {
            t.forEach(t => {
                "attributes" === t.type && this._handleMode(this.systemColorMode)
            }
            )
        }
        _changeDatasetBorderColor(t=!0) {
            this._data.data && [...this._data.data.datasets].forEach(e => ["pie", "doughnut", "polarArea"].includes(this._type) && (e.borderColor = t ? this._darkOptions.darkBgColor : this._darkOptions.darkBgColorLight))
        }
        static jQueryInterface(t, e, i) {
            return this.each(function() {
                let n = s.getData(this, tf);
                if (n || !/dispose/.test(t)) {
                    if (!n) {
                        const s = e ? ef(e, i, Qp) : Qp[i];
                        n = new of(this,t,s)
                    }
                    if ("string" == typeof t) {
                        if (void 0 === n[t])
                            throw new TypeError(`No method named "${t}"`);
                        n[t](e, i)
                    }
                }
            })
        }
        static getInstance(t) {
            return s.getData(t, tf)
        }
        static getOrCreateInstance(t, e={}) {
            return this.getInstance(t) || new this(t,"object" == typeof e ? e : null)
        }
    }
    const af = "lightbox"
      , rf = "mdb.lightbox"
      , lf = `click${`.${rf}`}.data-api`
      , hf = "lightbox-gallery-caption"
      , cf = `[data-mdb-${af}-init] img:not(.lightbox-disabled)`
      , df = {
        container: "string",
        zoomLevel: "(number|string)"
    }
      , uf = {
        container: "body",
        zoomLevel: 1
    };
    class pf extends ao {
        constructor(t, e={}) {
            super(t),
            this._options = e,
            this._getContainer(),
            this._id = `lightbox-${Math.random().toString(36).substr(2, 9)}`,
            this._activeImg = 0,
            this._images = [],
            this._preloadedImages = [],
            this._zoom = 1,
            this._gallery = null,
            this._galleryToolbar = null,
            this._galleryContent = null,
            this._loader = null,
            this._imgCounter = null,
            this._animating = !1,
            this._fullscreen = !1,
            this._zoomBtn = null,
            this._fullscreenBtn = null,
            this._toolsToggleTimer = 0,
            this._mousedown = !1,
            this._mousedownPositionX = 0,
            this._mousedownPositionY = 0,
            this._originalPositionX = 0,
            this._originalPositionY = 0,
            this._positionX = 0,
            this._positionY = 0,
            this._zoomTimer = 0,
            this._tapCounter = 0,
            this._tapTime = 0,
            this._rightArrow = null,
            this._leftArrowWrapper = null,
            this._rightArrowWrapper = null,
            this._initiated = !1,
            this._multitouch = !1,
            this._touchZoomPosition = [],
            this._element && (this.init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor))
        }
        static get NAME() {
            return af
        }
        get activeImg() {
            return this._activeImg
        }
        get currentImg() {
            return B.findOne(".active", this._galleryContent)
        }
        get nextImage() {
            return this._activeImg === this._images.length - 1 ? 0 : this._activeImg + 1
        }
        get previousImage() {
            return 0 === this._activeImg ? this._images.length - 1 : this._activeImg - 1
        }
        get options() {
            const t = {
                ...uf,
                ...N.getDataAttributes(this._element),
                ...this._options
            };
            return d(af, t, df),
            t
        }
        init() {
            this._initiated || (this._appendTemplate(),
            this._initiated = !0)
        }
        open(t=0) {
            this._getImages(),
            this._setActiveImg(t),
            this._triggerEvents("open", "opened"),
            this._loadImages().then(t => {
                this._preloadedImages = t,
                this._resizeImages(t),
                this._toggleTemplate(),
                this._addEvents(),
                this._focusFullscreenBtn()
            }
            )
        }
        close() {
            this.reset(),
            this._removeEvents(),
            this._toggleTemplate(),
            this._triggerEvents("close", "closed")
        }
        slide(t="right") {
            !0 === this._animating || this._images.length <= 1 || (this._triggerEvents("slide", "slid"),
            this._beforeSlideEvents(),
            "right" === t && this._slideHorizontally(t),
            "left" === t && this._slideHorizontally(t),
            "first" === t && this._slideToTarget(t),
            "last" === t && this._slideToTarget(t),
            this._afterSlideEvents())
        }
        zoomIn() {
            this._zoom >= 3 || (this._triggerEvents("zoomIn", "zoomedIn"),
            this._zoom += parseFloat(this.options.zoomLevel),
            N.style(this.currentImg.parentNode, {
                transform: `scale(${this._zoom})`
            }),
            this._updateZoomBtn())
        }
        zoomOut() {
            this._zoom <= 1 || (this._triggerEvents("zoomOut", "zoomedOut"),
            this._zoom -= parseFloat(this.options.zoomLevel),
            N.style(this.currentImg.parentNode, {
                transform: `scale(${this._zoom})`
            }),
            this._updateZoomBtn(),
            this._updateImgPosition())
        }
        toggleFullscreen() {
            !1 === this._fullscreen ? (N.addClass(this._fullscreenBtn, "active"),
            this._gallery.requestFullscreen && this._gallery.requestFullscreen(),
            this._fullscreen = !0) : (N.removeClass(this._fullscreenBtn, "active"),
            document.exitFullscreen && document.exitFullscreen(),
            this._fullscreen = !1)
        }
        reset() {
            this._restoreDefaultFullscreen(),
            this._restoreDefaultPosition(),
            this._restoreDefaultZoom(),
            clearTimeout(this._toolsToggleTimer),
            clearTimeout(this._doubleTapTimer)
        }
        dispose() {
            I.off(document, lf, cf, this.toggle),
            this._galleryContent && this._removeEvents(),
            this._gallery && this._gallery.remove(),
            s.removeData(this._element, rf),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _getImages() {
            const t = B.find("img", this._element).filter(t => !t.classList.contains("lightbox-disabled"));
            this._images = t
        }
        _getContainer() {
            this._container = B.findOne(this.options.container)
        }
        _setActiveImg(t) {
            this._activeImg = "number" == typeof t ? t : this._images.indexOf(t.target)
        }
        _appendTemplate() {
            this._gallery = _("div"),
            N.addClass(this._gallery, "lightbox-gallery"),
            this._element.dataset.id = this._id,
            this._gallery.id = this._id,
            this._appendLoader(),
            this._appendToolbar(),
            this._appendContent(),
            this._appendArrows(),
            this._appendCaption(),
            this._container.append(this._gallery)
        }
        _appendToolbar() {
            this._galleryToolbar = _("div"),
            this._imgCounter = _("p"),
            this._fullscreenBtn = _("button"),
            this._zoomBtn = _("button");
            const t = _("div")
              , e = _("div")
              , i = _("button");
            N.addClass(this._galleryToolbar, "lightbox-gallery-toolbar"),
            N.addClass(this._imgCounter, "lightbox-gallery-counter"),
            N.addClass(this._fullscreenBtn, "lightbox-gallery-fullscreen-btn"),
            N.addClass(this._zoomBtn, "lightbox-gallery-zoom-btn"),
            N.addClass(t, "lightbox-gallery-left-tools"),
            N.addClass(e, "lightbox-gallery-right-tools"),
            N.addClass(i, "lightbox-gallery-close-btn"),
            this._fullscreenBtn.setAttribute("aria-label", "Toggle fullscreen"),
            this._zoomBtn.setAttribute("aria-label", "Zoom in"),
            i.setAttribute("aria-label", "Close"),
            I.on(this._fullscreenBtn, lf, () => this.toggleFullscreen()),
            I.on(this._zoomBtn, lf, () => this._toggleZoom()),
            I.on(i, lf, () => this.close()),
            t.append(this._imgCounter),
            e.append(this._fullscreenBtn),
            e.append(this._zoomBtn),
            e.append(i),
            this._galleryToolbar.append(t),
            this._galleryToolbar.append(e),
            this._gallery.append(this._galleryToolbar)
        }
        _appendContent() {
            this._galleryContent = _("div"),
            N.addClass(this._galleryContent, "lightbox-gallery-content"),
            this._gallery.append(this._galleryContent)
        }
        _appendLoader() {
            this._loader = _("div");
            const t = _("div")
              , e = _("span");
            N.addClass(this._loader, "lightbox-gallery-loader"),
            N.addClass(t, "spinner-grow"),
            N.addClass(t, "text-light"),
            N.addClass(e, "sr-only"),
            t.setAttribute("role", "status"),
            e.innerHTML = "Loading...",
            t.append(e),
            this._loader.append(t),
            this._gallery.append(this._loader)
        }
        _appendArrows() {
            this._leftArrowWrapper = _("div"),
            N.addClass(this._leftArrowWrapper, "lightbox-gallery-arrow-left");
            const t = _("button");
            t.setAttribute("aria-label", "Previous"),
            I.on(t, lf, () => this.slide("left")),
            this._leftArrowWrapper.append(t),
            this._rightArrowWrapper = _("div"),
            N.addClass(this._rightArrowWrapper, "lightbox-gallery-arrow-right"),
            this._rightArrow = _("button"),
            this._rightArrow.setAttribute("aria-label", "Next"),
            I.on(this._rightArrow, lf, () => this.slide()),
            this._rightArrowWrapper.append(this._rightArrow),
            this._getImages(),
            this._images.length <= 1 || (this._gallery.append(this._leftArrowWrapper),
            this._gallery.append(this._rightArrowWrapper))
        }
        _appendCaption() {
            const t = _("div")
              , e = _("p");
            N.addClass(t, "lightbox-gallery-caption-wrapper"),
            N.addClass(e, hf),
            t.append(e),
            this._gallery.append(t)
        }
        async _loadImages() {
            const t = []
              , e = [];
            this._galleryContent.innerHTML = "";
            let i = -100;
            return [this.previousImage, this._activeImg, this.nextImage].forEach(n => {
                t.push(new Promise(t => {
                    const s = this._createImage(n, i, "right");
                    s.onload = () => {
                        e.push(s),
                        t(s)
                    }
                }
                )),
                i += 100
            }
            ),
            await Promise.all(t),
            e
        }
        _createImage(t, e, i) {
            const n = this._images[t]
              , s = new Image
              , o = _("div");
            return N.addClass(o, "lightbox-gallery-image"),
            this._addImgStyles(s, o, e, n),
            o.append(s),
            "right" === i ? this._galleryContent.append(o) : this._galleryContent.prepend(o),
            s.src = n.dataset.mdbImg || n.src,
            s
        }
        _updatePreloadedImages(t) {
            const e = "right" === t
              , i = e ? this._galleryContent.firstChild : this._galleryContent.lastChild
              , n = null == i ? void 0 : i.querySelector("img");
            this._removeImageEvents(n),
            this._galleryContent.removeChild(i);
            const s = e ? this.nextImage : this.previousImage
              , o = e ? 200 : -200
              , a = this._createImage(s, o, t);
            this._addImageEvents(a),
            this._preloadedImages = B.find("img", this._galleryContent)
        }
        _addImgStyles(t, e, i, n) {
            t.alt = n.alt,
            t.draggable = !1,
            N.style(e, {
                position: "absolute",
                left: `${i}%`,
                top: 0
            }),
            (n.dataset.mdbCaption || "" === n.dataset.mdbCaption) && (t.dataset.caption = n.dataset.mdbCaption),
            0 === i ? (t.width < t.height && N.addClass(t, "vertical"),
            N.style(e, {
                opacity: 1
            }),
            N.addClass(t, "active")) : N.removeClass(t, "active")
        }
        _resizeImages(t) {
            t.forEach(t => {
                this._calculateImgSize(t)
            }
            )
        }
        _calculateImgSize(t) {
            t.width >= t.height ? (t.style.width = "100%",
            t.style.maxWidth = "100%",
            t.style.height = "auto",
            t.style.top = (t.parentNode.offsetHeight - t.height) / 2 + "px",
            t.style.left = 0) : (t.style.height = "100%",
            t.style.maxHeight = "100%",
            t.style.width = "auto",
            t.style.left = (t.parentNode.offsetWidth - t.width) / 2 + "px",
            t.style.top = 0),
            t.width >= t.parentNode.offsetWidth && (t.style.width = `${t.parentNode.offsetWidth}px`,
            t.style.height = "auto",
            t.style.left = 0,
            t.style.top = (t.parentNode.offsetHeight - t.height) / 2 + "px"),
            t.height >= t.parentNode.offsetHeight && (t.style.height = `${t.parentNode.offsetHeight}px`,
            t.style.width = "auto",
            t.style.top = 0,
            t.style.left = (t.parentNode.offsetWidth - t.width) / 2 + "px"),
            this._positionX = parseFloat(t.style.left) || 0,
            this._positionY = parseFloat(t.style.top) || 0
        }
        _onResize() {
            this._preloadedImages.forEach(t => {
                this._calculateImgSize(t)
            }
            )
        }
        _onFullscreenChange() {
            void 0 === (document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement) && (this._fullscreen = !1,
            N.removeClass(this._fullscreenBtn, "active"))
        }
        _beforeSlideEvents() {
            this._animationStart(),
            this._restoreDefaultZoom(),
            this._restoreDefaultPosition(),
            this._resetDoubleTap()
        }
        _slideHorizontally(t) {
            this._updateActiveImg(t),
            this._updatePreloadedImages(t),
            this._resizeImages(this._preloadedImages),
            this._preloadedImages = B.find("img", this._galleryContent),
            this._slidePreloadedImages()
        }
        _slideImg(t, e) {
            0 === e ? (N.addClass(t, "active"),
            N.style(t.parentNode, {
                opacity: 1,
                transform: "scale(1)"
            })) : (N.removeClass(t, "active"),
            N.style(t.parentNode, {
                opacity: 0,
                transform: "scale(0.25)"
            })),
            t.parentNode.style.left = `${e}%`
        }
        _slidePreloadedImages() {
            let t = -100;
            this._preloadedImages.forEach(e => {
                this._slideImg(e, t),
                t += 100
            }
            )
        }
        _slideToTarget(t) {
            "first" === t && 0 === this._activeImg || "last" === t && this._activeImg === this._images.length - 1 || (this.reset(),
            this._removeEvents(),
            this._showLoader(),
            this._getImages(),
            this._activeImg = "first" === t ? 0 : this._images.length - 1,
            N.style(this.currentImg.parentNode, {
                transform: "scale(0.25)",
                opacity: 0
            }),
            setTimeout( () => {
                this._loadImages().then(t => {
                    this._preloadedImages = t,
                    this._resizeImages(t),
                    this._addEvents(),
                    this._updateCaption(),
                    this._hideLoader(),
                    setTimeout( () => {
                        N.style(this.currentImg.parentNode, {
                            transform: "scale(1)",
                            opacity: 1
                        })
                    }
                    , 10)
                }
                )
            }
            , 400))
        }
        _updateActiveImg(t) {
            "right" === t && (this._activeImg = this.nextImage),
            "left" === t && (this._activeImg = this.previousImage)
        }
        _afterSlideEvents() {
            this._updateCounter(),
            this._updateCaption()
        }
        _updateCounter() {
            this._images.length <= 1 || setTimeout( () => {
                this._imgCounter.innerHTML = `${this._activeImg + 1} / ${this._images.length}`
            }
            , 200)
        }
        _updateCaption() {
            setTimeout( () => {
                let t = this.currentImg.alt;
                (this.currentImg.dataset.caption || "" === this.currentImg.dataset.caption) && (t = this.currentImg.dataset.caption),
                B.findOne(`.${hf}`, this._gallery).innerHTML = t
            }
            , 200)
        }
        _toggleTemplate() {
            "visible" === this._gallery.style.visibility ? (N.style(this.currentImg.parentNode, {
                transform: "scale(0.25)"
            }),
            setTimeout( () => {
                this._hideGallery(),
                this._enableScroll(),
                this._showLoader()
            }
            , 100)) : (this._showGallery(),
            this._disableScroll(),
            this._updateCounter(),
            this._updateCaption(),
            this._setToolsToggleTimout(),
            this._hideLoader())
        }
        _showLoader() {
            N.style(this._loader, {
                opacity: 1
            })
        }
        _hideLoader() {
            N.style(this._loader, {
                opacity: 0
            })
        }
        _hideGallery() {
            N.style(this._gallery, {
                opacity: 0,
                pointerEvents: "none",
                visibility: "hidden"
            })
        }
        _showGallery() {
            N.style(this._gallery, {
                opacity: 1,
                pointerEvents: "initial",
                visibility: "visible"
            }),
            setTimeout( () => {
                N.style(this.currentImg.parentNode, {
                    transform: "scale(1)"
                })
            }
            , 50)
        }
        _toggleZoom() {
            1 !== this._zoom ? this._restoreDefaultZoom() : this.zoomIn()
        }
        _updateZoomBtn() {
            this._zoom > 1 ? (N.addClass(this._zoomBtn, "active"),
            this._zoomBtn.setAttribute("aria-label", "Zoom out")) : (N.removeClass(this._zoomBtn, "active"),
            this._zoomBtn.setAttribute("aria-label", "Zoom in"))
        }
        _updateImgPosition() {
            1 === this._zoom && this._restoreDefaultPosition()
        }
        _addEvents() {
            const t = B.find("img", this._galleryContent);
            this._onWindowTouchmove = this._onWindowTouchmove.bind(this),
            this._onWindowTouchstart = this._onWindowTouchstart.bind(this),
            this._onImgMousedown = this._onMousedown.bind(this),
            this._onImgMousemove = this._onMousemove.bind(this),
            this._onImgWheel = this._onWheel.bind(this),
            this._onImgMouseup = this._onMouseup.bind(this),
            this._onImgTouchend = this._onTouchend.bind(this),
            this._onImgDoubleClick = this._onDoubleClick.bind(this),
            this._onWindowResize = this._onResize.bind(this),
            this._onWindowFullscreenChange = this._onFullscreenChange.bind(this),
            this._onAnyImgAction = this._resetToolsToggler.bind(this),
            this._onGalleryClick = this._onBackdropClick.bind(this),
            this._onKeyupEvent = this._onKeyup.bind(this),
            this._onRightArrowKeydownEvent = this._onRightArrowKeydown.bind(this),
            this._onFullscreenBtnKeydownEvent = this._onFullscreenBtnKeydown.bind(this),
            t.forEach(t => {
                this._addImageEvents(t)
            }
            ),
            document.addEventListener("touchmove", this._onWindowTouchmove, {
                passive: !1
            }),
            I.on(window, "touchstart", this._onWindowTouchstart),
            I.on(window, "mouseup", this._onImgMouseup),
            I.on(window, "touchend", this._onImgTouchend),
            I.on(window, "resize", this._onWindowResize),
            I.on(window, "orientationchange", this._onWindowResize),
            I.on(window, "keyup", this._onKeyupEvent),
            I.on(window, "fullscreenchange", this._onWindowFullscreenChange),
            I.on(this._gallery, "mousemove", this._onAnyImgAction),
            I.on(this._gallery, "click", this._onGalleryClick),
            I.on(this._rightArrow, "keydown", this._onRightArrowKeydownEvent),
            I.on(this._fullscreenBtn, "keydown", this._onFullscreenBtnKeydownEvent)
        }
        _addImageEvents(t) {
            I.on(t, "mousedown", this._onImgMousedown, {
                passive: !0
            }),
            I.on(t, "touchstart", this._onImgMousedown, {
                passive: !0
            }),
            I.on(t, "mousemove", this._onImgMousemove, {
                passive: !0
            }),
            I.on(t, "touchmove", this._onImgMousemove, {
                passive: !0
            }),
            I.on(t, "wheel", this._onImgWheel, {
                passive: !0
            }),
            I.on(t, "dblclick", this._onImgDoubleClick, {
                passive: !0
            })
        }
        _removeEvents() {
            B.find("img", this._galleryContent).forEach(t => {
                this._removeImageEvents(t)
            }
            ),
            document.removeEventListener("touchmove", this._onWindowTouchmove, {
                passive: !1
            }),
            I.off(window, "touchstart", this._onWindowTouchstart),
            I.off(window, "mouseup", this._onImgMouseup),
            I.off(window, "touchend", this._onImgTouchend),
            I.off(window, "resize", this._onWindowResize),
            I.off(window, "orientationchange", this._onWindowResize),
            I.off(window, "keyup", this._onKeyupEvent),
            I.off(window, "fullscreenchange", this._onWindowFullscreenChange),
            I.off(this._gallery, "mousemove", this._onAnyImgAction),
            I.off(this._gallery, "click", this._onGalleryClick),
            I.off(this._rightArrow, "keydown", this._onRightArrowKeydownEvent),
            I.off(this._fullscreenBtn, "keydown", this._onFullscreenBtnKeydownEvent)
        }
        _removeImageEvents(t) {
            I.off(t, "mousedown", this._onImgMousedown),
            I.off(t, "touchstart", this._onImgMousedown),
            I.off(t, "mousemove", this._onImgMousemove),
            I.off(t, "touchmove", this._onImgMousemove),
            I.off(t, "wheel", this._onImgWheel),
            I.off(t, "dblclick", this._onImgDoubleClick)
        }
        _onMousedown(t) {
            const e = t.touches
              , i = e ? e[0].clientX : t.clientX
              , n = e ? e[0].clientY : t.clientY;
            this._originalPositionX = parseFloat(this.currentImg.style.left) || 0,
            this._originalPositionY = parseFloat(this.currentImg.style.top) || 0,
            this._positionX = this._originalPositionX,
            this._positionY = this._originalPositionY,
            this._mousedownPositionX = i * (1 / this._zoom) - this._positionX,
            this._mousedownPositionY = n * (1 / this._zoom) - this._positionY,
            this._mousedown = !0,
            "touchstart" === t.type && t.touches.length > 1 && (this._multitouch = !0,
            this._touchZoomPosition = t.touches)
        }
        _onMousemove(t) {
            if (!this._mousedown)
                return;
            const e = t.touches
              , i = e ? e[0].clientX : t.clientX
              , n = e ? e[0].clientY : t.clientY;
            if (e && this._resetToolsToggler(),
            !this._multitouch)
                if (1 !== this._zoom)
                    this._positionX = i * (1 / this._zoom) - this._mousedownPositionX,
                    this._positionY = n * (1 / this._zoom) - this._mousedownPositionY,
                    N.style(this.currentImg, {
                        left: `${this._positionX}px`,
                        top: `${this._positionY}px`
                    });
                else {
                    if (this._images.length <= 1)
                        return;
                    this._positionX = i * (1 / this._zoom) - this._mousedownPositionX,
                    N.style(this.currentImg, {
                        left: `${this._positionX}px`
                    })
                }
        }
        _onMouseup(t) {
            this._mousedown = !1,
            this._moveImg(t.target)
        }
        _onTouchend(t) {
            this._mousedown = !1,
            this._multitouch ? 0 === t.targetTouches.length && (this._multitouch = !1,
            this._touchZoomPosition = []) : this._multitouch || (this._checkDoubleTap(t),
            this._moveImg(t.target))
        }
        _calculateTouchZoom(t) {
            const e = Math.hypot(this._touchZoomPosition[1].pageX - this._touchZoomPosition[0].pageX, this._touchZoomPosition[1].pageY - this._touchZoomPosition[0].pageY)
              , i = Math.hypot(t.touches[1].pageX - t.touches[0].pageX, t.touches[1].pageY - t.touches[0].pageY);
            Math.abs(e - i) > .03 * t.view.screen.width && (e <= i ? this.zoomIn() : this.zoomOut(),
            this._touchZoomPosition = t.touches)
        }
        _onWindowTouchstart(t) {
            t.touches.length > 1 && (this._multitouch = !0,
            this._touchZoomPosition = t.touches)
        }
        _onWindowTouchmove(t) {
            t.preventDefault(),
            "touchmove" === t.type && t.targetTouches.length > 1 && this._calculateTouchZoom(t)
        }
        _onRightArrowKeydown(t) {
            switch (t.keyCode) {
            case 9:
                if (t.shiftKey)
                    break;
                t.preventDefault(),
                this._focusFullscreenBtn()
            }
        }
        _onFullscreenBtnKeydown(t) {
            switch (t.keyCode) {
            case 9:
                if (!t.shiftKey)
                    break;
                t.preventDefault(),
                this._focusRightArrow()
            }
        }
        _onKeyup(t) {
            switch (this._resetToolsToggler(),
            t.keyCode) {
            case 39:
                m ? this.slide("left") : this.slide();
                break;
            case 37:
                m ? this.slide() : this.slide("left");
                break;
            case 27:
                this.close();
                break;
            case 36:
                this.slide("first");
                break;
            case 35:
                this.slide("last");
                break;
            case 38:
                this.zoomIn();
                break;
            case 40:
                this.zoomOut()
            }
        }
        _focusFullscreenBtn() {
            setTimeout( () => {
                this._fullscreenBtn.focus()
            }
            , 100)
        }
        _focusRightArrow() {
            this._rightArrow.focus()
        }
        _moveImg(t) {
            if (this._multitouch)
                return;
            if (1 !== this._zoom || t !== this.currentImg || this._images.length <= 1)
                return;
            const e = this._positionX - this._originalPositionX;
            e > 0 ? m ? this.slide() : this.slide("left") : e < 0 && (m ? this.slide("left") : this.slide())
        }
        _checkDoubleTap(t) {
            clearTimeout(this._doubleTapTimer);
            const e = (new Date).getTime() - this._tapTime;
            this._tapCounter > 0 && e < 500 ? (this._onDoubleClick(t),
            this._doubleTapTimer = setTimeout( () => {
                this._tapTime = (new Date).getTime(),
                this._tapCounter = 0
            }
            , 300)) : (this._tapCounter++,
            this._tapTime = (new Date).getTime())
        }
        _resetDoubleTap() {
            this._tapTime = 0,
            this._tapCounter = 0,
            clearTimeout(this._doubleTapTimer)
        }
        _onDoubleClick(t) {
            this._multitouch || (t.touches || this._setNewPositionOnZoomIn(t),
            1 !== this._zoom ? this._restoreDefaultZoom() : this.zoomIn())
        }
        _onWheel(t) {
            const e = Math.max(-1, Math.min(1, t.deltaY));
            this._zoomOnWheel(t.x, t.y, e)
        }
        _zoomOnWheel(t, e, i) {
            -i > 0 ? this._triggerEvents("zoomIn") : this._triggerEvents("zoomOut"),
            1 === this._zoom && (this._positionX = 0,
            this._positionY = 0),
            N.style(this.currentImg, {
                transition: "none"
            });
            const n = this.currentImg.getBoundingClientRect()
              , s = (t - n.left) / this._zoom
              , o = (e - n.top) / this._zoom
              , a = (s - this._positionX) / this._zoom
              , r = (o - this._positionY) / this._zoom;
            this._zoom += -i * this.options.zoomLevel;
            this._zoom = Math.max(1, Math.min(3, this._zoom)),
            1 === this._zoom ? (this._positionX = 0,
            this._positionY = 0) : (this._positionX = -a * this._zoom + s,
            this._positionY = -r * this._zoom + o),
            N.style(this.currentImg, {
                transition: ""
            }),
            N.style(this.currentImg, {
                transform: `translate(${this._positionX}px,${this._positionY}px) scale(${this._zoom})`
            }),
            this._updateZoomBtn(),
            -i > 0 ? this._triggerEvents("zoomedIn") : this._triggerEvents("zoomedOut")
        }
        _onBackdropClick(t) {
            this._resetToolsToggler(),
            "DIV" === t.target.tagName && this.close()
        }
        _setNewPositionOnZoomIn(t) {
            clearTimeout(this._zoomTimer),
            this._positionX = window.innerWidth / 2 - t.offsetX - 50,
            this._positionY = window.innerHeight / 2 - t.offsetY - 50,
            this.currentImg.style.transition = "all 0.5s ease-out",
            this.currentImg.style.left = `${this._positionX}px`,
            this.currentImg.style.top = `${this._positionY}px`,
            this._zoomTimer = setTimeout( () => {
                this.currentImg.style.transition = "none"
            }
            , 500)
        }
        _resetToolsToggler() {
            this._showTools(),
            clearTimeout(this._toolsToggleTimer),
            this._setToolsToggleTimout()
        }
        _setToolsToggleTimout() {
            this._toolsToggleTimer = setTimeout( () => {
                this._hideTools(),
                clearTimeout(this._toolsToggleTimer)
            }
            , 4e3)
        }
        _hideTools() {
            N.style(this._galleryToolbar, {
                opacity: 0
            }),
            N.style(this._leftArrowWrapper, {
                opacity: 0
            }),
            N.style(this._rightArrowWrapper, {
                opacity: 0
            })
        }
        _showTools() {
            N.style(this._galleryToolbar, {
                opacity: 1
            }),
            N.style(this._leftArrowWrapper, {
                opacity: 1
            }),
            N.style(this._rightArrowWrapper, {
                opacity: 1
            })
        }
        _disableScroll() {
            N.addClass(document.body, "disabled-scroll"),
            document.documentElement.scrollHeight > document.documentElement.clientHeight && N.addClass(document.body, "replace-scrollbar")
        }
        _enableScroll() {
            setTimeout( () => {
                N.removeClass(document.body, "disabled-scroll"),
                N.removeClass(document.body, "replace-scrollbar")
            }
            , 300)
        }
        _animationStart() {
            this._animating = !0,
            setTimeout( () => {
                this._animating = !1
            }
            , 400)
        }
        _restoreDefaultZoom() {
            1 !== this._zoom && (this._zoom = 1,
            N.style(this.currentImg.parentNode, {
                transform: `scale(${this._zoom})`
            }),
            N.style(this.currentImg, {
                transform: `scale(${this._zoom})`
            }),
            this._updateZoomBtn(),
            this._updateImgPosition())
        }
        _restoreDefaultFullscreen() {
            this._fullscreen && this.toggleFullscreen()
        }
        _restoreDefaultPosition() {
            clearTimeout(this._zoomTimer);
            const t = this.currentImg;
            N.style(this.currentImg.parentNode, {
                left: 0,
                top: 0
            }),
            N.style(this.currentImg, {
                transition: "all 0.5s ease-out",
                left: 0,
                top: 0
            }),
            this._calculateImgSize(t),
            setTimeout( () => {
                N.style(this.currentImg, {
                    transition: "none"
                })
            }
            , 500)
        }
        async _triggerEvents(t, e) {
            I.trigger(this._element, `${t}.mdb.lightbox`),
            e && await setTimeout( () => {
                I.trigger(this._element, `${e}.mdb.lightbox`)
            }
            , 505)
        }
        static toggle(t) {
            const e = B.closest(t.target, ".lightbox");
            (pf.getInstance(e) || new pf(e)).open(t)
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                let i = s.getData(this, rf);
                const n = "object" == typeof t && t;
                if ((i || !/dispose/.test(t)) && (i || (i = new pf(this,n)),
                "string" == typeof t)) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
    }
    const ff = "rating"
      , gf = `mdb.${ff}`
      , mf = `.${gf}`
      , _f = {
        tooltip: "string",
        value: "(string|number)",
        readonly: "boolean",
        after: "string",
        before: "string",
        dynamic: "boolean",
        decimal: "boolean",
        decimalPrecision: "number|null"
    }
      , bf = {
        tooltip: "top",
        value: "",
        readonly: !1,
        after: "",
        before: "",
        dynamic: !1,
        decimal: !1,
        decimalPrecision: null
    }
      , vf = `scoreSelect${mf}`
      , yf = `scoreHover${mf}`
      , xf = `scoreMove${mf}`
      , wf = `keyup${mf}`
      , Cf = `focusout${mf}`
      , kf = `keydown${mf}`
      , Sf = `mousedown${mf}`;
    class Tf extends ao {
        constructor(t, e) {
            super(t),
            this._icons = B.find("i", this._element),
            this._options = this._getConfig(e),
            this._index = -1,
            this._savedIndex = null,
            this._originalClassList = [],
            this._fn = {},
            this._tooltips = [],
            this._element && (this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor))
        }
        static get NAME() {
            return ff
        }
        dispose() {
            this._options.readonly || (I.off(this._element, wf),
            I.off(this._element, Cf),
            I.off(this._element, kf),
            this._element.removeEventListener("mouseleave", this._fn.mouseleave),
            this._icons.forEach( (t, e) => {
                I.off(t, Sf),
                I.off(t, "mousemove"),
                t.removeEventListener("mouseenter", this._fn.mouseenter[e])
            }
            ),
            this._tooltips.forEach(t => {
                t._element.removeAttribute("data-mdb-toggle"),
                t.dispose()
            }
            ),
            this._element.removeAttribute("tabIndex")),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _init() {
            this._options.readonly || (this._bindMouseEnter(),
            this._bindMouseMove(),
            this._bindMouseLeave(),
            this._bindMouseDown(),
            this._bindKeyDown(),
            this._bindKeyUp(),
            this._bindFocusLost()),
            this._options.dynamic && this._saveOriginalClassList(),
            this._options.decimal && this._setContentVariable(),
            this._setCustomText(),
            this._setCustomColor(),
            this._setToolTips(),
            this._options.value && (this._index = this._options.value - 1,
            this._updateRating(this._index))
        }
        _getConfig(t) {
            const e = N.getDataAttributes(this._element);
            return t = {
                ...bf,
                ...e,
                ...t
            },
            d(ff, t, _f),
            t
        }
        _bindMouseEnter() {
            this._fn.mouseenter = [],
            this._icons.forEach( (t, e) => {
                t.addEventListener("mouseenter", this._fn.mouseenter[e] = i => {
                    this._index = this._calculateIndex(i, t, e),
                    this._updateRating(this._index),
                    this._triggerEvents(t, yf)
                }
                )
            }
            )
        }
        _bindMouseMove() {
            this._options.decimal && (this._fn.mousemove = [],
            this._icons.forEach( (t, e) => {
                I.on(t, "mousemove", i => {
                    this._index = this._calculateIndex(i, t, e),
                    this._updateRating(this._index),
                    this._triggerEvents(t, xf)
                }
                )
            }
            ))
        }
        _calculateIndex(t, e, i) {
            if (this._options.decimal) {
                const n = e.getBoundingClientRect()
                  , s = t.pageX - n.left + window.scrollX
                  , o = e.offsetWidth;
                return Number((i + (s / o - 1)).toFixed(2))
            }
            return Math.round(i)
        }
        _bindMouseLeave() {
            this._element.addEventListener("mouseleave", this._fn.mouseleave = () => {
                null !== this._savedIndex ? (this._updateRating(this._savedIndex),
                this._index = this._savedIndex) : this._options.value ? (this._updateRating(this._options.value - 1),
                this._index = this._options.value - 1) : (this._index = -1,
                this._clearRating())
            }
            )
        }
        _bindMouseDown() {
            this._icons.forEach(t => {
                I.on(t, Sf, () => {
                    this._setElementOutline("none"),
                    this._savedIndex = this._index,
                    this._triggerEvents(t, vf)
                }
                )
            }
            )
        }
        _bindKeyDown() {
            this._element.tabIndex = 0,
            I.on(this._element, kf, t => this._updateAfterKeyDown(t))
        }
        _bindKeyUp() {
            I.on(this._element, wf, () => this._setElementOutline("auto"))
        }
        _bindFocusLost() {
            I.on(this._element, Cf, () => this._setElementOutline("none"))
        }
        _setElementOutline(t) {
            this._element.style.outline = t
        }
        _setContentVariable() {
            this._icons.forEach(t => {
                const e = window.getComputedStyle(t, "::before").content;
                t.style.setProperty("--content", `${e}`)
            }
            )
        }
        _triggerEvents(t, e) {
            I.trigger(t, e, {
                value: this._index + 1
            })
        }
        _updateAfterKeyDown(t) {
            const e = this._icons.length - 1
              , i = this._index;
            "ArrowRight" === t.key && this._index < e && (this._index += 1),
            "ArrowLeft" === t.key && this._index > -1 && (this._index -= 1),
            i !== this._index && (this._savedIndex = this._index,
            this._updateRating(this._savedIndex),
            this._triggerEvents(this._icons[this._savedIndex], vf))
        }
        _updateRating(t) {
            var e, i, n;
            if (this._clearRating(),
            this._options.dynamic && this._restoreOriginalIcon(t),
            this._icons.forEach( (e, i) => {
                i <= t && (e.classList.add("fas", "active"),
                e.classList.remove("far"))
            }
            ),
            this._options.decimal && !Number.isInteger(t)) {
                const s = Math.floor(t) + 1
                  , o = 100 * this._roundToPrecision(t - Math.floor(t)) + "%";
                this._index = Number(this._roundToPrecision(t)),
                null == (e = this._icons[s]) || e.classList.add("fas", "partial"),
                null == (i = this._icons[s]) || i.classList.remove("far"),
                null == (n = this._icons[s]) || n.style.setProperty("--percentage", o)
            }
        }
        _roundToPrecision(t) {
            const e = this._options.decimalPrecision;
            if (!e)
                return t;
            const i = this._countDecimals(e);
            return (Math.round(t / e) * e).toFixed(i)
        }
        _countDecimals(t) {
            return t.toFixed(5).split(".")[1].replace(/0+$/, "").length
        }
        _clearRating() {
            this._icons.forEach( (t, e) => {
                this._options.dynamic ? t.classList = this._originalClassList[e] : (t.classList.remove("fas", "active", "partial"),
                t.classList.add("far"))
            }
            )
        }
        _setToolTips() {
            this._icons.forEach( (t, e) => {
                const i = N.getDataAttribute(t, "toggle");
                t.title && !i && (N.setDataAttribute(t, "toggle", "tooltip"),
                this._tooltips[e] = new oo(t,{
                    placement: this._options.tooltip
                }))
            }
            )
        }
        _setCustomText() {
            this._icons.forEach(t => {
                const e = N.getDataAttribute(t, "after")
                  , i = N.getDataAttribute(t, "before");
                e && t.insertAdjacentHTML("afterEnd", e),
                i && t.insertAdjacentHTML("beforeBegin", i)
            }
            )
        }
        _setCustomColor() {
            this._icons.forEach(t => {
                const e = N.getDataAttribute(t, "color");
                e && (t.style.color = e)
            }
            )
        }
        _saveOriginalClassList() {
            this._icons.forEach(t => {
                const e = t.classList.value;
                this._originalClassList.push(e)
            }
            )
        }
        _restoreOriginalIcon(t) {
            const e = this._originalClassList[t]
              , i = N.getDataAttribute(this._icons[t], "color");
            this._icons.forEach( (n, s) => {
                s <= t && (n.classList = e,
                n.style.color = i)
            }
            )
        }
        static autoInit(t) {
            return new Tf(t)
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                let i = s.getData(this, gf);
                const n = "object" == typeof t && t;
                if ((i || !/dispose|hide/.test(t)) && (i || (i = new Tf(this,n)),
                "string" == typeof t)) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
    }
    function Af(t) {
        return getComputedStyle(t)
    }
    function Ef(t, e) {
        for (const i in e) {
            let n = e[i];
            "number" == typeof n && (n = `${n}px`),
            t.style[i] = n
        }
        return t
    }
    function Mf(t) {
        const e = document.createElement("div");
        return e.className = t,
        e
    }
    const Of = "undefined" != typeof Element && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
    function Df(t, e) {
        if (!Of)
            throw new Error("No element matching method supported");
        return Of.call(t, e)
    }
    function $f(t) {
        t.remove ? t.remove() : t.parentNode && t.parentNode.removeChild(t)
    }
    function If(t, e) {
        return Array.prototype.filter.call(t.children, t => Df(t, e))
    }
    const Lf = "ps"
      , Pf = "ps__rtl"
      , Rf = {
        thumb: t => `ps__thumb-${t}`,
        rail: t => `ps__rail-${t}`,
        consuming: "ps__child--consume"
    }
      , Nf = {
        focus: "ps--focus",
        clicking: "ps--clicking",
        active: t => `ps--active-${t}`,
        scrolling: t => `ps--scrolling-${t}`
    }
      , Bf = {
        x: null,
        y: null
    };
    function Hf(t, e) {
        const i = t.element.classList
          , n = Nf.scrolling(e);
        i.contains(n) ? clearTimeout(Bf[e]) : i.add(n)
    }
    function Ff(t, e) {
        Bf[e] = setTimeout( () => t.isAlive && t.element.classList.remove(Nf.scrolling(e)), t.settings.scrollingThreshold)
    }
    class zf {
        constructor(t) {
            this.element = t,
            this.handlers = {}
        }
        bind(t, e) {
            void 0 === this.handlers[t] && (this.handlers[t] = []),
            this.handlers[t].push(e),
            this.element.addEventListener(t, e, !1)
        }
        unbind(t, e) {
            this.handlers[t] = this.handlers[t].filter(i => !(!e || i === e) || (this.element.removeEventListener(t, i, !1),
            !1))
        }
        unbindAll() {
            for (const t in this.handlers)
                this.unbind(t)
        }
        get isEmpty() {
            return Object.keys(this.handlers).every(t => 0 === this.handlers[t].length)
        }
    }
    class jf {
        constructor() {
            this.eventElements = []
        }
        eventElement(t) {
            let e = this.eventElements.filter(e => e.element === t)[0];
            return e || (e = new zf(t),
            this.eventElements.push(e)),
            e
        }
        bind(t, e, i) {
            this.eventElement(t).bind(e, i)
        }
        unbind(t, e, i) {
            const n = this.eventElement(t);
            n.unbind(e, i),
            n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1)
        }
        unbindAll() {
            this.eventElements.forEach(t => t.unbindAll()),
            this.eventElements = []
        }
        once(t, e, i) {
            const n = this.eventElement(t)
              , s = t => {
                n.unbind(e, s),
                i(t)
            }
            ;
            n.bind(e, s)
        }
    }
    function Wf(t) {
        if ("function" == typeof window.CustomEvent)
            return new CustomEvent(t);
        const e = document.createEvent("CustomEvent");
        return e.initCustomEvent(t, !1, !1, void 0),
        e
    }
    function Vf(t, e, i, n=!0, s=!1) {
        let o;
        if ("top" === e)
            o = ["contentHeight", "containerHeight", "scrollTop", "y", "up", "down"];
        else {
            if ("left" !== e)
                throw new Error("A proper axis should be provided");
            o = ["contentWidth", "containerWidth", "scrollLeft", "x", "left", "right"]
        }
        !function(t, e, [i,n,s,o,a,r], l=!0, h=!1) {
            const c = t.element;
            t.reach[o] = null,
            c[s] < 1 && (t.reach[o] = "start");
            c[s] > t[i] - t[n] - 1 && (t.reach[o] = "end");
            e && (c.dispatchEvent(Wf(`ps-scroll-${o}`)),
            e < 0 ? c.dispatchEvent(Wf(`ps-scroll-${a}`)) : e > 0 && c.dispatchEvent(Wf(`ps-scroll-${r}`)),
            l && function(t, e) {
                Hf(t, e),
                Ff(t, e)
            }(t, o));
            t.reach[o] && (e || h) && c.dispatchEvent(Wf(`ps-${o}-reach-${t.reach[o]}`))
        }(t, i, o, n, s)
    }
    function Yf(t) {
        return parseInt(t, 10) || 0
    }
    const Xf = {
        isWebKit: "undefined" != typeof document && "WebkitAppearance"in document.documentElement.style,
        supportsTouch: "undefined" != typeof window && ("ontouchstart"in window || "maxTouchPoints"in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
        supportsIePointer: "undefined" != typeof navigator && navigator.msMaxTouchPoints,
        isChrome: "undefined" != typeof navigator && /Chrome/i.test(navigator && navigator.userAgent)
    };
    function Kf(t) {
        const e = t.element
          , i = Math.floor(e.scrollTop)
          , n = e.getBoundingClientRect();
        t.containerWidth = Math.floor(n.width),
        t.containerHeight = Math.floor(n.height),
        t.contentWidth = e.scrollWidth,
        t.contentHeight = e.scrollHeight,
        e.contains(t.scrollbarXRail) || (If(e, Rf.rail("x")).forEach(t => $f(t)),
        e.appendChild(t.scrollbarXRail)),
        e.contains(t.scrollbarYRail) || (If(e, Rf.rail("y")).forEach(t => $f(t)),
        e.appendChild(t.scrollbarYRail)),
        !t.settings.suppressScrollX && t.containerWidth + t.settings.scrollXMarginOffset < t.contentWidth ? (t.scrollbarXActive = !0,
        t.railXWidth = t.containerWidth - t.railXMarginWidth,
        t.railXRatio = t.containerWidth / t.railXWidth,
        t.scrollbarXWidth = Uf(t, Yf(t.railXWidth * t.containerWidth / t.contentWidth)),
        t.scrollbarXLeft = Yf((t.negativeScrollAdjustment + e.scrollLeft) * (t.railXWidth - t.scrollbarXWidth) / (t.contentWidth - t.containerWidth))) : t.scrollbarXActive = !1,
        !t.settings.suppressScrollY && t.containerHeight + t.settings.scrollYMarginOffset < t.contentHeight ? (t.scrollbarYActive = !0,
        t.railYHeight = t.containerHeight - t.railYMarginHeight,
        t.railYRatio = t.containerHeight / t.railYHeight,
        t.scrollbarYHeight = Uf(t, Yf(t.railYHeight * t.containerHeight / t.contentHeight)),
        t.scrollbarYTop = Yf(i * (t.railYHeight - t.scrollbarYHeight) / (t.contentHeight - t.containerHeight))) : t.scrollbarYActive = !1,
        t.scrollbarXLeft >= t.railXWidth - t.scrollbarXWidth && (t.scrollbarXLeft = t.railXWidth - t.scrollbarXWidth),
        t.scrollbarYTop >= t.railYHeight - t.scrollbarYHeight && (t.scrollbarYTop = t.railYHeight - t.scrollbarYHeight),
        function(t, e) {
            const i = {
                width: e.railXWidth
            }
              , n = Math.floor(t.scrollTop);
            e.isRtl ? i.left = e.negativeScrollAdjustment + t.scrollLeft + e.containerWidth - e.contentWidth : i.left = t.scrollLeft;
            e.isScrollbarXUsingBottom ? i.bottom = e.scrollbarXBottom - n : i.top = e.scrollbarXTop + n;
            Ef(e.scrollbarXRail, i);
            const s = {
                top: n,
                height: e.railYHeight
            };
            e.isScrollbarYUsingRight ? e.isRtl ? s.right = e.contentWidth - (e.negativeScrollAdjustment + t.scrollLeft) - e.scrollbarYRight - e.scrollbarYOuterWidth - 9 : s.right = e.scrollbarYRight - t.scrollLeft : e.isRtl ? s.left = e.negativeScrollAdjustment + t.scrollLeft + 2 * e.containerWidth - e.contentWidth - e.scrollbarYLeft - e.scrollbarYOuterWidth : s.left = e.scrollbarYLeft + t.scrollLeft;
            Ef(e.scrollbarYRail, s),
            Ef(e.scrollbarX, {
                left: e.scrollbarXLeft,
                width: e.scrollbarXWidth - e.railBorderXWidth
            }),
            Ef(e.scrollbarY, {
                top: e.scrollbarYTop,
                height: e.scrollbarYHeight - e.railBorderYWidth
            })
        }(e, t),
        t.scrollbarXActive ? e.classList.add(Nf.active("x")) : (e.classList.remove(Nf.active("x")),
        t.scrollbarXWidth = 0,
        t.scrollbarXLeft = 0,
        e.scrollLeft = !0 === t.isRtl ? t.contentWidth : 0),
        t.scrollbarYActive ? e.classList.add(Nf.active("y")) : (e.classList.remove(Nf.active("y")),
        t.scrollbarYHeight = 0,
        t.scrollbarYTop = 0,
        e.scrollTop = 0)
    }
    function Uf(t, e) {
        return t.settings.minScrollbarLength && (e = Math.max(e, t.settings.minScrollbarLength)),
        t.settings.maxScrollbarLength && (e = Math.min(e, t.settings.maxScrollbarLength)),
        e
    }
    let qf = null;
    function Zf(t, [e,i,n,s,o,a,r,l,h]) {
        const c = t.element;
        let d = null
          , u = null
          , p = null;
        function f(e) {
            e.touches && e.touches[0] && (e[n] = e.touches[0][`page${l.toUpperCase()}`]),
            qf === o && (c[r] = d + p * (e[n] - u),
            Hf(t, l),
            Kf(t),
            e.stopPropagation(),
            e.preventDefault())
        }
        function g() {
            Ff(t, l),
            t[h].classList.remove(Nf.clicking),
            document.removeEventListener("mousemove", f),
            document.removeEventListener("mouseup", g),
            document.removeEventListener("touchmove", f),
            document.removeEventListener("touchend", g),
            qf = null
        }
        function m(m) {
            null === qf && (qf = o,
            d = c[r],
            m.touches && (m[n] = m.touches[0][`page${l.toUpperCase()}`]),
            u = m[n],
            p = (t[i] - t[e]) / (t[s] - t[a]),
            m.touches ? (document.addEventListener("touchmove", f, {
                passive: !1
            }),
            document.addEventListener("touchend", g)) : (document.addEventListener("mousemove", f),
            document.addEventListener("mouseup", g)),
            t[h].classList.add(Nf.clicking)),
            m.stopPropagation(),
            m.cancelable && m.preventDefault()
        }
        t[o].addEventListener("mousedown", m),
        t[o].addEventListener("touchstart", m)
    }
    const Gf = {
        "click-rail": function(t) {
            t.event.bind(t.scrollbarY, "mousedown", t => t.stopPropagation()),
            t.event.bind(t.scrollbarYRail, "mousedown", e => {
                const i = e.pageY - window.pageYOffset - t.scrollbarYRail.getBoundingClientRect().top > t.scrollbarYTop ? 1 : -1;
                t.element.scrollTop += i * t.containerHeight,
                Kf(t),
                e.stopPropagation()
            }
            ),
            t.event.bind(t.scrollbarX, "mousedown", t => t.stopPropagation()),
            t.event.bind(t.scrollbarXRail, "mousedown", e => {
                const i = e.pageX - window.pageXOffset - t.scrollbarXRail.getBoundingClientRect().left > t.scrollbarXLeft ? 1 : -1;
                t.element.scrollLeft += i * t.containerWidth,
                Kf(t),
                e.stopPropagation()
            }
            )
        },
        "drag-thumb": function(t) {
            Zf(t, ["containerHeight", "contentHeight", "pageY", "railYHeight", "scrollbarY", "scrollbarYHeight", "scrollTop", "y", "scrollbarYRail"]),
            Zf(t, ["containerWidth", "contentWidth", "pageX", "railXWidth", "scrollbarX", "scrollbarXWidth", "scrollLeft", "x", "scrollbarXRail"])
        },
        keyboard: function(t) {
            const e = t.element;
            t.event.bind(t.ownerDocument, "keydown", i => {
                if (i.isDefaultPrevented && i.isDefaultPrevented() || i.defaultPrevented)
                    return;
                if (!Df(e, ":hover") && !Df(t.scrollbarX, ":focus") && !Df(t.scrollbarY, ":focus"))
                    return;
                let n = document.activeElement ? document.activeElement : t.ownerDocument.activeElement;
                if (n) {
                    if ("IFRAME" === n.tagName)
                        n = n.contentDocument.activeElement;
                    else
                        for (; n.shadowRoot; )
                            n = n.shadowRoot.activeElement;
                    if (Df(s = n, "input,[contenteditable]") || Df(s, "select,[contenteditable]") || Df(s, "textarea,[contenteditable]") || Df(s, "button,[contenteditable]"))
                        return
                }
                var s;
                let o = 0
                  , a = 0;
                switch (i.which) {
                case 37:
                    o = i.metaKey ? -t.contentWidth : i.altKey ? -t.containerWidth : -30;
                    break;
                case 38:
                    a = i.metaKey ? t.contentHeight : i.altKey ? t.containerHeight : 30;
                    break;
                case 39:
                    o = i.metaKey ? t.contentWidth : i.altKey ? t.containerWidth : 30;
                    break;
                case 40:
                    a = i.metaKey ? -t.contentHeight : i.altKey ? -t.containerHeight : -30;
                    break;
                case 32:
                    a = i.shiftKey ? t.containerHeight : -t.containerHeight;
                    break;
                case 33:
                    a = t.containerHeight;
                    break;
                case 34:
                    a = -t.containerHeight;
                    break;
                case 36:
                    a = t.contentHeight;
                    break;
                case 35:
                    a = -t.contentHeight;
                    break;
                default:
                    return
                }
                t.settings.suppressScrollX && 0 !== o || t.settings.suppressScrollY && 0 !== a || (e.scrollTop -= a,
                e.scrollLeft += o,
                Kf(t),
                function(i, n) {
                    const s = Math.floor(e.scrollTop);
                    if (0 === i) {
                        if (!t.scrollbarYActive)
                            return !1;
                        if (0 === s && n > 0 || s >= t.contentHeight - t.containerHeight && n < 0)
                            return !t.settings.wheelPropagation
                    }
                    const o = e.scrollLeft;
                    if (0 === n) {
                        if (!t.scrollbarXActive)
                            return !1;
                        if (0 === o && i < 0 || o >= t.contentWidth - t.containerWidth && i > 0)
                            return !t.settings.wheelPropagation
                    }
                    return !0
                }(o, a) && i.preventDefault())
            }
            )
        },
        wheel: function(t) {
            const e = t.element;
            function i(i) {
                const [n,s] = function(t) {
                    let e = t.deltaX
                      , i = -1 * t.deltaY;
                    return void 0 !== e && void 0 !== i || (e = -1 * t.wheelDeltaX / 6,
                    i = t.wheelDeltaY / 6),
                    t.deltaMode && 1 === t.deltaMode && (e *= 10,
                    i *= 10),
                    e != e && i != i && (e = 0,
                    i = t.wheelDelta),
                    t.shiftKey ? [-i, -e] : [e, i]
                }(i);
                if (function(t, i, n) {
                    if (!Xf.isWebKit && e.querySelector("select:focus"))
                        return !0;
                    if (!e.contains(t))
                        return !1;
                    let s = t;
                    for (; s && s !== e; ) {
                        if (s.classList.contains(Rf.consuming))
                            return !0;
                        const t = Af(s);
                        if (n && t.overflowY.match(/(scroll|auto)/)) {
                            const t = s.scrollHeight - s.clientHeight;
                            if (t > 0 && (s.scrollTop > 0 && n < 0 || s.scrollTop < t && n > 0))
                                return !0
                        }
                        if (i && t.overflowX.match(/(scroll|auto)/)) {
                            const t = s.scrollWidth - s.clientWidth;
                            if (t > 0 && (s.scrollLeft > 0 && i < 0 || s.scrollLeft < t && i > 0))
                                return !0
                        }
                        s = s.parentNode
                    }
                    return !1
                }(i.target, n, s))
                    return;
                let o = !1;
                t.settings.useBothWheelAxes ? t.scrollbarYActive && !t.scrollbarXActive ? (s ? e.scrollTop -= s * t.settings.wheelSpeed : e.scrollTop += n * t.settings.wheelSpeed,
                o = !0) : t.scrollbarXActive && !t.scrollbarYActive && (n ? e.scrollLeft += n * t.settings.wheelSpeed : e.scrollLeft -= s * t.settings.wheelSpeed,
                o = !0) : (e.scrollTop -= s * t.settings.wheelSpeed,
                e.scrollLeft += n * t.settings.wheelSpeed),
                Kf(t),
                o = o || function(i, n) {
                    const s = Math.floor(e.scrollTop)
                      , o = 0 === e.scrollTop
                      , a = s + e.offsetHeight === e.scrollHeight
                      , r = 0 === e.scrollLeft
                      , l = e.scrollLeft + e.offsetWidth === e.scrollWidth;
                    let h;
                    return h = Math.abs(n) > Math.abs(i) ? o || a : r || l,
                    !h || !t.settings.wheelPropagation
                }(n, s),
                o && !i.ctrlKey && (i.stopPropagation(),
                i.preventDefault())
            }
            void 0 !== window.onwheel ? t.event.bind(e, "wheel", i) : void 0 !== window.onmousewheel && t.event.bind(e, "mousewheel", i)
        },
        touch: function(t) {
            if (!Xf.supportsTouch && !Xf.supportsIePointer)
                return;
            const e = t.element
              , i = {
                startOffset: {},
                startTime: 0,
                speed: {},
                easingLoop: null
            };
            function n(i, n) {
                e.scrollTop -= n,
                e.scrollLeft -= i,
                Kf(t)
            }
            function s(t) {
                return t.targetTouches ? t.targetTouches[0] : t
            }
            function o(e) {
                return e.target !== t.scrollbarX && e.target !== t.scrollbarY && ((!e.pointerType || "pen" !== e.pointerType || 0 !== e.buttons) && (!(!e.targetTouches || 1 !== e.targetTouches.length) || !(!e.pointerType || "mouse" === e.pointerType || e.pointerType === e.MSPOINTER_TYPE_MOUSE)))
            }
            function a(t) {
                if (!o(t))
                    return;
                const e = s(t);
                i.startOffset.pageX = e.pageX,
                i.startOffset.pageY = e.pageY,
                i.startTime = (new Date).getTime(),
                null !== i.easingLoop && clearInterval(i.easingLoop)
            }
            function r(a) {
                if (o(a)) {
                    const o = s(a)
                      , r = {
                        pageX: o.pageX,
                        pageY: o.pageY
                    }
                      , l = r.pageX - i.startOffset.pageX
                      , h = r.pageY - i.startOffset.pageY;
                    if (function(t, i, n) {
                        if (!e.contains(t))
                            return !1;
                        let s = t;
                        for (; s && s !== e; ) {
                            if (s.classList.contains(Rf.consuming))
                                return !0;
                            const t = Af(s);
                            if (n && t.overflowY.match(/(scroll|auto)/)) {
                                const t = s.scrollHeight - s.clientHeight;
                                if (t > 0 && (s.scrollTop > 0 && n < 0 || s.scrollTop < t && n > 0))
                                    return !0
                            }
                            if (i && t.overflowX.match(/(scroll|auto)/)) {
                                const t = s.scrollWidth - s.clientWidth;
                                if (t > 0 && (s.scrollLeft > 0 && i < 0 || s.scrollLeft < t && i > 0))
                                    return !0
                            }
                            s = s.parentNode
                        }
                        return !1
                    }(a.target, l, h))
                        return;
                    n(l, h),
                    i.startOffset = r;
                    const c = (new Date).getTime()
                      , d = c - i.startTime;
                    d > 0 && (i.speed.x = l / d,
                    i.speed.y = h / d,
                    i.startTime = c),
                    function(i, n) {
                        const s = Math.floor(e.scrollTop)
                          , o = e.scrollLeft
                          , a = Math.abs(i)
                          , r = Math.abs(n);
                        if (r > a) {
                            if (n < 0 && s === t.contentHeight - t.containerHeight || n > 0 && 0 === s)
                                return 0 === window.scrollY && n > 0 && Xf.isChrome
                        } else if (a > r && (i < 0 && o === t.contentWidth - t.containerWidth || i > 0 && 0 === o))
                            return !0;
                        return !0
                    }(l, h) && a.cancelable && a.preventDefault()
                }
            }
            function l() {
                t.settings.swipeEasing && (clearInterval(i.easingLoop),
                i.easingLoop = setInterval( () => {
                    t.isInitialized ? clearInterval(i.easingLoop) : i.speed.x || i.speed.y ? Math.abs(i.speed.x) < .01 && Math.abs(i.speed.y) < .01 ? clearInterval(i.easingLoop) : (n(30 * i.speed.x, 30 * i.speed.y),
                    i.speed.x *= .8,
                    i.speed.y *= .8) : clearInterval(i.easingLoop)
                }
                , 10))
            }
            Xf.supportsTouch ? (t.event.bind(e, "touchstart", a),
            t.event.bind(e, "touchmove", r),
            t.event.bind(e, "touchend", l)) : Xf.supportsIePointer && (window.PointerEvent ? (t.event.bind(e, "pointerdown", a),
            t.event.bind(e, "pointermove", r),
            t.event.bind(e, "pointerup", l)) : window.MSPointerEvent && (t.event.bind(e, "MSPointerDown", a),
            t.event.bind(e, "MSPointerMove", r),
            t.event.bind(e, "MSPointerUp", l)))
        }
    };
    class Qf {
        constructor(t, e={}) {
            if ("string" == typeof t && (t = document.querySelector(t)),
            !t || !t.nodeName)
                throw new Error("no element is specified to initialize PerfectScrollbar");
            this.element = t,
            t.classList.add(Lf),
            this.settings = {
                handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
                maxScrollbarLength: null,
                minScrollbarLength: null,
                scrollingThreshold: 1e3,
                scrollXMarginOffset: 0,
                scrollYMarginOffset: 0,
                suppressScrollX: !1,
                suppressScrollY: !1,
                swipeEasing: !0,
                useBothWheelAxes: !1,
                wheelPropagation: !0,
                wheelSpeed: 1
            };
            for (const a in e)
                this.settings[a] = e[a];
            this.containerWidth = null,
            this.containerHeight = null,
            this.contentWidth = null,
            this.contentHeight = null;
            const i = () => t.classList.add(Nf.focus)
              , n = () => t.classList.remove(Nf.focus);
            this.isRtl = "rtl" === Af(t).direction,
            !0 === this.isRtl && t.classList.add(Pf),
            this.isNegativeScroll = ( () => {
                const e = t.scrollLeft;
                let i = null;
                return t.scrollLeft = -1,
                i = t.scrollLeft < 0,
                t.scrollLeft = e,
                i
            }
            )(),
            this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0,
            this.event = new jf,
            this.ownerDocument = t.ownerDocument || document,
            this.scrollbarXRail = Mf(Rf.rail("x")),
            t.appendChild(this.scrollbarXRail),
            this.scrollbarX = Mf(Rf.thumb("x")),
            this.scrollbarXRail.appendChild(this.scrollbarX),
            this.scrollbarX.setAttribute("tabindex", 0),
            this.event.bind(this.scrollbarX, "focus", i),
            this.event.bind(this.scrollbarX, "blur", n),
            this.scrollbarXActive = null,
            this.scrollbarXWidth = null,
            this.scrollbarXLeft = null;
            const s = Af(this.scrollbarXRail);
            this.scrollbarXBottom = parseInt(s.bottom, 10),
            isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1,
            this.scrollbarXTop = Yf(s.top)) : this.isScrollbarXUsingBottom = !0,
            this.railBorderXWidth = Yf(s.borderLeftWidth) + Yf(s.borderRightWidth),
            Ef(this.scrollbarXRail, {
                display: "block"
            }),
            this.railXMarginWidth = Yf(s.marginLeft) + Yf(s.marginRight),
            Ef(this.scrollbarXRail, {
                display: ""
            }),
            this.railXWidth = null,
            this.railXRatio = null,
            this.scrollbarYRail = Mf(Rf.rail("y")),
            t.appendChild(this.scrollbarYRail),
            this.scrollbarY = Mf(Rf.thumb("y")),
            this.scrollbarYRail.appendChild(this.scrollbarY),
            this.scrollbarY.setAttribute("tabindex", 0),
            this.event.bind(this.scrollbarY, "focus", i),
            this.event.bind(this.scrollbarY, "blur", n),
            this.scrollbarYActive = null,
            this.scrollbarYHeight = null,
            this.scrollbarYTop = null;
            const o = Af(this.scrollbarYRail);
            this.scrollbarYRight = parseInt(o.right, 10),
            isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1,
            this.scrollbarYLeft = Yf(o.left)) : this.isScrollbarYUsingRight = !0,
            this.scrollbarYOuterWidth = this.isRtl ? function(t) {
                const e = Af(t);
                return Yf(e.width) + Yf(e.paddingLeft) + Yf(e.paddingRight) + Yf(e.borderLeftWidth) + Yf(e.borderRightWidth)
            }(this.scrollbarY) : null,
            this.railBorderYWidth = Yf(o.borderTopWidth) + Yf(o.borderBottomWidth),
            Ef(this.scrollbarYRail, {
                display: "block"
            }),
            this.railYMarginHeight = Yf(o.marginTop) + Yf(o.marginBottom),
            Ef(this.scrollbarYRail, {
                display: ""
            }),
            this.railYHeight = null,
            this.railYRatio = null,
            this.reach = {
                x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
                y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
            },
            this.isAlive = !0,
            this.settings.handlers.forEach(t => Gf[t](this)),
            this.lastScrollTop = Math.floor(t.scrollTop),
            this.lastScrollLeft = t.scrollLeft,
            this.event.bind(this.element, "scroll", t => this.onScroll(t)),
            Kf(this)
        }
        update() {
            this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0,
            Ef(this.scrollbarXRail, {
                display: "block"
            }),
            Ef(this.scrollbarYRail, {
                display: "block"
            }),
            this.railXMarginWidth = Yf(Af(this.scrollbarXRail).marginLeft) + Yf(Af(this.scrollbarXRail).marginRight),
            this.railYMarginHeight = Yf(Af(this.scrollbarYRail).marginTop) + Yf(Af(this.scrollbarYRail).marginBottom),
            Ef(this.scrollbarXRail, {
                display: "none"
            }),
            Ef(this.scrollbarYRail, {
                display: "none"
            }),
            Kf(this),
            Vf(this, "top", 0, !1, !0),
            Vf(this, "left", 0, !1, !0),
            Ef(this.scrollbarXRail, {
                display: ""
            }),
            Ef(this.scrollbarYRail, {
                display: ""
            }))
        }
        onScroll(t) {
            this.isAlive && (Kf(this),
            Vf(this, "top", this.element.scrollTop - this.lastScrollTop),
            Vf(this, "left", this.element.scrollLeft - this.lastScrollLeft),
            this.lastScrollTop = Math.floor(this.element.scrollTop),
            this.lastScrollLeft = this.element.scrollLeft)
        }
        destroy() {
            this.isAlive && (this.event.unbindAll(),
            $f(this.scrollbarX),
            $f(this.scrollbarY),
            $f(this.scrollbarXRail),
            $f(this.scrollbarYRail),
            this.removePsClasses(),
            this.element = null,
            this.scrollbarX = null,
            this.scrollbarY = null,
            this.scrollbarXRail = null,
            this.scrollbarYRail = null,
            this.isAlive = !1)
        }
        removePsClasses() {
            this.element.className = this.element.className.split(" ").filter(t => !t.match(/^ps([-_].+|)$/)).join(" ")
        }
    }
    class Jf {
        constructor(t, e={}, i) {
            this._element = t,
            this._toggler = i,
            this._event = e.event || "blur",
            this._condition = e.condition || ( () => !0),
            this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])',
            this._onlyVisible = e.onlyVisible || !1,
            this._focusableElements = [],
            this._firstElement = null,
            this._lastElement = null,
            this.handler = t => {
                this._condition(t) && t.target === this._lastElement && (t.preventDefault(),
                this._firstElement.focus())
            }
        }
        trap() {
            this._setElements(),
            this._init(),
            this._setFocusTrap()
        }
        disable() {
            this._focusableElements.forEach(t => {
                t.removeEventListener(this._event, this.handler)
            }
            ),
            this._toggler && this._toggler.focus()
        }
        update() {
            this._setElements(),
            this._setFocusTrap()
        }
        _init() {
            const t = e => {
                this._firstElement && "Tab" === e.key && !this._focusableElements.includes(e.target) && (e.preventDefault(),
                this._firstElement.focus(),
                window.removeEventListener("keydown", t))
            }
            ;
            window.addEventListener("keydown", t)
        }
        _filterVisible(t) {
            return t.filter(t => {
                if (!u(t))
                    return !1;
                const e = B.parents(t, "*");
                for (let i = 0; i < e.length; i++) {
                    const t = window.getComputedStyle(e[i]);
                    if (t && ("none" === t.display || "hidden" === t.visibility))
                        return !1
                }
                return !0
            }
            )
        }
        _setElements() {
            const t = B.find(this._selector, this._element);
            this._focusableElements = t.filter(t => {
                const e = "true" === t.getAttribute("data-mdb-disabled") || t.hasAttribute("disabled");
                return t.disabled || e ? null : t
            }
            ),
            this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)),
            this._firstElement = this._focusableElements[0],
            this._lastElement = this._focusableElements[this._focusableElements.length - 1]
        }
        _setFocusTrap() {
            this._focusableElements.forEach( (t, e) => {
                e === this._focusableElements.length - 1 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler)
            }
            )
        }
    }
    const tg = 37
      , eg = 38
      , ig = 39
      , ng = 40
      , sg = 36
      , og = 35
      , ag = 13
      , rg = 32
      , lg = 27
      , hg = {
        threshold: 10,
        direction: "all"
    };
    let cg = class {
        constructor(t, e) {
            this._element = t,
            this._startPosition = null,
            this._options = {
                ...hg,
                ...e
            }
        }
        handleTouchStart(t) {
            this._startPosition = this._getCoordinates(t)
        }
        handleTouchMove(t) {
            if (!this._startPosition)
                return;
            const e = this._getCoordinates(t)
              , i = {
                x: e.x - this._startPosition.x,
                y: e.y - this._startPosition.y
            }
              , n = this._getDirection(i);
            if ("all" === this._options.direction) {
                if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)
                    return;
                const t = n.y.value > n.x.value ? n.y.direction : n.x.direction;
                return I.trigger(this._element, `swipe${t}`),
                I.trigger(this._element, "swipe", {
                    direction: t
                }),
                void (this._startPosition = null)
            }
            const s = "left" === this._options.direction || "right" === this._options ? "x" : "y";
            n[s].direction === this._options.direction && n[s].value > this._options.threshold && (I.trigger(this._element, `swipe${n[s].direction}`),
            this._startPosition = null)
        }
        handleTouchEnd() {
            this._startPosition = null
        }
        _getCoordinates(t) {
            const [e] = t.touches;
            return {
                x: e.clientX,
                y: e.clientY
            }
        }
        _getDirection(t) {
            return {
                x: {
                    direction: t.x < 0 ? "left" : "right",
                    value: Math.abs(t.x)
                },
                y: {
                    direction: t.y < 0 ? "up" : "down",
                    value: Math.abs(t.y)
                }
            }
        }
    }
      , dg = class {
        constructor(t, e="swipe", i={}) {
            this._element = t,
            this._event = e,
            this.swipe = new cg(t,i),
            this._touchStartHandler = this._handleTouchStart.bind(this),
            this._touchMoveHandler = this._handleTouchMove.bind(this),
            this._touchEndHandler = this._handleTouchEnd.bind(this)
        }
        dispose() {
            this._element.removeEventListener("touchstart", this._touchStartHandler),
            this._element.removeEventListener("touchmove", this._touchMoveHandler),
            window.removeEventListener("touchend", this._touchEndHandler)
        }
        init() {
            this._element.addEventListener("touchstart", t => this._handleTouchStart(t)),
            this._element.addEventListener("touchmove", t => this._handleTouchMove(t)),
            window.addEventListener("touchend", t => this._handleTouchEnd(t))
        }
        _handleTouchStart(t) {
            this[this._event].handleTouchStart(t)
        }
        _handleTouchMove(t) {
            this[this._event].handleTouchMove(t)
        }
        _handleTouchEnd(t) {
            this[this._event].handleTouchEnd(t)
        }
    }
    ;
    const ug = "sidenav"
      , pg = "mdb.sidenav"
      , fg = "rotate-icon"
      , gg = '[data-mdb-toggle="sidenav"]'
      , mg = ".sidenav-collapse"
      , _g = ".sidenav-link"
      , bg = m ? 100 : -100
      , vg = m ? -100 : 100;
    let yg = 0;
    const xg = {
        accordion: "(boolean)",
        backdrop: "(boolean)",
        backdropClass: "(null|string)",
        closeOnEsc: "(boolean)",
        color: "(string)",
        content: "(null|string)",
        expandable: "(boolean)",
        expandOnHover: "(boolean)",
        focusTrap: "(boolean)",
        hidden: "(boolean)",
        mode: "(string)",
        scrollContainer: "(null|string)",
        slim: "(boolean)",
        slimCollapsed: "(boolean)",
        slimWidth: "(number)",
        position: "(string)",
        right: "(boolean)",
        transitionDuration: "(number)",
        width: "(number)",
        disableWindowScroll: "(boolean)"
    }
      , wg = {
        accordion: !1,
        backdrop: !0,
        backdropClass: null,
        closeOnEsc: !0,
        color: "primary",
        content: null,
        expandable: !0,
        expandOnHover: !1,
        focusTrap: !0,
        hidden: !0,
        mode: "over",
        scrollContainer: null,
        slim: !1,
        slimCollapsed: !1,
        slimWidth: 77,
        position: "fixed",
        right: !1,
        transitionDuration: 300,
        width: 240,
        disableWindowScroll: !1
    };
    class Cg extends ao {
        constructor(t, e={}) {
            super(t),
            this._options = e,
            yg++,
            this._ID = yg,
            this._backdrop = null,
            this._content = null,
            this._initialContentStyle = null,
            this._slimCollapsed = !1,
            this._activeNode = null,
            this._tempSlim = !1,
            this._focusTrap = null,
            this._perfectScrollbar = null,
            this._touch = null,
            this._scrollBar = new ce,
            this.escHandler = t => {
                t.keyCode === lg && this.toggler && u(this.toggler) && (this._update(!1),
                I.off(window, "keydown", this.escHandler))
            }
            ,
            this.hashHandler = () => {
                this._setActiveElements()
            }
            ,
            t && this._setup(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return ug
        }
        get container() {
            if ("fixed" === this.options.position)
                return B.findOne("body");
            const t = e => {
                if (!e.parentNode || e.parentNode === document)
                    return e;
                return "relative" === e.parentNode.style.position || e.parentNode.classList.contains("position-relative") ? e.parentNode : t(e.parentNode)
            }
            ;
            return t(this._element)
        }
        get isVisible() {
            let t = 0
              , e = window.innerWidth;
            if ("fixed" !== this.options.position) {
                const i = this.container.getBoundingClientRect();
                t = i.x,
                e = i.x + i.width
            }
            const {x: i} = this._element.getBoundingClientRect();
            if (this.options.right && !m || !this.options.right && m) {
                let t = 0;
                if (this.container.scrollHeight > this.container.clientHeight && (t = this.container.offsetWidth - this.container.clientWidth),
                "BODY" === this.container.tagName) {
                    const e = document.documentElement.clientWidth;
                    t = Math.abs(window.innerWidth - e)
                }
                return Math.abs(i + t - e) > 10
            }
            return Math.abs(i - t) < 10
        }
        get links() {
            return B.find(_g, this._element)
        }
        get navigation() {
            return B.find(".sidenav-menu", this._element)
        }
        get options() {
            const t = {
                ...wg,
                ...N.getDataAttributes(this._element),
                ...this._options
            };
            return d(ug, t, xg),
            t
        }
        get sidenavStyle() {
            return {
                width: `${this.width}px`,
                height: "fixed" === this.options.position ? "100vh" : "100%",
                position: this.options.position,
                transitionDuration: this.transitionDuration,
                transitionProperty: "transform, width, padding, margin",
                transitionTimingFunction: "linear"
            }
        }
        get toggler() {
            return B.find(gg).find(t => {
                const e = N.getDataAttribute(t, "target");
                return B.findOne(e) === this._element
            }
            )
        }
        get transitionDuration() {
            return this.options.transitionDuration / 1e3 + "s"
        }
        get translation() {
            return this.options.right ? vg : bg
        }
        get width() {
            return this._slimCollapsed ? this.options.slimWidth : this.options.width
        }
        changeMode(t) {
            this._setMode(t)
        }
        dispose() {
            this._backdrop && this._removeBackdrop(),
            I.off(window, "keydown", this.escHandler),
            I.off(window, "hashchange", this.hashHandler),
            this._touch.dispose(),
            s.removeData(this._element, pg),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        hide() {
            this._setVisibility(!1),
            this._update(!1)
        }
        show() {
            this._setVisibility(!0),
            this._update(!0)
        }
        toggle() {
            this._setVisibility(!this.isVisible),
            this._update(!this.isVisible)
        }
        toggleSlim() {
            this._setSlim(!this._slimCollapsed)
        }
        update(t) {
            this._options = t,
            this._setup()
        }
        _appendArrow(t) {
            const e = _("i");
            ["fas", "fa-angle-down", fg].forEach(t => {
                N.addClass(e, t)
            }
            ),
            0 === B.find(`.${fg}`, t).length && t.appendChild(e)
        }
        _collapseItems() {
            this.navigation.forEach(t => {
                B.find(mg, t).forEach(t => {
                    Eo.getInstance(t).hide()
                }
                )
            }
            )
        }
        _setupBackdrop() {
            const t = [];
            this.options.backdropClass && t.push(this.options.backdropClass);
            const e = {
                transition: `opacity ${this.transitionDuration} ease-out`,
                position: this.options.position,
                width: "fixed" === this.options.position ? "100vw" : "100%",
                height: "fixed" === this.options.position ? "100vh" : "100%"
            };
            if (!this._backdrop) {
                const i = _("div");
                t.push("sidenav-backdrop"),
                e.opacity = 0,
                I.on(i, "click", () => {
                    this._setVisibility(!1),
                    this._update(!1)
                }
                ),
                this._backdrop = i
            }
            this._backdrop.classList.add(...t),
            N.style(this._backdrop, e)
        }
        _getOffsetValue(t, {index: e, property: i, offsets: n}) {
            return this._getPxValue(this._initialContentStyle[e][n[i].property]) + (t ? n[i].value : 0)
        }
        _getProperty(...t) {
            return t.map( (t, e) => 0 === e ? t : t[0].toUpperCase().concat(t.slice(1))).join("")
        }
        _getPxValue(t) {
            return t ? parseFloat(t) : 0
        }
        _handleSwipe(t, e) {
            e && this._slimCollapsed && this.options.slim && this.options.expandable ? this.toggleSlim() : e || (!this._slimCollapsed && this.options.slim && this.options.expandable ? this.toggleSlim() : this.toggler && u(this.toggler) && this.toggle())
        }
        _isActive(t, e) {
            if (e)
                return e === t;
            if (t.attributes.href) {
                const e = window.location.href.split(/#|\?/)[0]
                  , i = window.location.href.split("?")[0];
                return new URL(t,window.location.href).href === e || new URL(t,window.location.href).href === i
            }
            return !1
        }
        _isAllToBeCollapsed() {
            return 0 === B.find("[data-mdb-collapse-init]", this._element).filter(t => "true" === t.getAttribute("aria-expanded")).length
        }
        _isAllCollapsed() {
            return 0 === B.find(mg, this._element).filter(t => u(t)).length
        }
        _setup() {
            this._setupTouch(),
            this.options.focusTrap && this._setupFocusTrap(),
            this.options.backdrop && (this._setupBackdrop(),
            this.options.hidden || "over" !== this.options.mode || this._appendBackdrop()),
            this._setupCollapse(),
            this.options.slimCollapsed && N.addClass(this._element, "sidenav-slim"),
            this.options.slim && this._setupSlim(),
            this._setupInitialStyling(),
            this._setupScrolling(),
            this.options.content && this._setupContent(),
            this._setupActiveState(),
            this._setupRippleEffect(),
            this.options.hidden || (this.options.right && this.show(),
            this._updateOffsets(!0, !0),
            this.options.disableWindowScroll && this._updateDisableScroll(!0))
        }
        _setupActiveState() {
            this._setActiveElements(),
            this.links.forEach(t => {
                I.on(t, "click", () => this._setActiveElements(t)),
                I.on(t, "keydown", e => {
                    e.keyCode === ag && this._setActiveElements(t)
                }
                )
            }
            ),
            I.on(window, "hashchange", this.hashHandler)
        }
        _setupCollapse() {
            this.navigation.forEach( (t, e) => {
                B.find(mg, t).forEach( (i, n) => this._setupCollapseList({
                    list: i,
                    index: n,
                    menu: t,
                    menuIndex: e
                }))
            }
            )
        }
        _generateCollpaseID(t, e) {
            return `sidenav-collapse-${this._ID}-${e}-${t}`
        }
        _setupCollapseList({list: t, index: e, menu: i, menuIndex: n}) {
            const s = this._generateCollpaseID(e, n);
            t.classList.add("collapse"),
            t.setAttribute("id", s);
            const [o] = B.prev(t, _g);
            N.setDataAttribute(o, "collapse-init", ""),
            o.setAttribute("href", `#${s}`),
            o.setAttribute("role", "button");
            const a = Eo.getInstance(t) || new Eo(t,{
                toggle: !1,
                parent: this.options.accordion ? i : t
            });
            this._appendArrow(o),
            N.hasClass(t, "show") && this._rotateArrow(o, 180),
            I.on(o, "click", e => {
                this._toggleCategory(e, a, t),
                this._tempSlim && this._isAllToBeCollapsed() && (this._setSlim(!0),
                this._tempSlim = !1),
                "over" === this.options.mode && this._focusTrap && this._focusTrap.update()
            }
            ),
            I.on(t, "show.bs.collapse", () => this._rotateArrow(o, 180)),
            I.on(t, "hide.bs.collapse", () => this._rotateArrow(o, 0)),
            I.on(t, "shown.bs.collapse", () => {
                "over" === this.options.mode && this._focusTrap && this._focusTrap.update()
            }
            ),
            I.on(t, "hidden.bs.collapse", () => {
                this._tempSlim && this._isAllCollapsed() && (this._setSlim(!0),
                this._tempSlim = !1),
                "over" === this.options.mode && this._focusTrap && this._focusTrap.update()
            }
            )
        }
        _setupContent() {
            this._content = B.find(this.options.content),
            this._initialContentStyle || (this._initialContentStyle = this._content.map(t => {
                const {paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: s, transition: o} = window.getComputedStyle(t);
                return {
                    paddingLeft: e,
                    paddingRight: i,
                    marginLeft: n,
                    marginRight: s,
                    transition: o
                }
            }
            ))
        }
        _setupFocusTrap() {
            this._focusTrap = new Jf(this._element,{
                event: "keydown",
                condition: t => 9 === t.keyCode,
                onlyVisible: !0
            },this.toggler)
        }
        _setupInitialStyling() {
            this._setColor(),
            N.style(this._element, this.sidenavStyle)
        }
        _setupScrolling() {
            let t = this._element;
            if (this.options.scrollContainer) {
                t = B.findOne(this.options.scrollContainer, this._element);
                const i = (e = t.parentNode.children,
                Array.from(e)).filter(e => e !== t).reduce( (t, e) => t + e.clientHeight, 0);
                N.style(t, {
                    maxHeight: `calc(100% - ${i}px)`,
                    position: "relative"
                })
            }
            var e;
            this._perfectScrollbar = new Qf(t,{
                suppressScrollX: !0,
                handlers: ["click-rail", "drag-thumb", "wheel", "touch"]
            })
        }
        _setupSlim() {
            this._slimCollapsed = this.options.slimCollapsed,
            this._toggleSlimDisplay(this._slimCollapsed),
            this.options.expandOnHover && (this._element.addEventListener("mouseenter", () => {
                this._slimCollapsed && this._setSlim(!1)
            }
            ),
            this._element.addEventListener("mouseleave", () => {
                this._slimCollapsed || this._setSlim(!0)
            }
            ))
        }
        _setupRippleEffect() {
            this.links.forEach(t => {
                let e = Sa.getInstance(t);
                if (e && e._options.color !== this.options.color)
                    e.dispose();
                else if (e)
                    return;
                e = new Sa(t,{
                    rippleColor: this.options.color
                })
            }
            )
        }
        _setupTouch() {
            this._touch = new dg(this._element,"swipe",{
                threshold: 20
            }),
            this._touch.init(),
            I.on(this._element, "swipeleft", t => this._handleSwipe(t, this.options.right)),
            I.on(this._element, "swiperight", t => this._handleSwipe(t, !this.options.right))
        }
        _setActive(t, e) {
            N.addClass(t, "active"),
            this._activeNode && this._activeNode.classList.remove("active"),
            this._activeNode = t;
            const [i] = B.parents(this._activeNode, mg);
            if (!i)
                return void this._setActiveCategory();
            const [n] = B.prev(i, _g);
            this._setActiveCategory(n),
            e || this._slimCollapsed || Eo.getInstance(i).show()
        }
        _setActiveCategory(t) {
            this.navigation.forEach(e => {
                B.find(mg, e).forEach(e => {
                    const [i] = B.prev(e, _g);
                    i !== t ? i.classList.remove("active") : N.addClass(i, "active")
                }
                )
            }
            )
        }
        _setActiveElements(t) {
            this.navigation.forEach(e => {
                B.find(_g, e).filter(t => 0 === B.next(t, mg).length).forEach(e => {
                    this._isActive(e, t) && e !== this._activeNode && this._setActive(e, t)
                }
                )
            }
            )
        }
        _setColor() {
            const t = ["primary", "secondary", "success", "info", "warning", "danger", "light", "dark"]
              , {color: e} = this.options
              , i = t.includes(e) ? e : "primary";
            t.forEach(t => {
                this._element.classList.remove(`sidenav-${t}`)
            }
            ),
            N.addClass(this._element, `sidenav-${i}`)
        }
        _setContentOffsets(t, e, i) {
            this._content.forEach( (n, s) => {
                const o = this._getOffsetValue(t, {
                    index: s,
                    property: "padding",
                    offsets: e
                })
                  , a = this._getOffsetValue(t, {
                    index: s,
                    property: "margin",
                    offsets: e
                })
                  , r = {};
                i || (r.transition = `all ${this.transitionDuration} linear`),
                r[e.padding.property] = `${o}px`,
                r[e.margin.property] = `${a}px`,
                N.style(n, r),
                t && (i ? N.style(n, {
                    transition: this._initialContentStyle[s].transition
                }) : I.on(n, "transitionend", () => {
                    N.style(n, {
                        transition: this._initialContentStyle[s].transition
                    })
                }
                ))
            }
            )
        }
        _setMode(t) {
            this.options.mode !== t && (this._options.mode = t,
            this._update(this.isVisible))
        }
        _setSlim(t) {
            const e = t ? ["collapse", "collapsed"] : ["expand", "expanded"];
            this._triggerEvents(...e),
            t ? (this._collapseItems(),
            N.addClass(this._element, "sidenav-slim")) : N.removeClass(this._element, "sidenav-slim"),
            this._slimCollapsed = t,
            this._toggleSlimDisplay(t),
            N.style(this._element, {
                width: `${this.width}px`
            }),
            this._updateOffsets(this.isVisible)
        }
        _setTabindex(t) {
            this.links.forEach(e => {
                e.tabIndex = t ? 1 : -1
            }
            )
        }
        _setVisibility(t) {
            const e = t ? ["show", "shown"] : ["hide", "hidden"];
            this._triggerEvents(...e)
        }
        _rotateArrow(t, e) {
            const [i] = B.children(t, `.${fg}`);
            i && N.style(i, {
                transform: `rotate(${e}deg)`
            })
        }
        async _toggleBackdrop(t) {
            t && "over" === this.options.mode ? this._appendBackdrop() : (N.style(this._backdrop, {
                opacity: 0
            }),
            await setTimeout( () => {
                this._removeBackdrop()
            }
            , this.options.transitionDuration))
        }
        _removeBackdrop() {
            this._backdrop.parentNode === this.container && this.container.removeChild(this._backdrop)
        }
        _appendBackdrop() {
            this.container.appendChild(this._backdrop),
            setTimeout( () => N.style(this._backdrop, {
                opacity: 1
            }), 0)
        }
        _toggleCategory(t, e) {
            t.preventDefault(),
            e.toggle(),
            this._slimCollapsed && this.options.expandable && (this._tempSlim = !0,
            this._setSlim(!1))
        }
        _toggleSlimDisplay(t) {
            const e = B.find('[data-mdb-slim="true"]', this._element)
              , i = B.find('[data-mdb-slim="false"]', this._element)
              , n = () => {
                e.forEach(t => {
                    N.style(t, {
                        display: this._slimCollapsed ? "unset" : "none"
                    })
                }
                ),
                i.forEach(t => {
                    N.style(t, {
                        display: this._slimCollapsed ? "none" : "unset"
                    })
                }
                )
            }
            ;
            t ? setTimeout( () => n(), this.options.transitionDuration) : n()
        }
        async _triggerEvents(t, e) {
            I.trigger(this._element, `${t}.mdb.sidenav`),
            e && await setTimeout( () => {
                I.trigger(this._element, `${e}.mdb.sidenav`)
            }
            , this.options.transitionDuration + 5)
        }
        _update(t) {
            this.toggler && this._updateTogglerAria(t),
            this._updateDisplay(t),
            this.options.backdrop && this._toggleBackdrop(t),
            this._updateOffsets(t),
            t && this.options.closeOnEsc && "side" !== this.options.mode && I.on(window, "keydown", this.escHandler),
            this.options.focusTrap && this._updateFocus(t),
            this.options.disableWindowScroll && this._updateDisableScroll(t)
        }
        _updateDisplay(t) {
            const e = t ? 0 : this.translation;
            N.style(this._element, {
                transform: `translateX(${e}%)`
            })
        }
        _updateDisableScroll(t) {
            "over" === this.options.mode && t ? this._scrollBar.hide() : this._scrollBar.reset()
        }
        _updateFocus(t) {
            if (this._setTabindex(t),
            "over" === this.options.mode && this.options.focusTrap) {
                if (t)
                    return void this._focusTrap.trap();
                this._focusTrap.disable()
            }
            this._focusTrap.disable()
        }
        _updateOffsets(t, e=!1) {
            const [i,n] = this.options.right && !m || !this.options.right && m ? ["right", "left"] : ["left", "right"]
              , s = {
                property: this._getProperty("padding", i),
                value: "over" === this.options.mode ? 0 : this.width
            }
              , o = {
                property: this._getProperty("margin", n),
                value: "push" === this.options.mode ? -1 * this.width : 0
            };
            I.trigger(this._element, "update.mdb.sidenav", {
                margin: o,
                padding: s
            }),
            this._content && this._setContentOffsets(t, {
                padding: s,
                margin: o
            }, e)
        }
        _updateTogglerAria(t) {
            this.toggler.setAttribute("aria-expanded", t)
        }
        static toggleSidenav() {
            return function(t) {
                const e = B.closest(t.target, gg)
                  , i = N.getDataAttributes(e).target;
                B.find(i).forEach(t => {
                    (Cg.getInstance(t) || new Cg(t)).toggle()
                }
                )
            }
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                let i = s.getData(this, pg);
                const n = "object" == typeof t && t;
                if ((i || !/dispose/.test(t)) && (i || (i = new Cg(this,n)),
                "string" == typeof t)) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
    }
    const kg = ".bs.alert"
      , Sg = `close${kg}`
      , Tg = `closed${kg}`;
    let Ag = class t extends Ct {
        static get NAME() {
            return "alert"
        }
        close() {
            if (_t.trigger(this._element, Sg).defaultPrevented)
                return;
            this._element.classList.remove("show");
            const t = this._element.classList.contains("fade");
            this._queueCallback( () => this._destroyElement(), this._element, t)
        }
        _destroyElement() {
            this._element.remove(),
            _t.trigger(this._element, Tg),
            this.dispose()
        }
        static jQueryInterface(e) {
            return this.each(function() {
                const i = t.getOrCreateInstance(this);
                if ("string" == typeof e) {
                    if (void 0 === i[e] || e.startsWith("_") || "constructor" === e)
                        throw new TypeError(`No method named "${e}"`);
                    i[e](this)
                }
            })
        }
    }
    ;
    const Eg = {
        position: "top",
        container: null,
        refresh: 1e3,
        filter: t => t
    }
      , Mg = {
        position: "string",
        container: "(undefined|null|string)",
        refresh: "number",
        filter: "function"
    };
    class Og {
        constructor(t, e, i) {
            this._element = t,
            this._selector = e,
            this._options = this._getConfig(i),
            this._offset = null,
            this._options.container && (this._parent = B.findOne(this._options.container))
        }
        get stackableElements() {
            return B.find(this._selector).filter( (t, e) => this._options.filter(t, e)).map(t => ({
                el: t,
                rect: t.getBoundingClientRect()
            })).filter( ({el: t, rect: e}) => {
                const i = t !== this._element && u(t);
                return null === this._offset ? i : i && this._getBoundryOffset(e) < this._offset
            }
            ).sort( (t, e) => this._getBoundryOffset(e.rect) - this._getBoundryOffset(t.rect))
        }
        get nextElements() {
            return B.find(this._selector).filter(t => t !== this._element).filter( (t, e) => this._options.filter(t, e)).filter(t => (this._offset = null,
            this._getBoundryOffset(t.getBoundingClientRect()) > this._offset))
        }
        _getConfig(t) {
            const e = {
                ...Eg,
                ...t
            };
            return d("Stack", e, Mg),
            e
        }
        _getBoundryOffset(t) {
            const {position: e} = this._options;
            let i = 0
              , n = window.innerHeight;
            if (this._parent) {
                const t = this._parent.getBoundingClientRect();
                i = t.top,
                n = t.bottom
            }
            return "top" === e ? t.top - i : n - t.bottom
        }
        calculateOffset() {
            const [t] = this.stackableElements;
            return this._offset = t ? this._getBoundryOffset(t.rect) + t.rect.height : 0,
            this._offset
        }
    }
    const Dg = "alert"
      , $g = `.${`mdb.${Dg}`}`
      , Ig = "closed.bs.alert"
      , Lg = `hide${$g}`
      , Pg = `hidden${$g}`
      , Rg = `show${$g}`
      , Ng = `shown${$g}`
      , Bg = [{
        name: "close"
    }, {
        name: "closed"
    }]
      , Hg = {
        position: "(string || null)",
        delay: "number",
        autohide: "boolean",
        width: "(string || null)",
        offset: "number",
        stacking: "boolean",
        hidden: "boolean",
        appendToBody: "boolean",
        color: "(string || null)",
        container: "(string|null)"
    }
      , Fg = {
        position: null,
        delay: 1e3,
        autohide: !1,
        width: null,
        offset: 10,
        stacking: !1,
        hidden: !1,
        appendToBody: !1,
        color: null,
        container: null
    };
    class zg extends Ag {
        constructor(t, e={}) {
            super(t, e),
            this._options = this._getConfig(e),
            this._isOpen = !0,
            this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        dispose() {
            I.off(this._element, "close.bs.alert"),
            I.off(this._element, Ig),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        get verticalOffset() {
            return this._options.stacking ? this.stackUtil.calculateOffset() : 0
        }
        get parent() {
            const [t] = B.parents(this._element, this._options.container);
            return t
        }
        get position() {
            const [t,e] = this._options.position.split("-");
            return {
                y: t,
                x: e
            }
        }
        update(t={}) {
            null !== this._timeout && (clearTimeout(this._timeout),
            this._timeout = null),
            this._options = this._getConfig(t),
            this._setup()
        }
        hide() {
            const t = I.trigger(this._element, Lg);
            if (this._isOpen && !t.defaultPrevented && this._element && this._element.classList.contains("show")) {
                N.toggleClass(this._element, "show");
                const t = e => {
                    N.style(e.target, {
                        display: "none"
                    }),
                    null !== this._timeout && (clearTimeout(this._timeout),
                    this._timeout = null),
                    this._options.stacking && this._updateAlertStack(),
                    I.off(e.target, "transitionend", t),
                    I.trigger(this._element, Pg),
                    this._isOpen = !1
                }
                ;
                I.on(this._element, "transitionend", t)
            }
        }
        show() {
            const t = I.trigger(this._element, Rg);
            if (!this._isOpen && !t.defaultPrevented && (this._options.autohide && this._setupAutohide(),
            this._options.stacking && this._updateAlertStack(),
            !this._element.classList.contains("show") && (N.style(this._element, {
                display: "block"
            }),
            u(this._element)))) {
                const t = e => {
                    N.style(e.target, {
                        display: "block"
                    }),
                    I.off(e.target, "transitionend", t),
                    I.trigger(this._element, Ng),
                    this._isOpen = !0
                }
                ;
                N.toggleClass(this._element, "show"),
                this._options.position && this._setupAlignment(),
                I.on(this._element, "transitionend", t)
            }
        }
        _init() {
            this._options.hidden && (N.style(this._element, {
                display: "none"
            }),
            N.removeClass(this._element, "show"),
            this._isOpen = !1),
            this._bindMdbEvents(),
            this._setup()
        }
        _setup() {
            this._options.color && this._setColor(),
            this._options.stacking && this._setupStacking(),
            this._options.autohide && !this._options.hidden && this._setupAutohide(),
            this._options.width && this._setupWidth(),
            this._options.appendToBody && this._appendToBody(),
            this._options.position && (this._setupAlignment(),
            this._setupPosition())
        }
        _setupStacking() {
            this.stackUtil = new Og(this._element,".alert",{
                position: this.position.y,
                offset: this._options.offset,
                container: this._options.container,
                filter: t => {
                    const e = zg.getInstance(t);
                    return !!e && (e._options.container === this._options.container && e._options.position === this._options.position)
                }
            }),
            I.on(this._element, Ig, () => {
                this._updateAlertStack()
            }
            )
        }
        _setColor() {
            const t = ["primary", "secondary", "success", "info", "warning", "danger", "light", "dark"]
              , e = t.includes(this._options.color) ? this._options.color : "primary";
            t.forEach(t => {
                this._element.classList.remove(`alert-${t}`)
            }
            ),
            N.addClass(this._element, `alert-${e}`)
        }
        _setupWidth() {
            N.style(this._element, {
                width: this._options.width
            })
        }
        _setupAutohide() {
            this._timeout = setTimeout( () => {
                this.hide()
            }
            , this._options.delay)
        }
        _setupAlignment() {
            const t = "top" === this.position.y ? "bottom" : "top"
              , e = "left" === this.position.x ? "right" : "left";
            "center" === this.position.x ? N.style(this._element, {
                [this.position.y]: `${this.verticalOffset + this._options.offset}px`,
                [t]: "unset",
                left: "50%",
                transform: "translate(-50%)"
            }) : N.style(this._element, {
                [this.position.y]: `${this.verticalOffset + this._options.offset}px`,
                [this.position.x]: `${this._options.offset}px`,
                [t]: "unset",
                [e]: "unset",
                transform: "unset"
            })
        }
        _setupPosition() {
            this._options.container ? (N.addClass(this.parent, "parent-alert-relative"),
            N.addClass(this._element, "alert-absolute")) : N.addClass(this._element, "alert-fixed")
        }
        _appendToBody() {
            this._element.parentNode.removeChild(this._element),
            document.body.appendChild(this._element)
        }
        _getConfig(t) {
            const e = {
                ...Fg,
                ...N.getDataAttributes(this._element),
                ...t
            };
            return d(Dg, e, Hg),
            e
        }
        _bindMdbEvents() {
            I.extend(this._element, Bg, Dg)
        }
        _updatePosition() {
            N.style(this._element, {
                [this.position.y]: `${this.verticalOffset + this._options.offset}px`
            })
        }
        _updateAlertStack() {
            this.stackUtil.nextElements.forEach(t => {
                const e = zg.getInstance(t);
                e && e._updatePosition()
            }
            )
        }
    }
    const jg = ".bs.toast"
      , Wg = `mouseover${jg}`
      , Vg = `mouseout${jg}`
      , Yg = `focusin${jg}`
      , Xg = `focusout${jg}`
      , Kg = `hide${jg}`
      , Ug = `hidden${jg}`
      , qg = `show${jg}`
      , Zg = `shown${jg}`
      , Gg = "hide"
      , Qg = "show"
      , Jg = "showing"
      , tm = {
        animation: "boolean",
        autohide: "boolean",
        delay: "number"
    }
      , em = {
        animation: !0,
        autohide: !0,
        delay: 5e3
    };
    let im = class t extends Ct {
        constructor(t, e) {
            super(t, e),
            this._timeout = null,
            this._hasMouseInteraction = !1,
            this._hasKeyboardInteraction = !1,
            this._setListeners()
        }
        static get Default() {
            return em
        }
        static get DefaultType() {
            return tm
        }
        static get NAME() {
            return "toast"
        }
        show() {
            if (_t.trigger(this._element, qg).defaultPrevented)
                return;
            this._clearTimeout(),
            this._config.animation && this._element.classList.add("fade");
            this._element.classList.remove(Gg),
            G(this._element),
            this._element.classList.add(Qg, Jg),
            this._queueCallback( () => {
                this._element.classList.remove(Jg),
                _t.trigger(this._element, Zg),
                this._maybeScheduleHide()
            }
            , this._element, this._config.animation)
        }
        hide() {
            if (!this.isShown())
                return;
            if (_t.trigger(this._element, Kg).defaultPrevented)
                return;
            this._element.classList.add(Jg),
            this._queueCallback( () => {
                this._element.classList.add(Gg),
                this._element.classList.remove(Jg, Qg),
                _t.trigger(this._element, Ug)
            }
            , this._element, this._config.animation)
        }
        dispose() {
            this._clearTimeout(),
            this.isShown() && this._element.classList.remove(Qg),
            super.dispose()
        }
        isShown() {
            return this._element.classList.contains(Qg)
        }
        _maybeScheduleHide() {
            this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout( () => {
                this.hide()
            }
            , this._config.delay)))
        }
        _onInteraction(t, e) {
            switch (t.type) {
            case "mouseover":
            case "mouseout":
                this._hasMouseInteraction = e;
                break;
            case "focusin":
            case "focusout":
                this._hasKeyboardInteraction = e
            }
            if (e)
                return void this._clearTimeout();
            const i = t.relatedTarget;
            this._element === i || this._element.contains(i) || this._maybeScheduleHide()
        }
        _setListeners() {
            _t.on(this._element, Wg, t => this._onInteraction(t, !0)),
            _t.on(this._element, Vg, t => this._onInteraction(t, !1)),
            _t.on(this._element, Yg, t => this._onInteraction(t, !0)),
            _t.on(this._element, Xg, t => this._onInteraction(t, !1))
        }
        _clearTimeout() {
            clearTimeout(this._timeout),
            this._timeout = null
        }
        static jQueryInterface(e) {
            return this.each(function() {
                const i = t.getOrCreateInstance(this, e);
                if ("string" == typeof e) {
                    if (void 0 === i[e])
                        throw new TypeError(`No method named "${e}"`);
                    i[e](this)
                }
            })
        }
    }
    ;
    const nm = "toast"
      , sm = "show.bs.toast"
      , om = "hidden.bs.toast"
      , am = [{
        name: "shown"
    }, {
        name: "hide"
    }]
      , rm = {
        position: "(string|null)",
        animation: "boolean",
        autohide: "boolean",
        width: "(string || null)",
        color: "(string|null)",
        delay: "(boolean|number)",
        offset: "number",
        appendToBody: "boolean",
        stacking: "boolean",
        container: "(string|null)"
    }
      , lm = {
        position: null,
        animation: !0,
        autohide: !0,
        width: null,
        color: null,
        delay: 500,
        offset: 10,
        appendToBody: !1,
        stacking: !0,
        container: ""
    };
    class hm extends im {
        constructor(t, e={}) {
            super(t, e),
            this._config = this._getConfig(e),
            this._setup(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        get parent() {
            const [t] = B.parents(this._element, this._config.container);
            return t
        }
        get position() {
            if (!this._config.position)
                return null;
            const [t,e] = this._config.position.split("-");
            return {
                y: t,
                x: e
            }
        }
        get verticalOffset() {
            return this._config.stacking && this.position ? this.stackUtil.calculateOffset() : 0
        }
        update(t={}) {
            this._config = this._getConfig(t),
            this._setupColor(),
            this._config.position && (this._config.stacking && (this._setupStacking(),
            I.on(this._element, "hidden.bs.toast", () => {
                setTimeout( () => this._updateToastStack(), 150)
            }
            )),
            this._setupPosition(),
            this._setupAlignment())
        }
        dispose() {
            I.off(this._element, sm),
            I.off(this._element, "shown.bs.toast"),
            I.off(this._element, "hide.bs.toast"),
            I.off(this._element, om),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _setup() {
            this._setupColor(),
            this._config.width && this._setupWidth(),
            this._bindMdbEvents(),
            this._setupDisplay(),
            this._config.position && (this._config.stacking && (this._setupStacking(),
            I.on(this._element, "hidden.bs.toast", () => {
                setTimeout( () => this._updateToastStack(), 150)
            }
            )),
            this._setupPosition(),
            !this._config.container && this._config.appendToBody && this._appendToBody())
        }
        _setupStacking() {
            this.stackUtil = new Og(this._element,".toast",{
                position: this.position.y,
                offset: this._config.offset,
                container: this._config.container,
                filter: t => {
                    const e = hm.getInstance(t);
                    return !!e && (e._config.container === this._config.container && e._config.position === this._config.position)
                }
            }),
            I.on(this._element, "closed.bs.alert", () => {
                this._updateAlertStack()
            }
            )
        }
        _setupColor() {
            if (!this._config.color)
                return;
            const t = B.findOne(".toast-header", this._element)
              , e = ["primary", "secondary", "success", "info", "warning", "danger", "light", "dark"]
              , i = e.includes(this._config.color) ? this._config.color : "primary";
            e.forEach(e => {
                this._element.classList.remove(`toast-${e}`),
                t && t.classList.remove(`toast-${e}`)
            }
            ),
            N.addClass(this._element, `toast-${i}`),
            t && N.addClass(t, `toast-${i}`)
        }
        _setupWidth() {
            N.style(this._element, {
                width: this._config.width
            })
        }
        _setupPosition() {
            this._config.container ? (N.addClass(this.parent, "parent-toast-relative"),
            N.addClass(this._element, "toast-absolute")) : N.addClass(this._element, "toast-fixed")
        }
        _setupAlignment() {
            var t, e, i, n, s, o, a;
            const r = "top" === (null == (t = this.position) ? void 0 : t.y) ? "bottom" : "top"
              , l = "left" === (null == (e = this.position) ? void 0 : e.x) ? "right" : "left";
            "center" === (null == (i = this.position) ? void 0 : i.x) ? N.style(this._element, {
                [this.position.y]: `${this.verticalOffset + this._config.offset}px`,
                [r]: "unset",
                left: "50%",
                transform: "translate(-50%)"
            }) : N.style(this._element, {
                [(null == (n = this.position) ? void 0 : n.y) || "defaultY"]: `${this.verticalOffset + (null == (s = this._config) ? void 0 : s.offset)}px`,
                [(null == (o = this.position) ? void 0 : o.x) || "defaultX"]: `${null == (a = this._config) ? void 0 : a.offset}px`,
                [r]: "unset",
                [l]: "unset",
                transform: "unset"
            })
        }
        _setupDisplay() {
            this._element.classList.contains("show") || N.style(this._element, {
                display: "none"
            }),
            I.on(this._element, om, () => {
                I.trigger(this._element, "hidden.mdb.toast"),
                N.style(this._element, {
                    display: "none"
                })
            }
            ),
            I.on(this._element, sm, () => {
                I.trigger(this._element, "show.mdb.toast").defaultPrevented || (this._setupAlignment(),
                N.style(this._element, {
                    display: "block"
                }))
            }
            )
        }
        _bindMdbEvents() {
            I.extend(this._element, am, nm)
        }
        _getConfig(t) {
            const e = {
                ...lm,
                ...N.getDataAttributes(this._element),
                ...t
            };
            return d(nm, e, rm),
            e
        }
        _appendToBody() {
            this._element.parentNode.removeChild(this._element),
            document.body.appendChild(this._element)
        }
        _updatePosition() {
            N.style(this._element, {
                [this.position.y]: `${this.verticalOffset + this._config.offset}px`
            })
        }
        _updateToastStack() {
            this.stackUtil.nextElements.forEach(t => {
                const e = hm.getInstance(t);
                e && e._updatePosition()
            }
            )
        }
        static jQueryInterface(t, e={}) {
            return this.each(function() {
                let i;
                if (i = "object" == typeof t ? new hm(this,t) : hm.getOrCreateInstance(this, t),
                "string" == typeof t) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
    }
    function cm(t, e, i, n, s, o, a) {
        return `\n  <div id='${t}' class='timepicker-head d-flex flex-row align-items-center justify-content-center ${o ? "timepicker-head-inline" : ""}'\n  style='padding-${a ? "left" : "right"}:${e && !o ? 50 : 0}px'>\n    <div class='timepicker-head-content d-flex w-100 justify-content-evenly'>\n    ${o ? '\n    <div class="timepicker-current-wrapper">\n      <span class="position-relative h-100 timepicker-inline-hour-icons">\n        <i class="fas fa-chevron-up position-absolute text-white timepicker-icon-up timepicker-icon-inline-hour"></i>\n        <button type=\'button\' class=\'timepicker-current timepicker-hour active timepicker-current-inline\' tabindex="0">21</button>\n        <i class="fas fa-chevron-down position-absolute text-white timepicker-icon-down timepicker-icon-inline-hour"></i>\n      </span>\n      <button type=\'button\' class=\'timepicker-dot timepicker-current-inline\' disabled>:</button>\n      <span class="position-relative h-100  timepicker-inline-minutes-icons">\n        <i class="fas fa-chevron-up position-absolute text-white timepicker-icon-up timepicker-icon-inline-minute"></i>\n        <button type=\'button\' class=\'timepicker-current timepicker-minute timepicker-current-inline\' tabindex="0">21</button>\n        <i class="fas fa-chevron-down position-absolute text-white timepicker-icon-down timepicker-icon-inline-minute"></i>\n      </span>\n    </div>\n  ' : "\n    <div class=\"timepicker-current-wrapper\">\n      <span class=\"position-relative h-100\">\n        <button type='button' class='timepicker-current timepicker-hour active' tabindex=\"0\">21</button>\n      </span>\n      <button type='button' class='timepicker-dot' disabled>:</button>\n      <span class=\"position-relative h-100\">\n        <button type='button' class='timepicker-current timepicker-minute' tabindex=\"0\">21</button>\n      </span>\n    </div>\n  "}\n      ${function(t, e, i, n, s) {
            const o = `<button type='button' class='timepicker-button timepicker-submit timepicker-submit-inline py-1 px-2 mb-0' tabindex="0">${s}</button>`;
            return e ? t ? `${o}` : "" : `\n      <div class="d-flex ${t ? "" : "flex-column "}justify-content-center timepicker-mode-wrapper">\n        <button type='button' class="timepicker-hour-mode timepicker-am${t ? " me-2 ms-4" : ""}" tabindex="0">${i}</button>\n        <button type='button' class="timepicker-hour-mode timepicker-pm" tabindex="0">${n}</button>\n        ${t ? `${o}` : ""}\n      </div>`
        }(o, e, i, n, s)}\n    </div>\n  </div>\n  `
    }
    const dm = t => {
        if ("" === t)
            return;
        let e, i, n, s;
        return um(t) ? (e = t.getHours(),
        s = e,
        i = t.getMinutes(),
        e %= 12,
        0 === e ? n = "AM" : e > 12 && (n = "PM"),
        e = e || 12,
        void 0 === n && (n = e >= 12 ? "PM" : "AM"),
        i = i < 10 ? `0${i}` : i) : ([e,i,n] = mm(t, !1),
        s = e,
        e %= 12,
        0 === e && void 0 === n && (n = "AM"),
        e = e || 12,
        void 0 === n && (n = s >= 12 ? "PM" : "AM")),
        {
            hours: e,
            minutes: i,
            amOrPm: n
        }
    }
      , um = t => t && "[object Date]" === Object.prototype.toString.call(t) && !isNaN(t)
      , pm = t => {
        if ("" === t)
            return;
        let e, i;
        return um(t) ? (e = t.getHours(),
        i = t.getMinutes()) : [e,i] = mm(t, !1),
        i = Number(i) < 10 ? `0${Number(i)}` : i,
        {
            hours: e,
            minutes: i
        }
    }
      , fm = ({clientX: t, clientY: e, touches: i}, n, s=!1) => {
        const {left: o, top: a} = n.getBoundingClientRect();
        let r = {};
        return s && i ? s && Object.keys(i).length > 0 && (r = {
            x: i[0].clientX - o,
            y: i[0].clientY - a
        }) : r = {
            x: t - o,
            y: e - a
        },
        r
    }
      , gm = () => {
        let t = !1;
        return (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) && (t = !0),
        t
    }
      , mm = (t, e=!0) => {
        let i;
        return i = e ? t.value.replace(/:/gi, " ") : t.replace(/:/gi, " "),
        i.split(" ")
    }
      , _m = (t, e) => {
        const [i,n,s] = mm(t, !1)
          , [o,a,r] = mm(e, !1);
        return "PM" == s && "AM" == r ? 1 : "AM" == s && "PM" == r ? 2 : s == r && i > o ? 1 : i < o ? 2 : n > a ? 1 : n < a ? 2 : void 0
    }
      , bm = () => {
        const t = new Date
          , e = t.getHours();
        let i = String(t.getMinutes());
        1 === i.length && (i = `0${i}`);
        return `${e}:${i}`
    }
      , vm = (t, e, i) => {
        if (!e)
            return t;
        let n = bm();
        return i && (n = `${dm(n).hours}:${dm(n).minutes} ${dm(n).amOrPm}`),
        ("" != t && 1 == _m(n, t) || "" === t) && (t = n),
        t
    }
      , ym = (t, e, i) => {
        if (!e)
            return t;
        let n = bm();
        return i && (n = `${dm(n).hours}:${dm(n).minutes} ${dm(n).amOrPm}`),
        ("" != t && 2 == _m(n, t) || "" === t) && (t = n),
        t
    }
      , xm = (t, e) => {
        t.forEach(t => {
            ("00" === t.textContent || Number(t.textContent) > e) && N.addClass(t, "disabled")
        }
        )
    }
      , wm = (t, e) => {
        t.forEach(t => {
            "00" !== t.textContent && Number(t.textContent) < e && N.addClass(t, "disabled")
        }
        )
    }
      , Cm = "timepicker"
      , km = `mdb.${Cm}`
      , Sm = `.${km}`
      , Tm = ".data-api"
      , Am = `close${Sm}`
      , Em = `open${Sm}`
      , Mm = `click${Sm}${Tm}`
      , Om = `keydown${Sm}${Tm}`
      , Dm = `mousedown${Sm}${Tm}`
      , $m = `mouseup${Sm}${Tm}`
      , Im = `mousemove${Sm}${Tm}`
      , Lm = `mouseleave${Sm}${Tm}`
      , Pm = `mouseover${Sm}${Tm}`
      , Rm = `touchmove${Sm}${Tm}`
      , Nm = `touchend${Sm}${Tm}`
      , Bm = `touchstart${Sm}${Tm}`
      , Hm = `valueChanged${Sm}`
      , Fm = `clear${Sm}`
      , zm = "active"
      , jm = `${Cm}-am`
      , Wm = `${Cm}-cancel`
      , Vm = `${Cm}-clear`
      , Ym = `${Cm}-submit`
      , Xm = `${Cm}-circle`
      , Km = `${Cm}-clock-animation`
      , Um = `${Cm}-clock`
      , qm = `${Cm}-clock-inner`
      , Zm = `${Cm}-clock-wrapper`
      , Gm = `.${Cm}-current`
      , Qm = `${Cm}-current-inline`
      , Jm = `${Cm}-hand-pointer`
      , t_ = `${Cm}-hour`
      , e_ = `${Cm}-hour-mode`
      , i_ = `${Cm}-icon-down`
      , n_ = `${Cm}-icon-inline-hour`
      , s_ = `${Cm}-icon-inline-minute`
      , o_ = `${Cm}-icon-up`
      , a_ = `${Cm}-inline-hour-icons`
      , r_ = `${Cm}-middle-dot`
      , l_ = `${Cm}-minute`
      , h_ = `${Cm}-modal`
      , c_ = `${Cm}-pm`
      , d_ = `${Cm}-tips-element`
      , u_ = `${Cm}-time-tips-hours`
      , p_ = `${Cm}-tips-inner-element`
      , f_ = `${Cm}-time-tips-inner`
      , g_ = `${Cm}-time-tips-minutes`
      , m_ = `${Cm}-transform`
      , __ = `${Cm}-wrapper`
      , b_ = `${Cm}-input`
      , v_ = "[data-mdb-toggle]"
      , y_ = {
        bodyId: "",
        cancelLabel: "Cancel",
        clearLabel: "Clear",
        closeModalOnBackdropClick: !0,
        closeModalOnMinutesClick: !1,
        container: "body",
        defaultTime: "",
        disablePast: !1,
        disableFuture: !1,
        focusInputAfterApprove: !1,
        footerId: "",
        format12: !0,
        format24: !1,
        headId: "",
        increment: !1,
        inline: !1,
        maxTime: "",
        minTime: "",
        modalId: "",
        okLabel: "Ok",
        overflowHidden: !0,
        pickerId: "",
        readOnly: !1,
        showClearBtn: !0,
        switchHoursToMinutesOnClick: !0,
        iconClass: "far fa-clock fa-sm timepicker-icon",
        withIcon: !0,
        pmLabel: "PM",
        amLabel: "AM",
        animations: !0,
        toggleButtonLabel: "Open Timepicker"
    }
      , x_ = {
        bodyId: "string",
        cancelLabel: "string",
        clearLabel: "string",
        closeModalOnBackdropClick: "boolean",
        closeModalOnMinutesClick: "boolean",
        container: "string",
        disablePast: "boolean",
        disableFuture: "boolean",
        footerId: "string",
        format12: "boolean",
        format24: "boolean",
        headId: "string",
        increment: "boolean",
        inline: "boolean",
        maxTime: "(string|date|null)",
        minTime: "(string|date|null)",
        modalId: "string",
        okLabel: "string",
        overflowHidden: "boolean",
        pickerId: "string",
        readOnly: "boolean",
        showClearBtn: "boolean",
        switchHoursToMinutesOnClick: "boolean",
        defaultTime: "(string|date|number)",
        iconClass: "string",
        withIcon: "boolean",
        pmLabel: "string",
        amLabel: "string",
        animations: "boolean",
        toggleButtonLabel: "string"
    };
    class w_ extends ao {
        constructor(t, e={}) {
            super(t),
            i(this, "_toggleAmPm", t => {
                "PM" == t ? (this._isPmEnabled = !0,
                this._isAmEnabled = !1) : "AM" == t && (this._isPmEnabled = !1,
                this._isAmEnabled = !0)
            }
            ),
            i(this, "_toggleBackgroundColorCircle", t => {
                null !== this._modal.querySelector(`.${t}.${zm}`) ? N.addClass(this._circle, "active") : N.removeClass(this._circle, "active")
            }
            ),
            i(this, "_toggleClassActive", (t, {textContent: e}, i) => {
                const n = [...t].find(t => Number(t) === Number(e));
                return i.forEach(t => {
                    N.hasClass(t, "disabled") || (t.textContent === n ? N.addClass(t, zm) : N.removeClass(t, zm))
                }
                )
            }
            ),
            i(this, "_makeMinutesDegrees", (t, e) => {
                const {increment: i} = this._options;
                return t < 0 ? (e = Math.round(360 + t / 6) % 60,
                t = 360 + 6 * Math.round(t / 6)) : (e = Math.round(t / 6) % 60,
                t = 6 * Math.round(t / 6)),
                i && (t = 30 * Math.round(t / 30),
                60 === (e = 6 * Math.round(t / 6) / 6) && (e = "00")),
                t >= 360 && (t = 0),
                {
                    degrees: t,
                    minute: e,
                    addDegrees: i ? 30 : 6
                }
            }
            ),
            i(this, "_makeHourDegrees", (t, e, i) => {
                if (t)
                    return this._hasTargetInnerClass(t) ? e < 0 ? (i = Math.round(360 + e / 30) % 24,
                    e = 360 + e) : 12 === (i = Math.round(e / 30) + 12) && (i = "00") : e < 0 ? (i = Math.round(360 + e / 30) % 12,
                    e = 360 + e) : (0 === (i = Math.round(e / 30) % 12) || i > 12) && (i = 12),
                    e >= 360 && (e = 0),
                    {
                        degrees: e,
                        hour: i,
                        addDegrees: 30
                    }
            }
            ),
            i(this, "_makeInnerHoursDegrees", (t, e) => (t < 0 ? (e = Math.round(360 + t / 30) % 24,
            t = 360 + t) : 12 === (e = Math.round(t / 30) + 12) && (e = "00"),
            {
                degrees: t,
                hour: e,
                addDegrees: 30
            })),
            i(this, "_getAppendClock", (t=[], e=`.${Um}`, i) => {
                let {minTime: n, maxTime: s} = this._options;
                const {inline: o, format12: a, disablePast: r, disableFuture: l} = this._options;
                n = vm(n, r, a),
                s = ym(s, l, a);
                const [h,c,d] = mm(s, !1)
                  , [u,p,f] = mm(n, !1);
                o || a && this._isInvalidTimeFormat && !N.hasClass(this._AM, "active") && N.addClass(this._PM, "active");
                const g = B.findOne(e)
                  , m = 360 / t.length;
                if (null === g)
                    return;
                const b = (g.offsetWidth - 32) / 2
                  , v = (g.offsetHeight - 32) / 2
                  , y = b - 4;
                setTimeout( () => {
                    let t;
                    a && (t = B.findOne(`.${e_}.${zm}`).textContent),
                    this._handleDisablingTipsMinTime(t, f, p, u),
                    this._handleDisablingTipsMaxTime(t, d, c, h)
                }
                , 0),
                [...t].forEach( (e, n) => {
                    const s = n * m * (Math.PI / 180);
                    const o = _("span")
                      , a = _("span");
                    a.innerHTML = e,
                    N.addClass(o, i);
                    const r = o.offsetWidth
                      , l = o.offsetHeight;
                    return N.addStyle(o, {
                        left: b + Math.sin(s) * y - r + "px",
                        bottom: v + Math.cos(s) * y - l + "px"
                    }),
                    t.includes("05") && N.addClass(o, `${g_}`),
                    t.includes("13") ? a.classList.add(p_) : a.classList.add(d_),
                    o.appendChild(a),
                    g.appendChild(o)
                }
                )
            }
            ),
            this._document = document,
            this._options = this._getConfig(e),
            this._currentTime = null,
            this._toggleButtonId = this._element.id ? `timepicker-toggle-${this._element.id}` : o("timepicker-toggle-"),
            this.hoursArray = ["12", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11"],
            this.innerHours = ["00", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"],
            this.minutesArray = ["00", "05", "10", "15", "20", "25", "30", "35", "40", "45", "50", "55"],
            this._input = B.findOne("input", this._element),
            this._hour = null,
            this._minutes = null,
            this._AM = null,
            this._PM = null,
            this._wrapper = null,
            this._modal = null,
            this._hand = null,
            this._circle = null,
            this._focusTrap = null,
            this._isOpen = !1,
            this._popper = null,
            this._interval = null,
            this._timeoutInterval = null,
            this._inputValue = "" !== this._options.defaultTime ? this._options.defaultTime : this._input.value,
            this._options.format24 && (this._options.format12 = !1,
            this._currentTime = pm(this._inputValue)),
            this._options.format12 && (this._options.format24 = !1,
            this._currentTime = dm(this._inputValue)),
            this._options.readOnly && this._input.setAttribute("readonly", !0),
            this._scrollBar = new ce,
            this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations,
            this.init(),
            this._isHours = !0,
            this._isMinutes = !1,
            this._isInvalidTimeFormat = !1,
            this._isMouseMove = !1,
            this._isInner = !1,
            this._isAmEnabled = !1,
            this._isPmEnabled = !1,
            this._options.format12 && !this._options.defaultTime && (this._isPmEnabled = !0),
            this._outerHandPointerHeight = "calc(40% + 1px)",
            this._innerHandPointerHeight = "21.5%",
            this._objWithDataOnChange = {
                degrees: null
            },
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return Cm
        }
        get container() {
            return B.findOne(`.timepicker-container-${this._toggleButtonId}`)
        }
        get toggleButton() {
            return B.findOne("[data-mdb-toggle]", this._element)
        }
        get customIcon() {
            return B.findOne(".timepicker-toggle-button", this._element)
        }
        init() {
            this.toggleButton || this.customIcon || !this._options.withIcon || this._appendToggleButton(this._options);
            const {format12: t, format24: e} = this._options;
            let i, n, s;
            if (N.addClass(this._input, b_),
            void 0 !== this._currentTime) {
                const {hours: o, minutes: a, amOrPm: r} = this._currentTime;
                i = Number(o) < 10 ? 0 : "",
                n = `${i}${Number(o)}:${a}`,
                s = r,
                t ? this._input.value = `${n} ${s}` : e && (this._input.value = `${n}`)
            } else
                i = "",
                n = "",
                s = "",
                this._input.value = "";
            this._input.value.length > 0 && "" !== this._input.value && N.addClass(this._input, "active"),
            null === this._options && null === this._element || (this._listenToUserInput(),
            this._handleOpen(),
            this._listenToToggleKeydown())
        }
        dispose() {
            this._isOpen && this.close(),
            this._removeInputAndToggleListeners(),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            setTimeout( () => {
                super.dispose()
            }
            , 355)
        }
        update(t={}) {
            this._options = this._getConfig({
                ...this._options,
                ...t
            })
        }
        close() {
            const t = I.trigger(this._element, Am);
            this._isOpen && !t.defaultPrevented && (this._removePicker(),
            this._isOpen = !1,
            this.toggleButton ? this.toggleButton.focus() : this._input && focusInputAfterApprove && this._input.focus())
        }
        open() {
            if (this._input.readOnly || this._input.disabled)
                return;
            const t = I.trigger(this._element, Em);
            if (this._isOpen || t.defaultPrevented)
                return;
            const e = this._getContainer();
            let i;
            N.addStyle(this.toggleButton, {
                pointerEvents: "none"
            }),
            i = "" === mm(this._input)[0] || this._isInvalidTimeFormat ? ["12", "00", "PM"] : mm(this._input);
            const {modalId: n, inline: s, format12: o} = this._options
              , [a,r,l] = i
              , h = _("div");
            if ((Number(a) > 12 || "00" === a) && (this._isInner = !0),
            h.innerHTML = ( ({format24: t, okLabel: e, cancelLabel: i, headId: n, footerId: s, bodyId: o, pickerId: a, clearLabel: r, inline: l, showClearBtn: h, amLabel: c, pmLabel: d, isRTL: u}, p) => {
                const f = `<div id='${a}' class='timepicker-wrapper h-100 d-flex align-items-center justify-content-center flex-column position-fixed'>\n      <div class="d-flex align-items-center justify-content-center flex-column timepicker-container timepicker-container-${p}">\n        <div class="d-flex flex-column timepicker-elements justify-content-around">\n          ${cm(n, t, c, d, e, l, u)}\n          ${function(t, e) {
                    return `\n  <div id='${t}' class='timepicker-clock-wrapper d-flex justify-content-center flex-column align-items-center'>\n    <div class='timepicker-clock'>\n      <span class='timepicker-middle-dot position-absolute'></span>\n      <div class='timepicker-hand-pointer position-absolute'>\n        <div class='timepicker-circle position-absolute'></div>\n      </div>\n      ${e ? '<div class="timepicker-clock-inner"></div>' : ""}\n    </div>\n  </div>`
                }(o, t)}\n        </div>\n        ${function(t, e, i, n, s) {
                    return `\n  <div id='${t}' class='timepicker-footer'>\n    <div class="w-100 d-flex justify-content-between">\n      ${e ? `<button type='button' class='timepicker-button timepicker-clear' tabindex="0" aria-label="${i}">${i}</button>` : ""}\n      <button type='button' class='timepicker-button timepicker-cancel' tabindex="0" aria-label="${n}">${n}</button>\n      <button type='button' class='timepicker-button timepicker-submit' tabindex="0" aria-label="${s}">${s}</button>\n    </div>\n  </div>`
                }(s, h, r, i, e)}\n\n      </div>\n    </div>`
                  , g = `\n    <div id='${a}' class='timepicker-wrapper h-100 d-flex align-items-center justify-content-center flex-column timepicker-wrapper-inline'>\n      <div class="d-flex align-items-center justify-content-center flex-column timepicker-container timepicker-container-${p}">\n\n        <div class="d-flex flex-column timepicker-elements justify-content-around timepicker-elements-inline">\n\n        ${cm(n, t, c, d, e, l, u)}\n\n        </div>\n\n      </div>\n    </div>\n  `;
                return l ? g : f
            }
            )(this._options, this._toggleButtonId),
            N.addClass(h, h_),
            N.addClass(h, `${h_}-${this._toggleButtonId}`),
            h.setAttribute("role", "dialog"),
            h.setAttribute("tabIndex", "-1"),
            h.setAttribute("id", n),
            s ? (this._popper = Ln(this._input, h, {
                placement: "bottom-start"
            }),
            e.appendChild(h)) : (e.appendChild(h),
            this._scrollBar.hide()),
            this._getDomElements(),
            this._animations ? this._toggleBackdropAnimation() : N.addClass(this._wrapper, "opacity-100"),
            this._appendTimes(),
            this._setActiveClassToTipsOnOpen(a, r, l),
            this._setTipsAndTimesDependOnInputValue(a, r),
            "" === this._input.value) {
                const t = B.find(`.${u_}`, this._modal);
                o && N.addClass(this._PM, zm),
                this._hour.textContent = "12",
                this._minutes.textContent = "00",
                this._addActiveClassToTip(t, Number(this._hour.textContent))
            }
            this._handleSwitchTimeMode(),
            this._handleOkButton(),
            this._handleClose(),
            s ? (this._handleHoverInlineBtn(),
            this._handleDocumentClickInline(),
            this._handleInlineClicks()) : (this._handleSwitchHourMinute(),
            this._handleClockClick(),
            this._handleKeyboard(),
            N.addStyle(this._hour, {
                pointerEvents: "none"
            }),
            N.addStyle(this._minutes, {
                pointerEvents: ""
            })),
            this._setFocusTrap(this.container),
            this._isOpen = !0
        }
        _removeInputAndToggleListeners() {
            I.off(this._input, "input"),
            I.off(this._element, Mm, v_),
            I.off(this._element, "keydown", v_)
        }
        _appendToggleButton() {
            const t = ( (t, e) => {
                const {iconClass: i, toggleButtonLabel: n} = t;
                return `\n  <button id="${e}" tabindex="0" type="button" class="timepicker-toggle-button" data-mdb-toggle="timepicker" aria-label="${n}">\n    <i class="${i}"></i>\n  </button>\n`
            }
            )(this._options, this._toggleButtonId);
            this._input.insertAdjacentHTML("afterend", t)
        }
        _getDomElements() {
            this._modal = B.findOne(`.${h_}-${this._toggleButtonId}`),
            this._hour = B.findOne(`.${t_}`, this._modal),
            this._minutes = B.findOne(`.${l_}`, this._modal),
            this._AM = B.findOne(`.${jm}`, this._modal),
            this._PM = B.findOne(`.${c_}`, this._modal),
            this._wrapper = B.findOne(`.${__}`, this._modal),
            this._hand = B.findOne(`.${Jm}`, this._modal),
            this._circle = B.findOne(`.${Xm}`, this._modal),
            this._clock = B.findOne(`.${Um}`, this._modal),
            this._clockInner = B.findOne(`.${qm}`, this._modal)
        }
        _handlerMaxMinHoursOptions(t, e, i, n, s, o) {
            if (!e && !i)
                return !0;
            const {format24: a, format12: r, disablePast: l, disableFuture: h} = this._options
              , {_isAmEnabled: c, _isPmEnabled: d} = this
              , u = o.keyCode
              , p = o.target.classList.contains("timepicker-clock-inner") || o.target.classList.contains("timepicker-time-tips-inner") || o.target.classList.contains("timepicker-tips-inner-element");
            i = vm(i, l, r);
            let f = "" !== (e = ym(e, h, r)) ? 30 * e : ""
              , g = "" !== i ? 30 * i : "";
            t <= 0 && (t = 360 + t);
            const m = () => {
                const t = document.querySelectorAll(".timepicker-tips-element")
                  , e = document.querySelectorAll(".timepicker-tips-inner-element");
                let i, n, s, o = (t => {
                    let e;
                    return e = t.startsWith("0") ? Number(t.slice(1)) : Number(t),
                    e
                }
                )(this._hour.innerText);
                return u === eg ? n = 1 : u === ng && (n = -1),
                s = 12 === o && u === eg ? 1 : 0 === o && u === eg ? 13 : 0 === o && u === ng ? 23 : 13 === o && u === ng ? 0 : 1 === o && u === ng ? 12 : o + n,
                t.forEach(t => {
                    t.textContent == s && (i = t)
                }
                ),
                e.forEach(t => {
                    t.textContent == s && (i = t)
                }
                ),
                !i.parentElement.classList.contains("disabled")
            }
            ;
            if (a && "keydown" !== o.type && p)
                return ( () => {
                    let n = "" !== i && i > 12 ? 30 * (i - 12) : ""
                      , s = "" !== e && e > 12 ? 30 * (e - 12) : "";
                    if (!(n && t < n || s && t > s || e && e < 12))
                        return !0
                }
                )();
            if ("keydown" === o.type)
                return m();
            return !(i && ("PM" === s && c || (!s || "PM" === s && d || "" !== i && "AM" === s && c) && t < g) || e && ("AM" === n && d || (!n || "PM" === n && d || "" !== e && "AM" === n && c) && t > f)) || void 0
        }
        _handleKeyboard() {
            I.on(this._document, Om, "", t => {
                let e, i, {increment: n, maxTime: s, minTime: o, format12: a, disablePast: r, disableFuture: l} = this._options, [h,c] = mm(o, !1), [d,u] = mm(s, !1);
                h = vm(h, r, a),
                d = ym(d, l, a);
                const p = null === B.findOne(`.${g_}`)
                  , f = null !== B.findOne(`.${f_}`)
                  , g = Number(this._hand.style.transform.replace(/[^\d-]/g, ""))
                  , m = B.find(`.${g_}`, this._modal)
                  , _ = B.find(`.${u_}`, this._modal)
                  , b = B.find(`.${f_}`, this._modal);
                let v = this._makeHourDegrees(t.target, g, e).hour;
                const {degrees: y, addDegrees: x} = this._makeHourDegrees(t.target, g, e);
                let {minute: w, degrees: C} = this._makeMinutesDegrees(g, i);
                const k = this._makeMinutesDegrees(g, i).addDegrees;
                let {hour: S} = this._makeInnerHoursDegrees(g, undefined);
                if (t.keyCode === lg) {
                    const t = B.findOne(`.${Wm}`, this._modal);
                    I.trigger(t, "click")
                } else if (p) {
                    if (f && (t.keyCode === ig && (this._isInner = !1,
                    N.addStyle(this._hand, {
                        height: this._outerHandPointerHeight
                    }),
                    this._hour.textContent = this._setHourOrMinute(v > 12 ? 1 : v),
                    this._toggleClassActive(this.hoursArray, this._hour, _),
                    this._toggleClassActive(this.innerHours, this._hour, b)),
                    t.keyCode === tg && (this._isInner = !0,
                    N.addStyle(this._hand, {
                        height: this._innerHandPointerHeight
                    }),
                    this._hour.textContent = this._setHourOrMinute(S >= 24 || "00" === S ? 0 : S),
                    this._toggleClassActive(this.innerHours, this._hour, b),
                    this._toggleClassActive(this.hoursArray, this._hour - 1, _))),
                    t.keyCode === eg) {
                        if (!this._handlerMaxMinHoursOptions(y + 30, d, h, u, c, t))
                            return;
                        ( () => N.addStyle(this._hand, {
                            transform: `rotateZ(${y + x}deg)`
                        }))(),
                        this._isInner ? (S += 1,
                        24 === S ? S = 0 : 25 !== S && "001" !== S || (S = 13),
                        this._hour.textContent = this._setHourOrMinute(S),
                        this._toggleClassActive(this.innerHours, this._hour, b)) : (v += 1,
                        this._hour.textContent = this._setHourOrMinute(v > 12 ? 1 : v),
                        this._toggleClassActive(this.hoursArray, this._hour, _))
                    }
                    if (t.keyCode === ng) {
                        if (!this._handlerMaxMinHoursOptions(y - 30, d, h, u, c, t))
                            return;
                        ( () => N.addStyle(this._hand, {
                            transform: `rotateZ(${y - x}deg)`
                        }))(),
                        this._isInner ? (S -= 1,
                        12 === S ? S = 0 : -1 === S && (S = 23),
                        this._hour.textContent = this._setHourOrMinute(S),
                        this._toggleClassActive(this.innerHours, this._hour, b)) : (v -= 1,
                        this._hour.textContent = this._setHourOrMinute(0 === v ? 12 : v),
                        this._toggleClassActive(this.hoursArray, this._hour, _))
                    }
                } else
                    t.keyCode === eg && (C += k,
                    N.addStyle(this._hand, {
                        transform: `rotateZ(${C}deg)`
                    }),
                    w += 1,
                    n && (w += 4,
                    "0014" === w && (w = 5)),
                    this._minutes.textContent = this._setHourOrMinute(w > 59 ? 0 : w),
                    this._toggleClassActive(this.minutesArray, this._minutes, m),
                    this._toggleBackgroundColorCircle(`${g_}`)),
                    t.keyCode === ng && (C -= k,
                    N.addStyle(this._hand, {
                        transform: `rotateZ(${C}deg)`
                    }),
                    w -= n ? 5 : 1,
                    -1 === w ? w = 59 : -5 === w && (w = 55),
                    this._minutes.textContent = this._setHourOrMinute(w),
                    this._toggleClassActive(this.minutesArray, this._minutes, m),
                    this._toggleBackgroundColorCircle(`${g_}`))
            }
            )
        }
        _setActiveClassToTipsOnOpen(t, ...e) {
            if (!this._isInvalidTimeFormat)
                if (this._options.format24) {
                    const e = B.find(`.${u_}`, this._modal)
                      , i = B.find(`.${f_}`, this._modal);
                    this._addActiveClassToTip(e, t),
                    this._addActiveClassToTip(i, t)
                } else {
                    [...e].filter(t => ("pm" === t.toLowerCase() ? N.addClass(this._PM, zm) : "am" === t.toLowerCase() ? N.addClass(this._AM, zm) : (N.removeClass(this._AM, zm),
                    N.removeClass(this._PM, zm)),
                    t));
                    const i = B.find(`.${u_}`, this._modal);
                    this._addActiveClassToTip(i, t)
                }
        }
        _setTipsAndTimesDependOnInputValue(t, e) {
            const {inline: i, format12: n} = this._options;
            if (this._isInvalidTimeFormat)
                this._hour.textContent = "12",
                this._minutes.textContent = "00",
                i || N.addStyle(this._hand, {
                    transform: "rotateZ(0deg)"
                }),
                n && N.addClass(this._PM, zm);
            else {
                const n = t > 12 ? 30 * t - 360 : 30 * t;
                this._hour.textContent = t,
                this._minutes.textContent = e,
                i || (N.addStyle(this._hand, {
                    transform: `rotateZ(${n}deg)`,
                    height: this._outerHandPointerHeight
                }),
                N.addClass(this._circle, "active"),
                (Number(t) > 12 || "00" === t) && N.addStyle(this._hand, {
                    height: this._innerHandPointerHeight
                }))
            }
        }
        _listenToToggleKeydown() {
            I.on(this._element, "keydown", v_, t => {
                t.keyCode === ag && this.open()
            }
            )
        }
        _handleOpen() {
            I.on(this._element, Mm, v_, () => {
                if (null === this._options)
                    return;
                const t = null !== N.getDataAttribute(this._input, "toggle") ? 200 : 0;
                setTimeout( () => {
                    this.open()
                }
                , t)
            }
            )
        }
        _setFocusTrap(t) {
            this._focusTrap = new Jf(t,{
                event: "keydown",
                condition: t => "Tab" === t.key
            }),
            this._focusTrap.trap()
        }
        _handleInlineClicks() {
            let t, e;
            const i = t => {
                let e = t;
                return e > 59 ? e = 0 : e < 0 && (e = 59),
                e
            }
              , n = t => {
                let e = t;
                return this._options.format24 ? (e > 24 ? e = 1 : e < 0 && (e = 23),
                e > 23 && (e = 0)) : (e > 12 ? e = 1 : e < 1 && (e = 12),
                e > 12 && (e = 1)),
                e
            }
              , s = t => {
                const e = n(t);
                this._hour.textContent = this._setHourOrMinute(e)
            }
              , o = t => {
                const e = i(t);
                this._minutes.textContent = this._setHourOrMinute(e)
            }
              , a = () => {
                t = n(t) + 1,
                s(t)
            }
              , r = () => {
                e = i(e) + 1,
                o(e)
            }
              , l = () => {
                t = n(t) - 1,
                s(t)
            }
              , h = () => {
                e = i(e) - 1,
                o(e)
            }
              , c = () => {
                clearInterval(this._interval),
                clearTimeout(this._timeoutInterval)
            }
              , d = t => {
                c(),
                this._timeoutInterval = setTimeout( () => {
                    this._interval = setInterval(t, 100)
                }
                , 500)
            }
            ;
            L.on(this._modal, "click mousedown mouseup touchstart touchend contextmenu", `.${o_}, .${i_}`, i => {
                t = Number(this._hour.textContent),
                e = Number(this._minutes.textContent);
                const {target: n, type: s} = i
                  , o = "mousedown" === s || "touchstart" === s;
                N.hasClass(n, o_) ? N.hasClass(n.parentNode, a_) ? o ? d(a) : "mouseup" === s || "touchend" === s || "contextmenu" === s ? c() : a() : o ? d(r) : "mouseup" === s || "touchend" === s || "contextmenu" === s ? c() : r() : N.hasClass(n, i_) && (N.hasClass(n.parentNode, a_) ? o ? d(l) : "mouseup" === s || "touchend" === s ? c() : l() : o ? d(h) : "mouseup" === s || "touchend" === s ? c() : h())
            }
            ),
            L.on(this._document, `${$m} ${Nm}`, () => {
                c()
            }
            ),
            I.on(window, Om, i => {
                const n = i.code
                  , s = document.activeElement.classList.contains("timepicker-hour")
                  , o = document.activeElement.classList.contains("timepicker-minute")
                  , c = document.activeElement === document.body;
                switch (t = Number(this._hour.textContent),
                e = Number(this._minutes.textContent),
                n) {
                case "ArrowUp":
                    i.preventDefault(),
                    c || s ? (this._hour.focus(),
                    a()) : o && r();
                    break;
                case "ArrowDown":
                    i.preventDefault(),
                    c || s ? (this._hour.focus(),
                    l()) : o && h()
                }
            }
            )
        }
        _handleClose() {
            I.on(this._modal, "click", `.${__}, .${Wm}, .${Vm}`, ({target: t}) => {
                const {closeModalOnBackdropClick: e} = this._options;
                if (N.hasClass(t, Vm)) {
                    let t;
                    this._toggleAmPm("PM"),
                    this._input.value = "",
                    I.trigger(this._input, Fm),
                    N.removeClass(this._input, "active"),
                    t = "" === mm(this._input)[0] ? ["12", "00", "PM"] : mm(this._input);
                    const [e,i,n] = t;
                    this._setTipsAndTimesDependOnInputValue("12", "00"),
                    this._setActiveClassToTipsOnOpen(e, i, n),
                    this._hour.click()
                } else
                    (N.hasClass(t, Wm) || N.hasClass(t, __) && e) && this.close()
            }
            )
        }
        _removePicker() {
            N.addStyle(this.toggleButton, {
                pointerEvents: "auto"
            }),
            this._animations && this._toggleBackdropAnimation(!0),
            this._removeModal()
        }
        _removeFocusTrap() {
            this._focusTrap && (this._focusTrap.disable(),
            this._focusTrap = null)
        }
        showValueInput() {
            return this._input.value
        }
        _handleOkButton() {
            L.on(this._modal, "click", `.${Ym}`, () => {
                let {maxTime: t, minTime: e} = this._options;
                const {format12: i, format24: n, disablePast: s, disableFuture: o} = this._options
                  , a = this._document.querySelector(`.${e_}.${zm}`)
                  , r = `${this._hour.textContent}:${this._minutes.textContent}`
                  , l = Number(this._hour.textContent)
                  , h = Number(this._minutes.textContent);
                e = vm(e, s, i),
                t = ym(t, o, i);
                const [c,d,u] = mm(t, !1)
                  , [p,f,g] = mm(e, !1)
                  , m = l < Number(p)
                  , _ = l > Number(c);
                let b = !0;
                a && (b = u === a.textContent);
                let v = !0;
                a && (v = g === a.textContent);
                const y = h > d && l === Number(c)
                  , x = h < f && l === Number(p);
                if (N.addClass(this._input, "active"),
                N.addStyle(this.toggleButton, {
                    pointerEvents: "auto"
                }),
                "" !== t) {
                    if (b && (_ || y))
                        return;
                    if ("AM" === u && "PM" === a.textContent)
                        return
                }
                if ("" !== e) {
                    if (v && (m || x))
                        return;
                    if ("PM" === g && "AM" === a.textContent)
                        return
                }
                void 0 !== ( ({format12: t, maxTime: e, minTime: i, disablePast: n, disableFuture: s}, o, a, r) => {
                    const l = mm(o)[1];
                    i = vm(i, n, t),
                    e = ym(e, s, t);
                    const [h,c,d] = mm(e, !1)
                      , [u,p,f] = mm(i, !1);
                    if (void 0 === d && void 0 === f)
                        if (void 0 === d) {
                            if ("" !== h && "" === u) {
                                if (Number(a) > Number(h))
                                    return;
                                if ("" !== c && void 0 === p && Number(a) > Number(h))
                                    return
                            } else if ("" === h && "" !== u && void 0 === c && "" !== p && (Number(a) < Number(u) || Number(a) < Number(u) && r < Number(p)))
                                return
                        } else if (void 0 === f)
                            if ("" !== h && "" === u) {
                                if (Number(a) > Number(h))
                                    return;
                                if ("" !== c && void 0 === p && (Number(a) > Number(h) || r > Number(c)))
                                    return
                            } else if ("" === h && "" !== u && void 0 === c && "" !== p && (Number(a) < Number(u) || r < Number(p)))
                                return;
                    return [a, l]
                }
                )(this._options, this._input, this._hour.textContent, this._minutes.textContent) && (this._isInvalidTimeFormat && N.removeClass(this._input, "is-invalid"),
                this._input.value = n ? r : null === a ? `${r} PM` : `${r} ${a.textContent}`,
                this.close(),
                I.trigger(this._input, Hm))
            }
            )
        }
        _handleHoverInlineBtn() {
            L.on(this._modal, "mouseover mouseleave", `.${Qm}`, ({type: t, target: e}) => {
                const i = B.find(`.${n_}`, this._modal)
                  , n = B.find(`.${s_}`, this._modal);
                "mouseover" === t ? N.hasClass(e, t_) ? i.forEach(t => N.addClass(t, zm)) : n.forEach(t => N.addClass(t, zm)) : N.hasClass(e, t_) ? i.forEach(t => N.removeClass(t, zm)) : n.forEach(t => N.removeClass(t, zm))
            }
            )
        }
        _handleDocumentClickInline() {
            I.on(document, Mm, ({target: t}) => {
                this._modal && !this._modal.contains(t) && (clearInterval(this._interval),
                this.close())
            }
            )
        }
        _handleSwitchHourMinute() {
            var t, e;
            t = "click",
            e = Gm,
            I.on(document, t, e, ({target: t}) => {
                N.hasClass(t, "active") || (document.querySelectorAll(e).forEach(t => {
                    N.hasClass(t, "active") && N.removeClass(t, "active")
                }
                ),
                N.addClass(t, "active"))
            }
            ),
            I.on(this._modal, "click", Gm, () => {
                const {format24: t} = this._options
                  , e = B.find(Gm, this._modal)
                  , i = B.find(`.${g_}`, this._modal)
                  , n = B.find(`.${u_}`, this._modal)
                  , s = B.find(`.${f_}`, this._modal)
                  , o = Number(this._hour.textContent)
                  , a = Number(this._minutes.textContent);
                t && (o > 12 || 0 === o) && (this._isInner = !0);
                const r = (e, s) => {
                    n.forEach(t => t.remove()),
                    i.forEach(t => t.remove()),
                    N.addClass(this._hand, m_),
                    setTimeout( () => {
                        N.removeClass(this._hand, m_)
                    }
                    , 401),
                    this._getAppendClock(e, `.${Um}`, s);
                    const r = () => {
                        const t = B.find(`.${u_}`, this._modal)
                          , e = B.find(`.${g_}`, this._modal);
                        this._addActiveClassToTip(t, o),
                        this._addActiveClassToTip(e, a)
                    }
                    ;
                    if (t) {
                        const t = B.find(`.${f_}`, this._modal);
                        setTimeout( () => {
                            this._addActiveClassToTip(t, o),
                            r()
                        }
                        , 401)
                    } else
                        setTimeout( () => {
                            r()
                        }
                        , 401)
                }
                ;
                e.forEach(e => {
                    N.hasClass(e, zm) && (N.hasClass(e, l_) ? (N.addClass(this._hand, m_),
                    N.addStyle(this._hand, {
                        transform: `rotateZ(${6 * this._minutes.textContent}deg)`,
                        height: this._outerHandPointerHeight
                    }),
                    t && s.length > 0 && s.forEach(t => t.remove()),
                    r(this.minutesArray, `${g_}`),
                    this._hour.style.pointerEvents = "",
                    this._minutes.style.pointerEvents = "none") : N.hasClass(e, t_) && (N.addStyle(this._hand, {
                        transform: `rotateZ(${30 * this._hour.textContent}deg)`
                    }),
                    Number(this._hour.textContent) > 12 || "00" === this._hour.textContent ? (N.addStyle(this._hand, {
                        transform: `rotateZ(${30 * this._hour.textContent - 360}deg)`,
                        height: this._innerHandPointerHeight
                    }),
                    Number(this._hour.textContent) > 12 && N.addStyle(this._hand, {
                        height: this._innerHandPointerHeight
                    })) : N.addStyle(this._hand, {
                        height: this._outerHandPointerHeight
                    }),
                    t && this._getAppendClock(this.innerHours, `.${qm}`, f_),
                    s.length > 0 && s.forEach(t => t.remove()),
                    r(this.hoursArray, `${u_}`),
                    N.addStyle(this._hour, {
                        pointerEvents: "none"
                    }),
                    N.addStyle(this._minutes, {
                        pointerEvents: ""
                    })))
                }
                )
            }
            )
        }
        _handleDisablingTipsMaxTime(t, e, i, n) {
            if (!this._options.maxTime && !this._options.disableFuture)
                return;
            const s = B.find(`.${u_}`)
              , o = B.find(`.${f_}`)
              , a = B.find(`.${g_}`);
            if (!e || e === t)
                return xm(o, n),
                xm(s, n),
                r = a,
                l = i,
                h = n,
                c = this._hour.textContent,
                void r.forEach(t => {
                    Number(t.textContent) > l && Number(c) == h && N.addClass(t, "disabled")
                }
                );
            var r, l, h, c;
            "AM" === e && "PM" === t && (s.forEach(t => {
                N.addClass(t, "disabled")
            }
            ),
            a.forEach(t => {
                N.addClass(t, "disabled")
            }
            ))
        }
        _handleDisablingTipsMinTime(t, e, i, n) {
            if (!this._options.minTime && !this._options.disablePast)
                return;
            const s = B.find(`.${u_}`)
              , o = B.find(`.${f_}`)
              , a = B.find(`.${g_}`);
            var r, l, h, c;
            e && e !== t ? "PM" === e && "AM" === t && (s.forEach(t => N.addClass(t, "disabled")),
            a.forEach(t => N.addClass(t, "disabled"))) : (wm(s, n),
            wm(o, n),
            r = a,
            l = i,
            h = n,
            c = this._hour.textContent,
            r.forEach(t => {
                Number(t.textContent) < l && Number(c) == h && N.addClass(t, "disabled")
            }
            ))
        }
        _handleSwitchTimeMode() {
            I.on(document, "click", `.${e_}`, ({target: t}) => {
                let {maxTime: e, minTime: i} = this._options;
                const {disablePast: n, disableFuture: s, format12: o} = this._options;
                i = vm(i, n, o),
                e = ym(e, s, o);
                let[a,r,l] = mm(e, !1)
                  , [h,c,d] = mm(i, !1);
                const u = B.find(`.${u_}`)
                  , p = B.find(`.${g_}`);
                if (u.forEach(t => {
                    N.removeClass(t, "disabled")
                }
                ),
                p.forEach(t => {
                    N.removeClass(t, "disabled")
                }
                ),
                this._handleDisablingTipsMinTime(t.textContent, d, c, h),
                this._handleDisablingTipsMaxTime(t.textContent, l, r, a),
                this._toggleAmPm(t.textContent),
                !N.hasClass(t, zm)) {
                    B.find(`.${e_}`).forEach(t => {
                        N.hasClass(t, zm) && N.removeClass(t, zm)
                    }
                    ),
                    N.addClass(t, zm)
                }
            }
            )
        }
        _handleClockClick() {
            let {maxTime: t, minTime: e} = this._options;
            const {disablePast: i, disableFuture: n, format12: s} = this._options;
            e = vm(e, i, s),
            t = ym(t, n, s);
            const o = mm(t, !1)[2]
              , a = mm(e, !1)[2]
              , r = mm(t, !1)[0]
              , l = mm(e, !1)[0]
              , h = B.findOne(`.${Zm}`);
            L.on(document, `${Dm} ${$m} ${Im} ${Lm} ${Pm} ${Bm} ${Rm} ${Nm}`, "", t => {
                gm() || t.preventDefault();
                const {type: e, target: i} = t
                  , {closeModalOnMinutesClick: n, switchHoursToMinutesOnClick: s} = this._options
                  , c = null !== B.findOne(`.${g_}`, this._modal)
                  , d = null !== B.findOne(`.${u_}`, this._modal)
                  , u = null !== B.findOne(`.${f_}`, this._modal)
                  , p = B.find(`.${g_}`, this._modal)
                  , f = fm(t, h)
                  , g = h.offsetWidth / 2;
                let m = Math.atan2(f.y - g, f.x - g);
                if (gm()) {
                    const e = fm(t, h, !0);
                    m = Math.atan2(e.y - g, e.x - g)
                }
                let _ = null
                  , b = null
                  , v = null;
                if ("mousedown" === e || "mousemove" === e || "touchmove" === e || "touchstart" === e)
                    "mousedown" !== e && "touchstart" !== e && "touchmove" !== e || (this._hasTargetInnerClass(i) || N.hasClass(i, Zm) || N.hasClass(i, Um) || N.hasClass(i, g_) || N.hasClass(i, u_) || N.hasClass(i, Xm) || N.hasClass(i, Jm) || N.hasClass(i, r_) || N.hasClass(i, d_)) && (this._isMouseMove = !0,
                    gm() && t.touches && (_ = t.touches[0].clientX,
                    b = t.touches[0].clientY,
                    v = document.elementFromPoint(_, b)));
                else if ("mouseup" === e || "touchend" === e) {
                    if (this._isMouseMove = !1,
                    this._hasTargetInnerClass(i) || N.hasClass(i, Um) || N.hasClass(i, u_) || N.hasClass(i, Xm) || N.hasClass(i, Jm) || N.hasClass(i, r_) || N.hasClass(i, d_)) {
                        if ((d || u) && s) {
                            const t = Number(this._hour.textContent) > r || Number(this._hour.textContent) < l;
                            if (this._options.format24 && "" != r && "" != l && t)
                                return;
                            if (this._options.format24 && "" != r && this._hour.textContent > r)
                                return;
                            if (this._options.format24 && "" != l && this._hour.textContent < l)
                                return
                        }
                        N.hasClass(this._minutes, zm) || I.trigger(this._minutes, "click")
                    }
                    if (c && n) {
                        const t = B.findOne(`.${Ym}`, this._modal);
                        I.trigger(t, "click")
                    }
                }
                if (c) {
                    let t;
                    const e = Math.trunc(180 * m / Math.PI) + 90
                      , {degrees: i, minute: n} = this._makeMinutesDegrees(e, t);
                    if (void 0 === this._handlerMaxMinMinutesOptions(i, n))
                        return;
                    const {degrees: s, minute: o} = this._handlerMaxMinMinutesOptions(i, n);
                    if (this._isMouseMove) {
                        if (N.addStyle(this._hand, {
                            transform: `rotateZ(${s}deg)`
                        }),
                        void 0 === o)
                            return;
                        const t = () => o >= 10 || "00" === o ? o : `0${o}`;
                        this._minutes.textContent = t(),
                        this._toggleClassActive(this.minutesArray, this._minutes, p),
                        this._toggleBackgroundColorCircle(`${g_}`),
                        this._objWithDataOnChange.degreesMinutes = s,
                        this._objWithDataOnChange.minutes = o
                    }
                }
                if (d || u) {
                    let e, n = Math.trunc(180 * m / Math.PI) + 90;
                    if (n = 30 * Math.round(n / 30),
                    N.addClass(this._circle, "active"),
                    void 0 === this._makeHourDegrees(i, n, e))
                        return;
                    const s = () => {
                        if (gm() && n && v) {
                            const {degrees: t, hour: i} = this._makeHourDegrees(v, n, e);
                            return this._handleMoveHand(v, i, t)
                        }
                        {
                            const {degrees: t, hour: s} = this._makeHourDegrees(i, n, e);
                            return this._handleMoveHand(i, s, t)
                        }
                    }
                    ;
                    this._objWithDataOnChange.degreesHours = n,
                    this._handlerMaxMinHoursOptions(n, r, l, o, a, t) && s()
                }
                t.stopPropagation()
            }
            )
        }
        _hasTargetInnerClass(t) {
            return N.hasClass(t, qm) || N.hasClass(t, f_) || N.hasClass(t, p_)
        }
        _handleMoveHand(t, e, i) {
            const n = B.find(`.${u_}`, this._modal)
              , s = B.find(`.${f_}`, this._modal);
            this._isMouseMove && (this._hasTargetInnerClass(t) ? N.addStyle(this._hand, {
                height: this._innerHandPointerHeight
            }) : N.addStyle(this._hand, {
                height: this._outerHandPointerHeight
            }),
            N.addStyle(this._hand, {
                transform: `rotateZ(${i}deg)`
            }),
            this._hour.textContent = e >= 10 || "00" === e ? e : `0${e}`,
            this._toggleClassActive(this.hoursArray, this._hour, n),
            this._toggleClassActive(this.innerHours, this._hour, s),
            this._objWithDataOnChange.hour = e >= 10 || "00" === e ? e : `0${e}`)
        }
        _handlerMaxMinMinutesOptions(t, e) {
            let {maxTime: i, minTime: n} = this._options;
            const {format12: s, increment: o, disablePast: a, disableFuture: r} = this._options;
            n = vm(n, a, s),
            i = ym(i, r, s);
            const l = mm(i, !1)[1]
              , h = mm(n, !1)[1]
              , c = mm(i, !1)[0]
              , d = mm(n, !1)[0]
              , u = mm(i, !1)[2]
              , p = mm(n, !1)[2]
              , f = "" !== l ? 6 * l : ""
              , g = "" !== h ? 6 * h : ""
              , m = Number(this._hour.textContent);
            if (u || p) {
                if ("" !== n) {
                    if ("PM" === p && this._isAmEnabled)
                        return;
                    if ("PM" === p && this._isPmEnabled) {
                        if (m < Number(d))
                            return;
                        if (m <= Number(d) && t <= g - 6)
                            return t
                    } else if ("AM" === p && this._isAmEnabled) {
                        if (m < Number(d))
                            return;
                        if (m <= Number(d) && t <= g - 6)
                            return t
                    }
                }
                if ("" !== i) {
                    if ("AM" === u && this._isPmEnabled)
                        return;
                    if ("PM" === u && this._isPmEnabled) {
                        if (m >= Number(c) && t >= f + 6)
                            return t
                    } else if ("AM" === u && this._isAmEnabled && m >= Number(c) && t >= f + 6)
                        return t
                }
            } else if ("" !== i && "" !== n) {
                if (c == m && t > f || d == m && t < g)
                    return t
            } else if ("" !== n && m <= Number(d)) {
                if (t <= g - 6)
                    return t
            } else if ("" !== i && m >= Number(c) && t >= f + 6)
                return t;
            return o && (t = 30 * Math.round(t / 30)),
            t <= 0 ? t = 360 + t : t >= 360 && (t = 0),
            {
                degrees: t,
                minute: e
            }
        }
        _removeModal() {
            const t = this._animations ? 300 : 0;
            setTimeout( () => {
                this._removeModalElements(),
                this._options.inline || this._scrollBar.reset()
            }
            , t),
            this._removeFocusTrap(),
            L.off(this._document, `${Mm} ${Om} ${Dm} ${$m} ${Im} ${Lm} ${Pm} ${Bm} ${Rm} ${Nm}`),
            I.off(window, Om)
        }
        _removeModalElements() {
            this._modal && this._modal.remove()
        }
        _toggleBackdropAnimation(t=!1) {
            t ? (N.addClass(this._wrapper, "animation"),
            N.addClass(this._wrapper, "fade-out"),
            this._wrapper.style.animationDuration = "300ms") : (N.addClass(this._wrapper, "animation"),
            N.addClass(this._wrapper, "fade-in"),
            this._wrapper.style.animationDuration = "300ms",
            this._options.inline || N.addClass(this._clock, Km))
        }
        _addActiveClassToTip(t, e) {
            t.forEach(t => {
                Number(t.textContent) === Number(e) && N.addClass(t, zm)
            }
            )
        }
        _setHourOrMinute(t) {
            return t < 10 ? `0${t}` : t
        }
        _appendTimes() {
            const {format24: t} = this._options;
            t ? (this._getAppendClock(this.hoursArray, `.${Um}`, `${u_}`),
            this._getAppendClock(this.innerHours, `.${qm}`, f_)) : this._getAppendClock(this.hoursArray, `.${Um}`, `${u_}`)
        }
        _getConfig(t) {
            const e = N.getDataAttributes(this._element);
            return t = {
                ...y_,
                ...e,
                ...t,
                isRTL: m
            },
            d(Cm, t, x_),
            t
        }
        _getContainer() {
            return B.findOne(this._options.container)
        }
        _listenToUserInput() {
            I.on(this._input, "input", t => {
                this._handleUserInput(t.target.value)
            }
            )
        }
        _handleUserInput(t) {
            const {format24: e, format12: i} = this._options;
            if ("" === this._input.value)
                return;
            const n = /^(0?[1-9]|1[0-2]):[0-5][0-9] [APap][mM]$/.test(t);
            !0 === /^(?:[01]\d|2[0-3]):[0-5]\d$/.test(t) && e ? (this._isInvalidTimeFormat = !1,
            this._inputValue = this._input.value,
            this._currentTime = pm(this._inputValue)) : !0 === n && i ? (this._isInvalidTimeFormat = !1,
            this._inputValue = this._input.value,
            this._currentTime = dm(this._inputValue)) : this._isInvalidTimeFormat = !0
        }
        static jQueryInterface(t) {
            return this.each(function() {
                let e = s.getData(this, km);
                const i = "object" == typeof t && t;
                if ((e || !/dispose|hide/.test(t)) && (e || (e = new w_(this,i)),
                "string" == typeof t)) {
                    if (void 0 === e[t])
                        throw new TypeError(`No method named "${t}"`);
                    e[t]()
                }
            })
        }
    }
    class C_ extends ao {
        static get NAME() {
            return "navbar"
        }
        init() {
            this._onScroll(),
            this._addEvent(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        dispose() {
            this._removeEvent(),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _addEvent() {
            I.on(window, "scroll", () => this._onScroll())
        }
        _removeEvent() {
            I.off(window, "scroll")
        }
        _onScroll() {
            window.scrollY > 0 ? N.addClass(this._element, "navbar-scrolled") : N.removeClass(this._element, "navbar-scrolled")
        }
        static jQueryInterface(t) {
            this.each(function() {
                const e = C_.getOrCreateInstance(this);
                if ("string" == typeof t) {
                    if (void 0 === e[t])
                        throw new TypeError(`No method named "${t}"`);
                    e[t]()
                }
            })
        }
    }
    const k_ = "infiniteScroll"
      , S_ = `mdb.${k_}`
      , T_ = `completed${`.${S_}`}`
      , A_ = {
        infiniteDirection: "y"
    }
      , E_ = {
        infiniteDirection: "string"
    };
    class M_ extends ao {
        constructor(t, e) {
            super(t),
            this._element = t,
            this._options = this._getConfig(e),
            this._elementScrollHandler = this._scrollHandler.bind(this),
            this._init(),
            this._element !== window && (N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor))
        }
        static get NAME() {
            return k_
        }
        get rect() {
            return this._element.getBoundingClientRect()
        }
        get condition() {
            return this._element === window ? Math.abs(window.scrollY + window.innerHeight - document.documentElement.scrollHeight) < 1 : "x" === this._options.infiniteDirection ? this.rect.width + this._element.scrollLeft + 10 >= this._element.scrollWidth : Math.ceil(this.rect.height + this._element.scrollTop) >= this._element.scrollHeight
        }
        dispose() {
            I.off(this._element, "scroll", this._elementScrollHandler),
            this._element !== window && N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _init() {
            I.on(this._element, "scroll", this._elementScrollHandler)
        }
        _scrollHandler() {
            this.condition && I.trigger(this._element, T_)
        }
        _getConfig(t) {
            const e = {
                ...A_,
                ...N.getDataAttributes(this._element),
                ...t
            };
            return d(k_, e, E_),
            e
        }
        static jQueryInterface(t) {
            return this.each(function() {
                let e = s.getData(this, S_);
                if (e || (e = new M_(this,"object" == typeof t && t)),
                "string" == typeof t) {
                    if (void 0 === e[t])
                        throw new TypeError(`No method named "${t}"`);
                    e[t](this)
                }
            })
        }
    }
    const O_ = "lazyLoad"
      , D_ = "mdb.lazyLoad"
      , $_ = "lazy"
      , I_ = ["img", "video"]
      , L_ = `.${D_}`
      , P_ = `contentLoaded${L_}`
      , R_ = `loadingError${L_}`
      , N_ = {
        lazySrc: "(string|null)",
        lazyDelay: "number",
        lazyAnimation: "string",
        lazyOffset: "number",
        lazyPlaceholder: "(string|undefined)",
        lazyError: "(string|undefined)"
    }
      , B_ = {
        lazySrc: null,
        lazyDelay: 500,
        lazyAnimation: "fade-in",
        lazyOffset: 0
    };
    class H_ extends ao {
        constructor(t, e) {
            super(t),
            this._options = this._getConfig(e),
            this._scrollHandler = this._handleScroll.bind(this),
            this._errorHandler = this._setElementError.bind(this),
            this._childrenInstances = null,
            this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return O_
        }
        get offsetValues() {
            return this._element.getBoundingClientRect()
        }
        get inViewport() {
            if (this.parent) {
                const t = this.parent.getBoundingClientRect();
                return t.y > 0 && t.y < window.innerHeight && this.offsetValues.y >= t.y && this.offsetValues.y <= t.y + t.height && this.offsetValues.y <= window.innerHeight
            }
            return this.offsetValues.top + this._options.lazyOffset <= window.innerHeight && this.offsetValues.bottom >= 0
        }
        get parent() {
            const [t] = B.parents(this._element, ".lazy");
            return t
        }
        get node() {
            return this._element.nodeName
        }
        get isContainer() {
            return !B.matches(this._element, I_)
        }
        dispose() {
            I.off(this._element, "load"),
            I.off(this._element, "error", this._errorHandler),
            I.off(window, "scroll", this._scrollHandler),
            this._animation && (this._animation.dispose(),
            this._animation = null),
            this._childrenInstances && this._childrenInstances.forEach(t => t.dispose()),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _init() {
            N.addClass(this._element, $_),
            this.isContainer ? this._setupContainer() : this._setupElement()
        }
        _setupElement() {
            I.one(this._element, "error", this._errorHandler),
            this._options.lazyPlaceholder && this._setPlaceholder(),
            this._animation = new Ia(this._element,{
                animation: this._options.lazyAnimation,
                animationStart: "onLoad"
            }),
            I.one(this._element, "load", this._scrollHandler),
            this.parent && I.on(this.parent, "scroll", this._scrollHandler),
            I.on(window, "scroll", this._scrollHandler)
        }
        _handleScroll() {
            this.inViewport && (this._timeout = setTimeout( () => {
                this._setSrc(),
                this._element.classList.remove($_),
                this._removeAttrs(),
                this._animation.init()
            }
            , this._options.lazyDelay),
            this.parent && I.off(this.parent, "scroll", this._scrollHandler),
            I.off(window, "scroll", this._scrollHandler))
        }
        _setElementError() {
            this._options.lazyError && this._element.src !== this._options.lazyError ? this._element.setAttribute("src", this._options.lazyError) : this._element.alt = "404 not found",
            I.trigger(this._element, R_)
        }
        _setSrc() {
            this._element.setAttribute("src", this._options.lazySrc),
            I.trigger(this._element, P_)
        }
        _setPlaceholder() {
            "IMG" === this.node ? this._element.setAttribute("src", this._options.lazyPlaceholder) : "VIDEO" === this.node && this._element.setAttribute("poster", this._options.lazyPlaceholder)
        }
        _removeAttrs() {
            ["src", "delay", "animation", "placeholder", "offset", "error"].forEach(t => {
                N.removeDataAttribute(this._element, `lazy-${t}`)
            }
            )
        }
        _setupContainer() {
            this._childrenInstances = B.children(this._element, I_).map(t => new H_(t,this._options))
        }
        _getConfig(t) {
            const e = {
                ...B_,
                ...t,
                ...N.getDataAttributes(this._element)
            };
            return d(O_, e, N_),
            e
        }
        static jQueryInterface(t) {
            return this.each(function() {
                let e = s.getData(this, D_);
                if (e || (e = new H_(this,"object" == typeof t && t)),
                "string" == typeof t) {
                    if (void 0 === e[t])
                        throw new TypeError(`No method named "${t}"`);
                    e[t](this)
                }
            })
        }
    }
    function F_(t) {
        return t.getDate()
    }
    function z_(t) {
        return t.getDay()
    }
    function j_(t) {
        return t.getMonth()
    }
    function W_(t) {
        return t.getFullYear()
    }
    function V_(t) {
        return function(t) {
            return q_(t.getFullYear(), t.getMonth() + 1, 0)
        }(t).getDate()
    }
    function Y_() {
        return new Date
    }
    function X_(t, e) {
        return K_(t, 12 * e)
    }
    function K_(t, e) {
        const i = q_(t.getFullYear(), t.getMonth() + e, t.getDate());
        return F_(t) !== F_(i) && i.setDate(0),
        i
    }
    function U_(t, e) {
        return q_(t.getFullYear(), t.getMonth(), t.getDate() + e)
    }
    function q_(t, e, i) {
        const n = new Date(t,e,i);
        return t >= 0 && t < 100 && n.setFullYear(n.getFullYear() - 1900),
        n
    }
    function Z_(t) {
        const e = t.split("-");
        return q_(e[0], e[1], e[2])
    }
    function G_(t) {
        return !Number.isNaN(t.getTime())
    }
    function Q_(t, e) {
        return 2 === e.length && (tb(t, e[0]) > 0 && tb(t, e[1]) < 0)
    }
    function J_(t, e) {
        if (2 === e.length) {
            if (eb(e[0], e[1]))
                return !1;
            if (eb(t, e[0]))
                return "first";
            if (eb(t, e[1]))
                return "last"
        }
        return !1
    }
    function tb(t, e) {
        return W_(t) - W_(e) || j_(t) - j_(e) || F_(t) - F_(e)
    }
    function eb(t, e) {
        return t.setHours(0, 0, 0, 0),
        e.setHours(0, 0, 0, 0),
        t.getTime() === e.getTime()
    }
    function ib(t, e) {
        const i = W_(t) - function(t, e, i) {
            let n = 0;
            if (i) {
                n = W_(i) - t + 1
            } else
                e && (n = W_(e));
            return n
        }();
        return (i % (n = e) + n) % n;
        var n
    }
    function nb(t, e, i, n, s, o) {
        const a = new Date;
        a.setHours(0, 0, 0, 0);
        const r = e && tb(t, e) <= -1
          , l = i && tb(t, i) >= 1
          , h = s && tb(t, a) <= -1
          , c = o && tb(t, a) >= 1
          , d = n && !1 === n(t);
        return r || l || d || h || c
    }
    function sb(t, e, i, n, s, o) {
        const a = new Date
          , r = n && W_(n)
          , l = n && j_(n)
          , h = i && W_(i)
          , c = i && j_(i)
          , d = W_(a)
          , u = j_(a);
        return l && r && (e > r || e === r && t > l) || c && h && (e < h || e === h && t < c) || s && (e < d || e === d && t < u) || o && (e > d || e === d && t > u)
    }
    function ob(t, e, i, n, s) {
        const o = e && W_(e)
          , a = i && W_(i)
          , r = W_(new Date);
        return a && t > a || o && t < o || n && t < r || s && t > r
    }
    function ab(t, e, i, n, s, o, a, r) {
        return "days" === i ? W_(t) === W_(e) && j_(t) === j_(e) : "months" === i ? W_(t) === W_(e) : "years" === i && (W_(e) >= r && W_(e) <= a)
    }
    function rb(t, e, i, n, s, o, a, r, l, h) {
        const c = j_(t)
          , d = W_(t)
          , u = F_(t)
          , p = z_(t)
          , f = _("div");
        if (s.inline) {
            const u = `\n    ${cb(t, c, d, e, i, n, s, o, a, r, h)}\n`;
            N.addClass(f, "datepicker-dropdown-container"),
            N.addClass(f, `datepicker-dropdown-container-${l}`),
            f.innerHTML = u
        } else {
            const g = `\n    ${function(t, e, i, n, s, o) {
                return `\n      <div class="datepicker-header">\n      ${n.headerTemplate ? lb(t, e, i, s, n) : `\n        <div class="datepicker-title">\n          <span class="datepicker-title-text">${n.title}</span>\n        </div>\n        <div class="datepicker-date">\n          <span class="datepicker-date-text">${hb(s, o, n)}</span>\n        </div>\n        `}\n      </div>\n    `
            }(u, p, c, s, t, h)}\n    ${cb(t, c, d, e, i, n, s, o, a, r, h)}\n  `;
            N.addClass(f, "datepicker-modal-container"),
            N.addClass(f, `datepicker-modal-container-${l}`),
            f.innerHTML = g
        }
        return s.dateRange && N.addClass(f, "datepicker-date-range"),
        f
    }
    function lb(t, e, i, n, s) {
        const {weekdaysShort: o, weekdaysFull: a, monthsShort: r, headerTemplateModifier: l, headerTemplate: h} = s
          , c = l ? l(n) : n;
        return h.replaceAll("[day]", t).replaceAll("[weekday]", o[e]).replaceAll("[weekdayFull]", a[e]).replaceAll("[month]", r[i]).replaceAll("[selected]", c)
    }
    function hb(t, e, i) {
        const {dateRange: n, weekdaysShort: s, monthsShort: o} = i
          , a = t => {
            const e = j_(t)
              , i = F_(t)
              , n = z_(t);
            return `${s[n]}, ${o[e]} ${i}`
        }
        ;
        if (n) {
            let i, n;
            return e && 0 !== e.length ? [n,i] = e : (n = t,
            i = t),
            `${a(n)} - ${i ? a(i) : ""}`
        }
        return a(t)
    }
    function cb(t, e, i, n, s, o, a, r, l, h, c) {
        let d;
        return d = a.inline ? `\n    <div class="datepicker-main">\n      ${ub(e, i, a)}\n      <div class="datepicker-view" tabindex="0">\n        ${db(t, i, n, s, o, a, r, l, h, c)}\n      </div>\n    </div>\n  ` : `\n      <div class="datepicker-main">\n        ${ub(e, i, a)}\n        <div class="datepicker-view" tabindex="0">\n          ${db(t, i, n, s, o, a, r, l, h, c)}\n        </div>\n        ${function(t) {
            const e = `<button class="datepicker-footer-btn datepicker-ok-btn" aria-label="${t.okBtnLabel}">${t.okBtnText}</button>`
              , i = `<button class="datepicker-footer-btn datepicker-cancel-btn" aria-label="${t.cancelBtnLabel}">${t.cancelBtnText}</button>`
              , n = `<button class="datepicker-footer-btn datepicker-clear-btn" aria-label="${t.clearBtnLabel}">${t.clearBtnText}</button>`;
            return `\n        <div class="datepicker-footer">\n          ${t.removeClearBtn ? "" : n}\n          ${t.removeCancelBtn ? "" : i}\n          ${t.removeOkBtn ? "" : e}\n        </div>\n      `
        }(a)}\n      </div>\n    `,
        d
    }
    function db(t, e, i, n, s, o, a, r, l, h) {
        let c;
        return c = "days" === o.view ? pb(t, i, o, h) : "months" === o.view ? gb(e, n, s, o, a) : mb(t, n, o, r, l),
        c
    }
    function ub(t, e, i) {
        return `\n    <div class="datepicker-date-controls">\n      <button class="datepicker-view-change-button" aria-label="${i.switchToMultiYearViewLabel}">\n        ${i.monthsFull[t]} ${e}\n      </button>\n      <div class="datepicker-arrow-controls">\n        <button class="datepicker-previous-button" aria-label="${i.prevMonthLabel}"></button>\n        <button class="datepicker-next-button" aria-label="${i.nextMonthLabel}"></button>\n      </div>\n    </div>\n    `
    }
    function pb(t, e, i, n) {
        const s = fb(t, e, i, n, 1)
          , o = i.dateRange ? fb(K_(t, 1), e, i, n, 2) : null
          , a = `\n      <tr>\n        ${i.weekdaysNarrow.map( (t, e) => `<th class="datepicker-day-heading" scope="col" aria-label="${i.weekdaysFull[e]}">${t}</th>`).join("")}\n      </tr>\n    `
          , r = (t, e) => `\n    <table class="datepicker-table">\n        <thead class="text-center">\n          ${i.dateRange ? `\n          <tr class="datepicker-month-header">\n            <th colspan="7">${i.monthsFull[e]}</th>\n          </tr>\n          ` : ""}\n          ${a}\n        </thead>\n        <tbody class="datepicker-table-body">\n         ${(t => t.map(t => `\n          <tr>\n            ${t.map(t => {
            const e = `${i.weekdaysFull[z_(t.date)]}, ${i.monthsFull[j_(t.date)]} ${F_(t.date)}, ${W_(t.date)}`
              , n = `${W_(t.date)}-${j_(t.date)}-${F_(t.date)}`
              , s = "first" === t.isEdgeOfRange
              , o = "last" === t.isEdgeOfRange;
            return `\n                  <td\n                    class="${["datepicker-cell", "datepicker-small-cell", "datepicker-day-cell", t.currentMonth ? "" : "disabled", t.disabled ? "disabled" : "", t.isToday ? "current" : "", t.isSelected ? "selected" : "", t.isInRange ? "in-range" : "", s ? "first-in-range" : "", o ? "last-in-range" : ""].filter(Boolean).join(" ")}"\n                    data-mdb-date="${t.currentMonth ? n : ""}"\n                    aria-label="${e}"\n                    aria-selected="${t.isSelected}"\n                    ${t.disabled ? 'aria-disabled="true"' : ""}>\n                    <div\n                      class="datepicker-cell-content datepicker-small-cell-content"\n                      style="${t.currentMonth ? "display: block" : "display: none"}">\n                      ${t.dayNumber}\n                    </div>\n                  </td>\n                `
        }
        ).join("")}\n          </tr>\n        `).join(""))(t)}\n        </tbody>\n      </table>\n    `;
        return i.dateRange ? `\n    ${r(s, j_(t))}\n    <div class="vr"></div>\n    ${r(o, j_(K_(t, 1)))}\n    ` : r(s, j_(t))
    }
    function fb(t, e, i, n=[], s) {
        const o = []
          , a = j_(t)
          , r = j_(K_(t, -1))
          , l = j_(K_(t, 1))
          , h = W_(t)
          , c = function(t, e, i) {
            const n = i.startDay
              , s = n > 0 ? 7 - n : 0
              , o = new Date(t,e).getDay() + s;
            return o >= 7 ? o - 7 : o
        }(h, a, i)
          , d = V_(t)
          , u = V_(K_(t, -1));
        let p = 1
          , f = !1;
        const g = 1 === s ? a : r
          , m = 1 === s ? l : a
          , _ = i.dateRange ? a === g || a === m : a === g
          , b = (t, e) => !(!e || 0 === (null == e ? void 0 : e.length)) && (i.dateRange ? 1 === e.length ? eb(t, e[0]) : eb(t, e[0]) || eb(t, e[1]) : eb(t, e));
        for (let v = 1; v < 7; v++) {
            const t = [];
            if (1 === v) {
                for (let o = u - c + 1; o <= u; o++) {
                    const s = q_(h, r, o);
                    t.push({
                        date: s,
                        currentMonth: f,
                        isSelected: b(s, e) && f,
                        isInRange: Q_(s, n) && f,
                        isEdgeOfRange: !!f && J_(s, n),
                        isToday: eb(s, Y_()),
                        dayNumber: F_(s),
                        disabled: nb(s, i.min, i.max, i.filter, i.disablePast, i.disableFuture)
                    })
                }
                f = !0;
                const s = 7 - t.length;
                for (let o = 0; o < s; o++) {
                    const s = q_(h, a, p);
                    t.push({
                        date: s,
                        currentMonth: f,
                        isSelected: b(s, e) && _,
                        isInRange: Q_(s, n) && f,
                        isEdgeOfRange: !!f && J_(s, n),
                        isToday: eb(s, Y_()),
                        dayNumber: F_(s),
                        disabled: nb(s, i.min, i.max, i.filter, i.disablePast, i.disableFuture)
                    }),
                    p++
                }
            } else
                for (let s = 1; s < 8; s++) {
                    p > d && (p = 1,
                    f = !1);
                    const s = q_(h, f ? a : l, p);
                    t.push({
                        date: s,
                        currentMonth: f,
                        isSelected: b(s, e) && f,
                        isInRange: Q_(s, n) && f,
                        isEdgeOfRange: !!f && J_(s, n),
                        isToday: eb(s, Y_()),
                        dayNumber: F_(s),
                        disabled: nb(s, i.min, i.max, i.filter, i.disablePast, i.disableFuture)
                    }),
                    p++
                }
            o.push(t)
        }
        return o
    }
    function gb(t, e, i, n, s) {
        const o = function({monthsShort: t}, e) {
            return t.reduce( (t, i, n) => {
                const s = Math.floor(n / e);
                return t[s] || (t[s] = []),
                t[s].push(i),
                t
            }
            , [])
        }(n, s)
          , a = j_(Y_())
          , r = W_(Y_());
        return `\n      <table class="datepicker-table">\n        <tbody class="datepicker-table-body">\n         ${`\n      ${o.map(s => `\n          <tr>\n          ${s.map(s => {
            const o = n.monthsShort.indexOf(s)
              , l = sb(o, t, n.min, n.max, n.disablePast, n.disableFuture);
            return `\n                <td class="datepicker-cell datepicker-large-cell datepicker-month-cell \n                ${l ? "disabled" : ""} ${o === i && t === e ? "selected" : ""} ${o === a && t === r ? "current" : ""}" data-mdb-month="${o}" data-mdb-year="${t}" aria-label="${s}, ${t}"  ${l ? "aria-disabled=true" : ""}>\n                  <div class="datepicker-cell-content datepicker-large-cell-content">${s}</div>\n                </td>\n              `
        }
        ).join("")}\n          </tr>\n        `).join("")}\n    `}\n        </tbody>\n      </table>\n    `
    }
    function mb(t, e, i, n, s) {
        const o = function(t, e, i) {
            const n = []
              , s = W_(t)
              , o = ib(t, e)
              , a = s - o;
            let r = [];
            for (let l = 0; l < e; l++)
                if (r.push(a + l),
                r.length === i) {
                    const t = r;
                    n.push(t),
                    r = []
                }
            return n
        }(t, n, s)
          , a = W_(Y_());
        return `\n      <table class="datepicker-table">\n        <tbody class="datepicker-table-body">\n        ${`\n    ${o.map(t => `\n        <tr>\n          ${t.map(t => {
            const n = ob(t, i.min, i.max, i.disablePast, i.disableFuture);
            return `\n              <td class="datepicker-cell datepicker-large-cell datepicker-year-cell\n              ${n ? "disabled" : ""} ${t === e ? "selected" : ""} ${t === a ? "current" : ""}" aria-label="${t}" data-mdb-year="${t}" ${n ? 'aria-disabled="true"' : ""}>\n                <div class="datepicker-cell-content datepicker-large-cell-content">${t}</div>\n              </td>\n            `
        }
        ).join("")}\n        </tr>\n      `).join("")}\n  `}\n        </tbody>\n      </table>\n    `
    }
    const _b = 24
      , bb = "datepicker"
      , vb = `mdb.${bb}`
      , yb = `.${vb}`
      , xb = `close${yb}`
      , wb = `open${yb}`
      , Cb = `valueChanged${yb}`
      , kb = `viewChanged${yb}`
      , Sb = `click${yb}.data-api`
      , Tb = '[data-mdb-toggle="datepicker"]'
      , Ab = {
        title: "Select date",
        container: "body",
        disablePast: !1,
        disableFuture: !1,
        monthsFull: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        weekdaysFull: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        weekdaysNarrow: ["S", "M", "T", "W", "T", "F", "S"],
        okBtnText: "Ok",
        clearBtnText: "Clear",
        cancelBtnText: "Cancel",
        okBtnLabel: "Confirm selection",
        clearBtnLabel: "Clear selection",
        cancelBtnLabel: "Cancel selection",
        nextMonthLabel: "Next month",
        prevMonthLabel: "Previous month",
        nextYearLabel: "Next year",
        prevYearLabel: "Previous year",
        nextMultiYearLabel: "Next 24 years",
        prevMultiYearLabel: "Previous 24 years",
        switchToMultiYearViewLabel: "Switch to year list",
        switchToDayViewLabel: "Switch to day list",
        startDate: null,
        startDay: 0,
        format: "dd/mm/yyyy",
        view: "days",
        min: null,
        max: null,
        filter: null,
        inline: !1,
        toggleButton: !0,
        animations: !0,
        confirmDateOnSelect: !1,
        removeOkBtn: !1,
        removeCancelBtn: !1,
        removeClearBtn: !1,
        headerTemplate: null,
        headerTemplateModifier: null,
        dateRange: !1,
        toggleButtonLabel: "Open Datepicker"
    }
      , Eb = {
        title: "string",
        container: "string",
        disablePast: "boolean",
        disableFuture: "boolean",
        monthsFull: "array",
        monthsShort: "array",
        weekdaysFull: "array",
        weekdaysShort: "array",
        weekdaysNarrow: "array",
        okBtnText: "string",
        clearBtnText: "string",
        cancelBtnText: "string",
        okBtnLabel: "string",
        clearBtnLabel: "string",
        cancelBtnLabel: "string",
        nextMonthLabel: "string",
        prevMonthLabel: "string",
        nextYearLabel: "string",
        prevYearLabel: "string",
        nextMultiYearLabel: "string",
        prevMultiYearLabel: "string",
        switchToMultiYearViewLabel: "string",
        switchToDayViewLabel: "string",
        startDate: "(null|string|date)",
        startDay: "number",
        format: "string",
        view: "string",
        min: "(null|date|string)",
        max: "(null|date|string)",
        filter: "(null|function)",
        inline: "boolean",
        toggleButton: "boolean",
        animations: "boolean",
        confirmDateOnSelect: "boolean",
        removeOkBtn: "boolean",
        removeCancelBtn: "boolean",
        removeClearBtn: "boolean",
        headerTemplate: "(null|string)",
        headerTemplateModifier: "(null|function)",
        dateRange: "boolean",
        toggleButtonLabel: "string"
    };
    class Mb extends ao {
        constructor(t, e) {
            super(t),
            this._input = B.findOne("input", this._element),
            this._options = this._getConfig(e),
            this._activeDate = new Date,
            this._selectedDate = null,
            this._selectedRange = [],
            this._selectedYear = null,
            this._selectedMonth = null,
            this._firstVisibleMonth = null,
            this._headerDate = null,
            this._headerYear = null,
            this._headerMonth = null,
            this._view = this._options.view,
            this._popper = null,
            this._focusTrap = null,
            this._isOpen = !1,
            this._toggleButtonId = this._element.id ? `datepicker-toggle-${this._element.id}` : o("datepicker-toggle-"),
            this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations,
            this._scrollBar = new ce,
            this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return bb
        }
        get container() {
            return B.findOne(`.datepicker-modal-container-${this._toggleButtonId}`) || B.findOne(`.datepicker-dropdown-container-${this._toggleButtonId}`)
        }
        get options() {
            return this._options
        }
        get activeCell() {
            let t;
            return "days" === this._view && (t = this._getActiveDayCell()),
            "months" === this._view && (t = this._getActiveMonthCell()),
            "years" === this._view && (t = this._getActiveYearCell()),
            t
        }
        get activeDay() {
            return F_(this._activeDate)
        }
        get activeMonth() {
            return j_(this._activeDate)
        }
        get activeYear() {
            return W_(this._activeDate)
        }
        get firstYearInView() {
            return this.activeYear - ib(this._activeDate, _b)
        }
        get lastYearInView() {
            return this.firstYearInView + _b - 1
        }
        get viewChangeButton() {
            return B.findOne(".datepicker-view-change-button", this.container)
        }
        get previousButton() {
            return B.findOne(".datepicker-previous-button", this.container)
        }
        get nextButton() {
            return B.findOne(".datepicker-next-button", this.container)
        }
        get okButton() {
            return B.findOne(".datepicker-ok-btn", this.container)
        }
        get cancelButton() {
            return B.findOne(".datepicker-cancel-btn", this.container)
        }
        get clearButton() {
            return B.findOne(".datepicker-clear-btn", this.container)
        }
        get datesContainer() {
            return B.findOne(".datepicker-view", this.container)
        }
        get toggleButton() {
            return B.findOne(".datepicker-toggle-button", this._element)
        }
        get isSelectionCompleted() {
            return !this.options.dateRange || this.isRangeComplete
        }
        get isRangeComplete() {
            return 2 === this._selectedRange.length
        }
        get hasPartialRange() {
            return 1 === this._selectedRange.length
        }
        get visibleDates() {
            return B.find("td", this.datesContainer)
        }
        update(t={}) {
            this._options = this._getConfig({
                ...this._options,
                ...t
            })
        }
        _getConfig(t) {
            const e = N.getDataAttributes(this._element);
            if (t = {
                ...Ab,
                ...e,
                ...t
            },
            d(bb, t, Eb),
            t.max && "string" == typeof t.max && (t.max = new Date(t.max)),
            t.min && "string" == typeof t.min && (t.min = new Date(t.min)),
            t.startDay && 0 !== t.startDay) {
                const e = this._getNewDaysOrderArray(t);
                t.weekdaysNarrow = e
            }
            return t
        }
        _getContainer() {
            return B.findOne(this._options.container)
        }
        _getNewDaysOrderArray(t) {
            const e = t.startDay
              , i = t.weekdaysNarrow;
            return i.slice(e).concat(i.slice(0, e))
        }
        _init() {
            !this.toggleButton && this._options.toggleButton && this._appendToggleButton(),
            this._listenToUserInput(),
            this._listenToToggleClick(),
            this._listenToToggleKeydown()
        }
        _appendToggleButton() {
            const t = (e = this._toggleButtonId,
            i = this._options.toggleButtonLabel,
            `\n    <button id="${e}" type="button" class="datepicker-toggle-button" data-mdb-toggle="datepicker" aria-label="${i}">\n      <i class="far fa-calendar datepicker-toggle-icon"></i>\n    </button>\n  `);
            var e, i;
            this._element.insertAdjacentHTML("beforeend", t),
            N.addClass(this._input, "form-icon-trailing")
        }
        open() {
            if (this._input.readOnly || this._input.disabled)
                return;
            const t = I.trigger(this._element, wb);
            if (this._isOpen || t.defaultPrevented)
                return;
            this._setInitialDate();
            const e = function() {
                const t = _("div");
                return N.addClass(t, "datepicker-backdrop"),
                t
            }()
              , i = rb(this._activeDate, this._selectedDate, this._selectedYear, this._selectedMonth, this._options, 4, _b, 4, this._toggleButtonId, this._selectedRange);
            this._firstVisibleMonth = this._activeDate,
            this._options.inline ? this._openDropdown(i) : (this._openModal(e, i),
            this._scrollBar.hide()),
            this._animations && (N.addClass(this.container, "animation"),
            N.addClass(this.container, "fade-in"),
            this.container.style.animationDuration = "300ms",
            N.addClass(e, "animation"),
            N.addClass(e, "fade-in"),
            e.style.animationDuration = "150ms"),
            this._setFocusTrap(this.container),
            this._listenToDateSelection(),
            this._addControlsListeners(),
            this._updateControlsDisabledState(),
            this._listenToEscapeClick(),
            this._listenToKeyboardNavigation(),
            this._listenToDatesContainerFocus(),
            this._listenToDatesContainerBlur(),
            this._asyncFocusDatesContainer(),
            this._updateViewControlsAndAttributes(this._view),
            this._isOpen = !0,
            setTimeout( () => {
                this._listenToOutsideClick()
            }
            , 0)
        }
        _openDropdown(t) {
            this._popper = Ln(this._input, t, {
                placement: "bottom-start"
            });
            this._getContainer().appendChild(t)
        }
        _openModal(t, e) {
            const i = this._getContainer();
            i.appendChild(t),
            i.appendChild(e)
        }
        _setFocusTrap(t) {
            this._focusTrap = new Jf(t,{
                event: "keydown",
                condition: t => "Tab" === t.key
            }),
            this._focusTrap.trap()
        }
        _listenToUserInput() {
            I.on(this._input, "input", t => {
                this._handleUserInput(t.target.value)
            }
            )
        }
        _listenToToggleClick() {
            I.on(this._element, Sb, Tb, t => {
                t.preventDefault(),
                this.open()
            }
            )
        }
        _listenToToggleKeydown() {
            I.on(this._element, "keydown", Tb, t => {
                t.keyCode !== ag || this._isOpen || this.open()
            }
            )
        }
        _listenToDateSelection() {
            I.on(this.datesContainer, "click", t => {
                this._handleDateSelection(t)
            }
            )
        }
        _handleDateSelection(t) {
            const e = "DIV" === t.target.nodeName ? t.target.parentNode.dataset : t.target.dataset;
            if (!e)
                return;
            const i = "DIV" === t.target.nodeName ? t.target.parentNode : t.target;
            if (e.mdbDate && this._pickDay(e.mdbDate, i),
            e.mdbMonth && e.mdbYear) {
                const t = parseInt(e.mdbMonth, 10)
                  , i = parseInt(e.mdbYear, 10);
                this._pickMonth(t, i)
            }
            if (e.mdbYear && !e.mdbMonth) {
                const t = parseInt(e.mdbYear, 10);
                this._pickYear(t)
            }
            this._options.inline || (this.options.dateRange ? this._updateHeaderDate(this._selectedRange[0], this._selectedRange) : this._updateHeaderDate(this._activeDate, this._selectedRange))
        }
        _updateHeaderDate(t, e) {
            const i = B.findOne(".datepicker-date-text", this.container)
              , n = B.findOne(".datepicker-header", this.container);
            if (this._options.headerTemplate && n) {
                const e = F_(t)
                  , i = z_(t)
                  , s = j_(t);
                return void (n.innerHTML = lb(e, i, s, t, this._options))
            }
            i.innerHTML = hb(t, e, this._options)
        }
        _addControlsListeners() {
            I.on(this.nextButton, "click", () => {
                "days" === this._view ? this.nextMonth() : "years" === this._view ? this.nextYears() : this.nextYear(),
                this._updateControlsDisabledState()
            }
            ),
            I.on(this.previousButton, "click", () => {
                "days" === this._view ? this.previousMonth() : "years" === this._view ? this.previousYears() : this.previousYear(),
                this._updateControlsDisabledState()
            }
            ),
            I.on(this.viewChangeButton, "click", () => {
                "days" === this._view ? this._changeView("years") : "years" !== this._view && "months" !== this._view || this._changeView("days")
            }
            ),
            this._options.inline || this._listenToFooterButtonsClick()
        }
        _listenToFooterButtonsClick() {
            I.on(this.okButton, "click", () => this.handleOk()),
            I.on(this.cancelButton, "click", () => this.handleCancel()),
            I.on(this.clearButton, "click", () => this.handleClear())
        }
        _listenToOutsideClick() {
            I.on(document, Sb, t => {
                var e;
                const i = t.target === this.container
                  , n = null == (e = this.container) ? void 0 : e.contains(t.target);
                i || n || (this._options.dateRange ? this._interruptDateRangeSelection() : this.close())
            }
            )
        }
        _listenToEscapeClick() {
            I.on(document, "keydown", t => {
                t.keyCode === lg && this._isOpen && (this._options.dateRange ? this._interruptDateRangeSelection() : this.close())
            }
            )
        }
        _interruptDateRangeSelection() {
            if (this._options.inline && this.hasPartialRange)
                return this._handleSingleDayRange(),
                void this.close();
            this.handleCancel()
        }
        _handleSingleDayRange() {
            this._selectedRange.push(this._selectedRange[0]),
            this._confirmSelection(this._selectedRange[0])
        }
        _listenToKeyboardNavigation() {
            I.on(this.datesContainer, "keydown", t => {
                this._handleKeydown(t)
            }
            )
        }
        _listenToDatesContainerFocus() {
            I.on(this.datesContainer, "focus", () => {
                this._focusActiveCell(this.activeCell)
            }
            )
        }
        _listenToDatesContainerBlur() {
            I.on(this.datesContainer, "blur", () => {
                this._removeCurrentFocusStyles()
            }
            )
        }
        _handleKeydown(t) {
            "days" === this._view && this._handleDaysViewKeydown(t),
            "months" === this._view && this._handleMonthsViewKeydown(t),
            "years" === this._view && this._handleYearsViewKeydown(t)
        }
        _handleDaysViewKeydown(t) {
            const e = this._activeDate
              , i = this.activeCell;
            switch (t.keyCode) {
            case tg:
                this._activeDate = U_(this._activeDate, m ? 1 : -1);
                break;
            case ig:
                this._activeDate = U_(this._activeDate, m ? -1 : 1);
                break;
            case eg:
                this._activeDate = U_(this._activeDate, -7);
                break;
            case ng:
                this._activeDate = U_(this._activeDate, 7);
                break;
            case sg:
                this._activeDate = U_(this._activeDate, 1 - F_(this._activeDate));
                break;
            case og:
                this._activeDate = U_(this._activeDate, V_(this._activeDate) - F_(this._activeDate));
                break;
            case 33:
                this._activeDate = K_(this._activeDate, -1);
                break;
            case 34:
                this._activeDate = K_(this._activeDate, 1);
                break;
            case ag:
            case rg:
                return this._selectDate(this._activeDate),
                this._handleDateSelection(t),
                void t.preventDefault();
            default:
                return
            }
            ab(e, this._activeDate, this._view) || this._options.dateRange && ab(K_(this._firstVisibleMonth, 1), this._activeDate, this._view) || this._changeView("days"),
            this._removeHighlightFromCell(i),
            this._focusActiveCell(this.activeCell),
            t.preventDefault()
        }
        _asyncFocusDatesContainer() {
            setTimeout( () => {
                this.datesContainer.focus()
            }
            , 0)
        }
        _focusActiveCell(t) {
            t && N.addClass(t, "focused")
        }
        _removeHighlightFromCell(t) {
            t && t.classList.remove("focused")
        }
        _getActiveDayCell() {
            const t = B.find("td", this.datesContainer);
            return Array.from(t).find(t => eb(Z_(t.dataset.mdbDate), this._activeDate))
        }
        _handleMonthsViewKeydown(t) {
            const e = this._activeDate
              , i = this.activeCell;
            switch (t.keyCode) {
            case tg:
                this._activeDate = K_(this._activeDate, m ? 1 : -1);
                break;
            case ig:
                this._activeDate = K_(this._activeDate, m ? -1 : 1);
                break;
            case eg:
                this._activeDate = K_(this._activeDate, -4);
                break;
            case ng:
                this._activeDate = K_(this._activeDate, 4);
                break;
            case sg:
                this._activeDate = K_(this._activeDate, -this.activeMonth);
                break;
            case og:
                this._activeDate = K_(this._activeDate, 11 - this.activeMonth);
                break;
            case 33:
                this._activeDate = X_(this._activeDate, -1);
                break;
            case 34:
                this._activeDate = X_(this._activeDate, 1);
                break;
            case ag:
            case rg:
                return void this._selectMonth(this.activeMonth);
            default:
                return
            }
            ab(e, this._activeDate, this._view, 0, this._options.min, this._options.max) || this._changeView("months"),
            this._removeHighlightFromCell(i),
            this._focusActiveCell(this.activeCell),
            t.preventDefault()
        }
        _getActiveMonthCell() {
            const t = B.find("td", this.datesContainer);
            return Array.from(t).find(t => {
                const e = parseInt(t.dataset.mdbYear, 10)
                  , i = parseInt(t.dataset.mdbMonth, 10);
                return e === this.activeYear && i === this.activeMonth
            }
            )
        }
        _handleYearsViewKeydown(t) {
            const e = this._activeDate
              , i = this.activeCell;
            switch (t.keyCode) {
            case tg:
                this._activeDate = X_(this._activeDate, m ? 1 : -1);
                break;
            case ig:
                this._activeDate = X_(this._activeDate, m ? -1 : 1);
                break;
            case eg:
                this._activeDate = X_(this._activeDate, -4);
                break;
            case ng:
                this._activeDate = X_(this._activeDate, 4);
                break;
            case sg:
                this._activeDate = X_(this._activeDate, -ib(this._activeDate, 24));
                break;
            case og:
                this._activeDate = X_(this._activeDate, 24 - ib(this._activeDate, 24) - 1);
                break;
            case 33:
                this._activeDate = X_(this._activeDate, -24);
                break;
            case 34:
                this._activeDate = X_(this._activeDate, 24);
                break;
            case ag:
            case rg:
                return void this._selectYear(this.activeYear);
            default:
                return
            }
            ab(e, this._activeDate, this._view, 0, this._options.min, this._options.max) || this._changeView("years"),
            this._removeHighlightFromCell(i),
            this._focusActiveCell(this.activeCell),
            t.preventDefault()
        }
        _getActiveYearCell() {
            const t = B.find("td", this.datesContainer);
            return Array.from(t).find(t => parseInt(t.dataset.mdbYear, 10) === this.activeYear)
        }
        _setInitialDate() {
            this._input.value ? this._handleUserInput(this._input.value) : this._options.startDate ? this._activeDate = new Date(this._options.startDate) : this._activeDate = new Date
        }
        close() {
            const t = I.trigger(this._element, xb);
            this._isOpen && !t.defaultPrevented && (this._removeDatepickerListeners(),
            this._animations && (N.addClass(this.container, "animation"),
            N.addClass(this.container, "fade-out")),
            this._options.inline ? this._closeDropdown() : this._closeModal(),
            this._isOpen = !1,
            this._view = this._options.view,
            this.toggleButton ? this.toggleButton.focus() : this._input.focus())
        }
        _closeDropdown() {
            const t = B.findOne(".datepicker-dropdown-container")
              , e = this._getContainer();
            this._animations ? t.addEventListener("animationend", () => {
                t && e.removeChild(t),
                this._popper && this._popper.destroy()
            }
            ) : (t && e.removeChild(t),
            this._popper && this._popper.destroy()),
            this._removeFocusTrap()
        }
        _closeModal() {
            const t = B.findOne(".datepicker-backdrop")
              , e = B.findOne(".datepicker-modal-container");
            e && t && (this._animations && (N.addClass(t, "animation"),
            N.addClass(t, "fade-out")),
            this._animations ? t.addEventListener("animationend", () => {
                this._removePicker(t, e),
                this._scrollBar.reset()
            }
            ) : (this._removePicker(t, e),
            this._scrollBar.reset()))
        }
        _removePicker(t, e) {
            const i = this._getContainer();
            i.removeChild(t),
            i.removeChild(e)
        }
        _removeFocusTrap() {
            this._focusTrap && (this._focusTrap.disable(),
            this._focusTrap = null)
        }
        _removeDatepickerListeners() {
            I.off(this.nextButton, "click"),
            I.off(this.previousButton, "click"),
            I.off(this.viewChangeButton, "click"),
            I.off(this.okButton, "click"),
            I.off(this.cancelButton, "click"),
            I.off(this.clearButton, "click"),
            I.off(this.datesContainer, "click"),
            I.off(this.datesContainer, "keydown"),
            I.off(this.datesContainer, "focus"),
            I.off(this.datesContainer, "blur"),
            I.off(document, Sb)
        }
        dispose() {
            this._isOpen && this.close(),
            this._removeInputAndToggleListeners();
            const t = B.findOne(`#${this._toggleButtonId}`);
            t && this._element.removeChild(t),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _removeInputAndToggleListeners() {
            I.off(this._input, "input"),
            I.off(this._element, Sb, Tb),
            I.off(this._element, "keydown", Tb)
        }
        handleOk() {
            this.hasPartialRange ? this._handleSingleDayRange() : this.isRangeComplete ? this._confirmSelection(this._selectedRange[0]) : this._confirmSelection(this._headerDate),
            this.close()
        }
        _selectDate(t, e=this.activeCell) {
            const {min: i, max: n, filter: s, disablePast: o, disableFuture: a, inline: r, confirmDateOnSelect: l, dateRange: h} = this._options;
            nb(t, i, n, s, o, a) || (this._removeCurrentFocusStyles(),
            h ? this._handleDateRangeSelection(t, e) : this._handleSingleDateSelection(t, e),
            (r || l) && (this._confirmSelection(t),
            this.isSelectionCompleted && this.close()))
        }
        _handleSingleDateSelection(t, e) {
            this._removeCurrentStyle("selected"),
            this._selectedDate = t,
            this._selectedYear = W_(t),
            this._selectedMonth = j_(t),
            this._addSelectedStyles(e),
            this._headerDate = t
        }
        _handleDateRangeSelection(t, e) {
            this.isRangeComplete ? (this._resetDateRangeStyles(),
            this._selectedRange = [],
            this._selectedRange.push(t)) : this.hasPartialRange ? (this._selectedRange.push(t),
            this._selectedRange.sort(tb),
            this._addDateRangeStyles()) : 0 === this._selectedRange.length && (this._selectedRange.push(t),
            this._headerDate = [t]),
            this._addSelectedStyles(e)
        }
        _resetDateRangeStyles() {
            ["selected", "in-range", "first-in-range", "last-in-range"].forEach(t => this._removeCurrentStyle(t))
        }
        _selectYear(t, e=this.activeCell) {
            this._removeCurrentStyle("selected"),
            this._removeCurrentFocusStyles(),
            this._addSelectedStyles(e),
            this._headerYear = t,
            this._asyncChangeView("months")
        }
        _selectMonth(t, e=this.activeCell) {
            this._removeCurrentStyle("selected"),
            this._removeCurrentFocusStyles(),
            this._addSelectedStyles(e),
            this._headerMonth = t,
            this._asyncChangeView("days")
        }
        _removeSelectedStyles(t) {
            t && t.classList.remove("selected")
        }
        _addSelectedStyles(t) {
            t && N.addClass(t, "selected")
        }
        _addDateRangeStyles() {
            const t = this._selectedRange[0]
              , e = this._selectedRange[1];
            eb(t, e) || this.visibleDates.forEach(i => {
                const n = Z_(i.dataset.mdbDate);
                eb(n, t) && N.addClass(i, "first-in-range"),
                eb(n, e) && N.addClass(i, "last-in-range"),
                Q_(n, [t, e]) && N.addClass(i, "in-range")
            }
            )
        }
        _confirmSelection(t) {
            if (t) {
                let e;
                this._options.dateRange ? this.hasPartialRange ? e = `${this.formatDate(this._selectedRange[0])} - ` : this.isRangeComplete && (e = `${this.formatDate(this._selectedRange[0])} - ${this.formatDate(this._selectedRange[1])}`) : e = this.formatDate(t),
                this._input.value = e,
                N.addClass(this._input, "active"),
                this.isSelectionCompleted && I.trigger(this._element, Cb, {
                    date: this._options.dateRange ? this._selectedRange : t
                })
            }
        }
        handleCancel() {
            this._selectedRange = [],
            this._selectedDate = null,
            this._selectedYear = null,
            this._selectedMonth = null,
            this.close()
        }
        handleClear() {
            this._selectedRange = [],
            this._selectedDate = null,
            this._selectedMonth = null,
            this._selectedYear = null,
            this._headerDate = null,
            this._headerMonth = null,
            this._headerYear = null,
            this._removeCurrentStyle("selected"),
            this.options.dateRange && this._resetDateRangeStyles(),
            this._input.value = "",
            this._input.classList.remove("active"),
            this._setInitialDate(),
            this._changeView("days"),
            this._updateHeaderDate(this._activeDate, this._selectedRange)
        }
        _removeCurrentStyle(t) {
            const e = B.find(`.${t}`, this.container);
            e && e.forEach(e => {
                e.classList.remove(`${t}`)
            }
            )
        }
        _removeCurrentFocusStyles() {
            const t = B.findOne(".focused", this.container);
            t && t.classList.remove("focused")
        }
        formatDate(t) {
            const e = F_(t)
              , i = this._addLeadingZero(F_(t))
              , n = this._options.weekdaysShort[z_(t)]
              , s = this._options.weekdaysFull[z_(t)]
              , o = j_(t) + 1
              , a = this._addLeadingZero(j_(t) + 1)
              , r = this._options.monthsShort[j_(t)]
              , l = this._options.monthsFull[j_(t)]
              , h = 2 === W_(t).toString().length ? W_(t) : W_(t).toString().slice(2, 4)
              , c = W_(t)
              , d = this._options.format.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);
            let u = "";
            return d.forEach(t => {
                switch (t) {
                case "dddd":
                    t = t.replace(t, s);
                    break;
                case "ddd":
                    t = t.replace(t, n);
                    break;
                case "dd":
                    t = t.replace(t, i);
                    break;
                case "d":
                    t = t.replace(t, e);
                    break;
                case "mmmm":
                    t = t.replace(t, l);
                    break;
                case "mmm":
                    t = t.replace(t, r);
                    break;
                case "mm":
                    t = t.replace(t, a);
                    break;
                case "m":
                    t = t.replace(t, o);
                    break;
                case "yyyy":
                    t = t.replace(t, c);
                    break;
                case "yy":
                    t = t.replace(t, h)
                }
                u += t
            }
            ),
            u
        }
        _addLeadingZero(t) {
            return parseInt(t, 10) < 10 ? `0${t}` : t
        }
        _pickDay(t, e) {
            const i = Z_(t)
              , {min: n, max: s, filter: o, disablePast: a, disableFuture: r} = this._options;
            nb(i, n, s, o, a, r) || (this._activeDate = i,
            this._selectDate(i, e))
        }
        _pickYear(t) {
            const {min: e, max: i, disablePast: n, disableFuture: s} = this._options;
            if (ob(t, e, i, n, s))
                return;
            const o = q_(t, this.activeMonth, this.activeDay);
            this._activeDate = o,
            this._selectedDate = o,
            this._selectYear(t)
        }
        _pickMonth(t, e) {
            const {min: i, max: n, disablePast: s, disableFuture: o} = this._options;
            if (sb(t, e, i, n, s, o) || ob(e, i, n, s, o))
                return;
            const a = q_(e, t, this.activeDay);
            this._activeDate = a,
            this._selectMonth(t)
        }
        nextMonth() {
            const t = this.options.dateRange ? K_(this._firstVisibleMonth, 1) : K_(this._activeDate, 1);
            this._activeDate = t,
            this._firstVisibleMonth = t;
            const e = pb(t, this.options.dateRange ? this._selectedRange : this._headerDate, this._options, this._selectedRange);
            this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`,
            this.datesContainer.innerHTML = e
        }
        previousMonth() {
            const t = this.options.dateRange ? K_(this._firstVisibleMonth, -1) : K_(this._activeDate, -1);
            this._activeDate = t,
            this._firstVisibleMonth = t;
            const e = pb(t, this.options.dateRange ? this._selectedRange : this._headerDate, this._options, this._selectedRange);
            this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`,
            this.datesContainer.innerHTML = e
        }
        nextYear() {
            const t = X_(this._activeDate, 1);
            this._activeDate = t,
            this.viewChangeButton.textContent = `${this.activeYear}`;
            const e = gb(this.activeYear, this._selectedYear, this._selectedMonth, this._options, 4);
            this.datesContainer.innerHTML = e
        }
        previousYear() {
            const t = X_(this._activeDate, -1);
            this._activeDate = t,
            this.viewChangeButton.textContent = `${this.activeYear}`;
            const e = gb(this.activeYear, this._selectedYear, this._selectedMonth, this._options, 4);
            this.datesContainer.innerHTML = e
        }
        nextYears() {
            const t = X_(this._activeDate, 24);
            this._activeDate = t;
            const e = mb(t, this._selectedYear, this._options, _b, 4);
            this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`,
            this.datesContainer.innerHTML = e
        }
        previousYears() {
            const t = X_(this._activeDate, -24);
            this._activeDate = t;
            const e = mb(t, this._selectedYear, this._options, _b, 4);
            this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`,
            this.datesContainer.innerHTML = e
        }
        _asyncChangeView(t) {
            setTimeout( () => {
                this._changeView(t)
            }
            , 0)
        }
        _changeView(t) {
            this._view = t,
            this.datesContainer.blur();
            const e = this.options.dateRange ? this._selectedRange : this._headerDate;
            "days" === t && (this.datesContainer.innerHTML = pb(this._activeDate, e, this._options, this._selectedRange)),
            "months" === t && (this.datesContainer.innerHTML = gb(this.activeYear, this._selectedYear, this._selectedMonth, this._options, 4)),
            "years" === t && (this.datesContainer.innerHTML = mb(this._activeDate, this._selectedYear, this._options, _b, 4)),
            this._firstVisibleMonth = this._activeDate,
            this.datesContainer.focus(),
            this._updateViewControlsAndAttributes(t),
            this._updateControlsDisabledState(),
            I.trigger(this._element, kb, {
                view: this._view
            })
        }
        _updateViewControlsAndAttributes(t) {
            "days" === t && (this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`,
            this.viewChangeButton.setAttribute("aria-label", this._options.switchToMultiYearViewLabel),
            this.previousButton.setAttribute("aria-label", this._options.prevMonthLabel),
            this.nextButton.setAttribute("aria-label", this._options.nextMonthLabel)),
            "months" === t && (this.viewChangeButton.textContent = `${this.activeYear}`,
            this.viewChangeButton.setAttribute("aria-label", this._options.switchToDayViewLabel),
            this.previousButton.setAttribute("aria-label", this._options.prevYearLabel),
            this.nextButton.setAttribute("aria-label", this._options.nextYearLabel)),
            "years" === t && (this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`,
            this.viewChangeButton.setAttribute("aria-label", this._options.switchToDayViewLabel),
            this.previousButton.setAttribute("aria-label", this._options.prevMultiYearLabel),
            this.nextButton.setAttribute("aria-label", this._options.nextMultiYearLabel))
        }
        _updateControlsDisabledState() {
            !function(t, e, i, n, s, o, a, r) {
                const l = new Date;
                return l.setHours(0, 0, 0, 0),
                (t && o && tb(o, l) < 0 || t) && (o = l),
                o && ab(e, o, i, 0, 0, 0, a, r)
            }(this._options.disableFuture, this._activeDate, this._view, 0, this._options.min, this._options.max, this.lastYearInView, this.firstYearInView) ? this.nextButton.disabled = !1 : this.nextButton.disabled = !0,
            !function(t, e, i, n, s, o, a, r) {
                const l = new Date;
                return l.setHours(0, 0, 0, 0),
                (t && s && tb(s, l) < 0 || t) && (s = l),
                s && ab(e, s, i, 0, 0, 0, a, r)
            }(this._options.disablePast, this._activeDate, this._view, 0, this._options.min, this._options.max, this.lastYearInView, this.firstYearInView) ? this.previousButton.disabled = !1 : this.previousButton.disabled = !0
        }
        _handleUserInput(t) {
            const e = this._getDelimeters(this._options.format);
            let i, n, s, o;
            this.options.dateRange && (n = t.split(" - "),
            n = n.map(t => this._parseDate(t, this._options.format, e)),
            s = G_(n[0]),
            o = (null == n ? void 0 : n.length) > 1 && G_(n[1]),
            s && 1 === n.length && (n.push(n[0]),
            o = !0),
            s && o && (i = tb(n[0], n[1]) <= 0));
            const a = this._parseDate(t, this._options.format, e);
            G_(a) && !this.options.dateRange ? this._setDate(a) : s && o && i ? this._setDate(n) : (this._activeDate = this._options.startDate ? new Date(this._options.startDate) : new Date,
            this._selectedRange = [],
            this._selectedDate = null,
            this._selectedMonth = null,
            this._selectedYear = null,
            this._headerDate = null,
            this._headerMonth = null,
            this._headerYear = null)
        }
        _setDate(t) {
            if (this.options.dateRange) {
                const [e,i] = t;
                this._activeDate = e,
                this._selectedDate = [e, i],
                this._selectedYear = [W_(e), W_(i)],
                this._selectedMonth = [j_(e), j_(i)],
                this._selectedRange = [e, i]
            } else
                this._activeDate = t,
                this._selectedDate = t,
                this._selectedYear = W_(t),
                this._selectedMonth = j_(t),
                this._headerDate = t
        }
        _getDelimeters(t) {
            return t.match(/[^(dmy)]{1,}/g)
        }
        _parseDate(t, e, i) {
            let n;
            n = i[0] !== i[1] ? i[0] + i[1] : i[0];
            const s = new RegExp(`[${n}]`)
              , o = t.split(s)
              , a = e.split(s)
              , r = -1 !== e.indexOf("mmm")
              , l = [];
            for (let d = 0; d < a.length; d++)
                -1 !== a[d].indexOf("yy") && (l[0] = {
                    value: o[d],
                    format: a[d]
                }),
                -1 !== a[d].indexOf("m") && (l[1] = {
                    value: o[d],
                    format: a[d]
                }),
                -1 !== a[d].indexOf("d") && a[d].length <= 2 && (l[2] = {
                    value: o[d],
                    format: a[d]
                });
            let h;
            h = -1 !== e.indexOf("mmmm") ? this._options.monthsFull : this._options.monthsShort;
            let c = Number(l[0].value);
            !function(t) {
                return null == t ? void 0 : t.toLowerCase().includes("yyyy")
            }(l[0].value) && c < 100 && (c += c >= 50 ? 1900 : 2e3);
            return q_(c, r ? this.getMonthNumberByMonthName(l[1].value, h) : Number(l[1].value) - 1, Number(l[2].value))
        }
        getMonthNumberByMonthName(t, e) {
            return e.findIndex(e => e === t)
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                let i = s.getData(this, vb);
                const n = "object" == typeof t && t;
                if ((i || !/dispose/.test(t)) && (i || (i = new Mb(this,n)),
                "string" == typeof t)) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
    }
    const Ob = "popconfirm"
      , Db = "mdb.popconfirm"
      , $b = `.${Db}`
      , Ib = `cancel${$b}`
      , Lb = `confirm${$b}`
      , Pb = {
        popconfirmMode: "string",
        message: "string",
        cancelText: "string",
        okText: "string",
        okClass: "string",
        cancelClass: "string",
        popconfirmIcon: "string",
        cancelLabel: "string",
        confirmLabel: "string",
        position: "string"
    }
      , Rb = {
        popconfirmMode: "inline",
        message: "Are you sure?",
        cancelText: "Cancel",
        okText: "OK",
        okClass: "btn-primary",
        cancelClass: "btn-secondary",
        popconfirmIcon: "",
        cancelLabel: "Cancel",
        confirmLabel: "Confirm",
        position: "bottom"
    };
    class Nb extends ao {
        constructor(t, e) {
            super(t),
            this._options = this._getConfig(e),
            this._cancelButtonTemplate = this._getCancelButtonTemplate(),
            this._popper = null,
            this._cancelButton = "",
            this._confirmButton = "",
            this._isOpen = !1,
            this._uid = this._element.id ? `popconfirm-${this._element.id}` : o("popconfirm-"),
            this._focusTrap = null,
            this._scrollBar = new ce,
            this._clickHandler = this.open.bind(this),
            this._escapeKeydownHandler = this._handleEscapeKey.bind(this),
            this._outsideClickHandler = this._handleOutsideClick.bind(this),
            I.on(this._element, "click", this._clickHandler),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return Ob
        }
        get container() {
            return B.findOne(`#${this._uid}`)
        }
        get popconfirmBody() {
            return B.findOne(".popconfirm", this.container)
        }
        dispose() {
            (this._isOpen || null !== this.container) && this.close(),
            I.off(this._element, "click", this._clickHandler),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);
            const t = this._isOpen && "inline" === this._options.popconfirmMode ? 155 : 0;
            setTimeout( () => {
                super.dispose()
            }
            , t)
        }
        open() {
            this._isOpen || ("inline" === this._options.popconfirmMode ? this._openPopover(this._getPopoverTemplate()) : (this._openModal(this._getModalTemplate()),
            this._scrollBar.hide()),
            this._handleCancelButtonClick(),
            this._handleConfirmButtonClick(),
            this._listenToEscapeKey(),
            this._listenToOutsideClick())
        }
        close() {
            if (this._isOpen) {
                if (null !== this._popper || null !== B.findOne(".popconfirm-popover"))
                    I.on(this.popconfirmBody, "transitionend", this._handlePopconfirmTransitionEnd.bind(this)),
                    N.removeClass(this.popconfirmBody, "show");
                else {
                    const t = B.findOne(".popconfirm-backdrop");
                    N.removeClass(this.popconfirmBody, "show"),
                    document.body.removeChild(t),
                    this._isOpen = !1
                }
                this._removeFocusTrap(),
                this._scrollBar.reset(),
                this._element.focus(),
                I.off(document, "click", this._outsideClickHandler),
                I.off(document, "keydown", this._escapeKeydownHandler)
            }
        }
        _setFocusTrap(t) {
            this._focusTrap = new Jf(t,{
                event: "keydown",
                condition: t => "Tab" === t.key
            }),
            this._focusTrap.trap();
            const e = B.findOne("#popconfirm-button-cancel", t)
              , i = B.findOne("#popconfirm-button-confirm", t);
            e ? e.focus() : i.focus()
        }
        _removeFocusTrap() {
            this._focusTrap && (this._focusTrap.disable(),
            this._focusTrap = null)
        }
        _handlePopconfirmTransitionEnd(t) {
            if (t.target !== this.popconfirmBody)
                return;
            const e = B.findOne(".popconfirm-popover");
            I.off(this.popconfirmBody, "transitionend"),
            this._isOpen && t && "opacity" === t.propertyName && (this._popper.destroy(),
            e && document.body.removeChild(e),
            this._isOpen = !1)
        }
        _getPopoverTemplate() {
            const t = _("div")
              , e = this._getPopconfirmTemplate();
            return N.addClass(t, "popconfirm-popover"),
            N.addClass(t, "shadow-2"),
            t.id = this._uid,
            t.innerHTML = e,
            t
        }
        _getModalTemplate() {
            const t = _("div")
              , e = this._getPopconfirmTemplate();
            return N.addClass(t, "popconfirm-modal"),
            N.addClass(t, "shadow-2"),
            t.id = this._uid,
            t.innerHTML = e,
            t
        }
        _getPopconfirmTemplate() {
            return `<div class="popconfirm">\n      <p class="popconfirm-message">\n      ${this._getMessageIcon()}\n      <span class="popconfirm-message-text">${this._options.message}</span>\n      </p>\n      <div class="popconfirm-buttons-container">\n      ${this._cancelButtonTemplate}\n      <button type="button" id="popconfirm-button-confirm" data-mdb-ripple-init\n      aria-label="${this._options.confirmLabel}"\n      class="btn ${this._options.okClass} btn-sm">${this._options.okText}</button>\n      </div>\n    </div>`
        }
        _getConfig(t) {
            return t = {
                ...Rb,
                ...N.getDataAttributes(this._element),
                ...t
            },
            d(Ob, t, Pb),
            t
        }
        _getCancelButtonTemplate() {
            return "" === this._options.cancelText || " " === this._options.cancelText ? "" : `<button type="button" id="popconfirm-button-cancel" aria-label="${this._options.cancelLabel}"\n    class="btn ${this._options.cancelClass} btn-sm" data-mdb-ripple-init >${this._options.cancelText}</button>`
        }
        _getMessageIcon() {
            return "" === this._options.popconfirmIcon ? "" : `<span class="popconfirm-icon-container"><i class="${this._options.popconfirmIcon}"></i></span>`
        }
        _openPopover(t) {
            this._popper = Ln(this._element, t, {
                placement: this._translatePositionValue(),
                modifiers: [{
                    name: "offset",
                    options: {
                        offset: [0, 5]
                    }
                }]
            }),
            document.body.appendChild(t),
            setTimeout( () => {
                N.addClass(this.popconfirmBody, "fade"),
                N.addClass(this.popconfirmBody, "show"),
                this._isOpen = !0,
                this._setFocusTrap(this.container)
            }
            , 0)
        }
        _openModal(t) {
            const e = _("div");
            N.addClass(e, "popconfirm-backdrop"),
            document.body.appendChild(e),
            e.appendChild(t),
            N.addClass(this.popconfirmBody, "show"),
            this._isOpen = !0,
            this._setFocusTrap(this.container)
        }
        _handleCancelButtonClick() {
            const t = this.container;
            this._cancelButton = B.findOne("#popconfirm-button-cancel", t),
            null !== this._cancelButton && I.on(this._cancelButton, "click", () => {
                this.close(),
                I.trigger(this._element, Ib)
            }
            )
        }
        _handleConfirmButtonClick() {
            const t = this.container;
            this._confirmButton = B.findOne("#popconfirm-button-confirm", t),
            I.on(this._confirmButton, "click", () => {
                this.close(),
                I.trigger(this._element, Lb)
            }
            )
        }
        _listenToEscapeKey() {
            I.on(document, "keydown", this._escapeKeydownHandler)
        }
        _handleEscapeKey(t) {
            t.keyCode === lg && (this._isOpen && I.trigger(this._element, Ib),
            this.close())
        }
        _listenToOutsideClick() {
            I.on(document, "click", this._outsideClickHandler)
        }
        _handleOutsideClick(t) {
            const e = this.container
              , i = t.target === e
              , n = e && e.contains(t.target)
              , s = t.target === this._element
              , o = this._element && this._element.contains(t.target);
            i || n || s || o || (this._isOpen && I.trigger(this._element, Ib),
            this.close())
        }
        _translatePositionValue() {
            switch (this._options.position) {
            case "top left":
                return m ? "top-start" : "top-end";
            case "top":
                return "top";
            case "top right":
                return m ? "top-end" : "top-start";
            case "bottom left":
                return m ? "bottom-start" : "bottom-end";
            case "bottom":
                return "bottom";
            case "bottom right":
                return m ? "bottom-end" : "bottom-start";
            case "left":
                return m ? "right" : "left";
            case "left top":
                return m ? "right-end" : "left-end";
            case "left bottom":
                return m ? "right-start" : "left-start";
            case "right":
                return m ? "left" : "right";
            case "right top":
                return m ? "left-end" : "right-end";
            case "right bottom":
                return m ? "left-start" : "right-start";
            case void 0:
                return "bottom";
            default:
                return this._options.position
            }
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                const i = s.getData(this, Db)
                  , n = "object" == typeof t && t;
                if (i || !/dispose/.test(t)) {
                    if (!i)
                        return new Nb(this,n);
                    if ("string" == typeof t) {
                        if (void 0 === i[t])
                            throw new TypeError(`No method named "${t}"`);
                        i[t](e)
                    }
                }
            })
        }
    }
    const Bb = ({columns: t, rows: e, noFoundMessage: i, edit: n, multi: s, selectable: o, loading: a, loadingMessage: r, loaderClass: l, columnSearch: h}) => {
        const c = ( ({rows: t, columns: e, noFoundMessage: i, edit: n, selectable: s, loading: o}) => {
            const a = t.map(t => {
                const i = `\n    <td data-mdb-field="checkbox">\n      <div class="form-check">\n        <input data-mdb-row-index="${t.rowIndex}" class="datatable-row-checkbox form-check-input" type="checkbox">\n      </div>\n    </td>\n    `
                  , o = e.map( (i, s) => {
                    const o = {};
                    if (i.width && (o["min-width"] = i.width - 1 + "px",
                    o["max-width"] = `${i.width}px`,
                    o.width = `${i.width}px`),
                    i.fixed) {
                        const t = e.filter( (t, e) => t.fixed === i.fixed && e < s).reduce( (t, e) => t + e.width, 0);
                        o["right" === i.fixed ? "right" : "left"] = `${t}px`
                    }
                    return `<td style="${Object.keys(o).map(t => `${t}: ${o[t]}`).join("; ")}" class="${i.fixed ? "fixed-cell" : ""}" data-mdb-field="${i.field}" ${n && 'contenteditable="true"'}>${t[i.field]}</td>`
                }
                ).join("");
                return `<tr scope="row" data-mdb-index="${t.rowIndex}">${s ? i : ""}${o}</tr>`
            }
            );
            return t.length > 0 || o ? a.join("\n") : `<tr><td>${i}</td></tr>`
        }
        )({
            rows: e,
            columns: t,
            noFoundMessage: i,
            edit: n,
            loading: a,
            selectable: o
        })
          , d = ( (t, e, i, n) => [e ? i ? '\n<th scope="col">\n  <div class="form-check d-flex align-items-center mb-0">\n    <input class="datatable-header-checkbox form-check-input" type="checkbox">\n  </div>\n</th>\n' : '<th scope="col"></th>' : "", ...t.map( (e, i) => {
            const s = e.fixed ? t.filter( (t, n) => t.fixed === e.fixed && n < i).reduce( (t, e) => t + e.width, 0) : null;
            return `<th style="${e.fixed ? `${"right" === e.fixed ? "right" : "left"}: ${s}px;` : ""}" ${e.fixed ? 'class="fixed-cell"' : ""} scope="col">\n    <div>${e.sort ? `<i data-mdb-sort="${e.field}" class="datatable-sort-icon fas fa-arrow-up"></i>` : ""}\n    ${e.label} </div>\n    ${n ? `<div class="datatable-header-filter"><input type="text" data-mdb-field="${e.field}" class="datatable-header-filter-input" /></div>` : ""}\n    </th>`
        }
        )].join("\n"))(t, o, s, h);
        return {
            table: `\n<div class="datatable-inner table-responsive">\n  <table class="table datatable-table">\n    <thead class="datatable-header">\n      <tr>\n        ${d}\n      </tr>\n    </thead>\n    <tbody class="datatable-body">\n      ${a ? "" : c}\n    </tbody>\n  </table>\n</div>\n  ${a ? `\n  <div class="datatable-loader">\n    <span class="datatable-loader-inner"><span class="datatable-progress ${l}"></span></span>\n  </div>\n  <p class="text-center text-muted my-4">${r}</p>\n` : ""}\n  `,
            rows: c,
            column: d
        }
    }
      , Hb = t => `\n    <div class="datatable-pagination-buttons">\n      ${t ? '<button data-mdb-ripple-color="dark" data-mdb-ripple-init class="btn btn-link datatable-pagination-button datatable-pagination-start"><i class="fa fa-angle-double-left"></i></button>' : ""}\n      <button data-mdb-ripple-color="dark" data-mdb-ripple-init class="btn btn-link datatable-pagination-button datatable-pagination-left"><i class="fa fa-chevron-${m ? "right" : "left"}"></i></button>\n      <button data-mdb-ripple-color="dark" data-mdb-ripple-init class="btn btn-link datatable-pagination-button datatable-pagination-right"><i class="fa fa-chevron-${m ? "left" : "right"}"></i></button>\n      ${t ? '<button data-mdb-ripple-color="dark" data-mdb-ripple-init class="btn btn-link datatable-pagination-button datatable-pagination-end"><i class="fa fa-angle-double-right"></i></button>' : ""}\n    </div>\n  `
      , Fb = (t, e, i, n, s) => `\n    <div class="datatable-select-wrapper">\n      <p class="datatable-select-text">${n}</p>\n      <select name="entries" ${i ? 'data-mdb-disabled="true"' : ""} class="datatable-select select">\n        ${e.map(e => "all" === ("string" == typeof e ? e.toLowerCase() : e) ? `<option value="${e}" ${e === t ? "selected" : ""}>${s}</option>` : `<option value="${e}">${e}</option>`).join("\n")}\n      </select>\n    </div>\n  `
      , zb = ".form-check-input"
      , jb = "selected"
      , Wb = "active";
    class Vb {
        constructor(t, e, i, n, s, o, a, r, l, h, c) {
            this.id = t,
            this.nativeOption = e,
            this.multiple = i,
            this.value = n,
            this.label = s,
            this.selected = o,
            this.disabled = a,
            this.hidden = r,
            this.secondaryText = l,
            this.groupId = h,
            this.icon = c,
            this.node = null,
            this.active = !1
        }
        select() {
            this.multiple ? this._selectMultiple() : this._selectSingle()
        }
        _selectSingle() {
            this.selected || (N.addClass(this.node, jb),
            this.node.setAttribute("aria-selected", !0),
            this.selected = !0,
            this.nativeOption && (this.nativeOption.selected = !0))
        }
        _selectMultiple() {
            if (!this.selected) {
                const t = B.findOne(zb, this.node);
                t && (t.checked = !0),
                N.addClass(this.node, jb),
                this.node.setAttribute("aria-selected", !0),
                this.selected = !0,
                this.nativeOption && (this.nativeOption.selected = !0)
            }
        }
        deselect() {
            this.multiple ? this._deselectMultiple() : this._deselectSingle()
        }
        _deselectSingle() {
            this.selected && (N.removeClass(this.node, jb),
            this.node.setAttribute("aria-selected", !1),
            this.selected = !1,
            this.nativeOption && (this.nativeOption.selected = !1))
        }
        _deselectMultiple() {
            if (this.selected) {
                const t = B.findOne(zb, this.node);
                t && (t.checked = !1),
                N.removeClass(this.node, jb),
                this.node.setAttribute("aria-selected", !1),
                this.selected = !1,
                this.nativeOption && (this.nativeOption.selected = !1)
            }
        }
        setNode(t) {
            this.node = t
        }
        setActiveStyles() {
            this.active || (this.active = !0,
            N.addClass(this.node, Wb))
        }
        removeActiveStyles() {
            this.active && (this.active = !1,
            N.removeClass(this.node, Wb))
        }
    }
    class Yb {
        constructor(t=!1) {
            this._multiple = t,
            this._selections = []
        }
        select(t) {
            this._multiple ? this._selections.push(t) : this._selections = [t]
        }
        deselect(t) {
            if (this._multiple) {
                const e = this._selections.findIndex(e => t === e);
                this._selections.splice(e, 1)
            } else
                this._selections = []
        }
        clear() {
            this._selections = []
        }
        get selection() {
            return this._selections[0]
        }
        get selections() {
            return this._selections
        }
        get label() {
            return this._selections[0] && this.selection.label
        }
        get labels() {
            return this._selections.map(t => t.label).join(", ")
        }
        get value() {
            return this.selections[0] && this.selection.value
        }
        get values() {
            return this._selections.map(t => t.value)
        }
    }
    function Xb(t) {
        return t.filter(t => !t.disabled).every(t => t.selected)
    }
    const Kb = t => {
        "Tab" !== t.code && "Esc" !== t.code && t.preventDefault()
    }
    ;
    function Ub(t, e, i, n, s, o, a) {
        const r = document.createElement("div");
        r.classList.add("select-dropdown-container"),
        r.setAttribute("id", `${t}`),
        r.style.width = `${i}px`;
        const l = document.createElement("div");
        l.setAttribute("tabindex", 0),
        l.classList.add("select-dropdown");
        const h = _("div");
        N.addClass(h, "select-options-wrapper"),
        h.style.maxHeight = `${n}px`;
        const c = qb(o, s, e);
        return h.appendChild(c),
        e.filter && l.appendChild(function(t) {
            const e = _("div");
            N.addClass(e, "input-group");
            const i = _("input");
            return N.addClass(i, "form-control"),
            N.addClass(i, "select-filter-input"),
            i.placeholder = t,
            i.setAttribute("role", "searchbox"),
            i.setAttribute("type", "text"),
            e.appendChild(i),
            e
        }(e.searchPlaceholder)),
        l.appendChild(h),
        a && l.appendChild(a),
        r.appendChild(l),
        r
    }
    function qb(t, e, i, n) {
        const s = _("div");
        N.addClass(s, "select-options-list"),
        (null == n ? void 0 : n.id) && s.setAttribute("aria-labelledby", n.id);
        const o = i.multiple ? "true" : "false"
          , a = i.filter ? "combobox" : "listbox";
        let r;
        return s.setAttribute("role", a),
        s.setAttribute("aria-multiselectable", o),
        r = i.multiple ? function(t, e, i) {
            let n = null;
            i.selectAll && (n = function(t, e, i) {
                const n = Xb(e)
                  , s = _("div");
                N.addClass(s, "select-option"),
                N.addClass(s, "select-all-option"),
                N.addStyle(s, {
                    height: `${i.optionHeight}px`
                }),
                s.setAttribute("role", "option"),
                s.setAttribute("aria-selected", n),
                n && N.addClass(s, "selected");
                return s.appendChild(Qb(t, i)),
                t.setNode(s),
                s
            }(e, t, i));
            const s = Zb(t, i)
              , o = n ? [n, ...s] : s;
            return o
        }(t, e, i) : function(t, e) {
            const i = Zb(t, e);
            return i
        }(t, i),
        r.forEach(t => {
            s.appendChild(t)
        }
        ),
        s
    }
    function Zb(t, e) {
        const i = [];
        return t.forEach(t => {
            if (t.hasOwnProperty("options")) {
                const n = function(t, e) {
                    const i = _("div");
                    N.addClass(i, "select-option-group"),
                    i.setAttribute("role", "group"),
                    i.setAttribute("id", t.id),
                    t.hidden && N.addClass(i, "d-none");
                    const n = _("label");
                    return N.addClass(n, "select-option-group-label"),
                    N.addStyle(n, {
                        height: `${e.optionHeight}px`
                    }),
                    n.setAttribute("for", t.id),
                    n.textContent = t.label,
                    i.appendChild(n),
                    t.options.forEach(t => {
                        i.appendChild(Gb(t, e))
                    }
                    ),
                    i
                }(t, e);
                i.push(n)
            } else
                i.push(Gb(t, e))
        }
        ),
        i
    }
    function Gb(t, e) {
        if (t.node)
            return t.node;
        const i = _("div");
        return N.addClass(i, "select-option"),
        N.addStyle(i, {
            height: `${e.optionHeight}px`
        }),
        N.setDataAttribute(i, "id", t.id),
        i.setAttribute("role", "option"),
        i.setAttribute("aria-selected", t.selected),
        i.setAttribute("aria-disabled", t.disabled),
        t.selected && N.addClass(i, "selected"),
        t.disabled && N.addClass(i, "disabled"),
        t.hidden && N.addClass(i, "d-none"),
        i.appendChild(Qb(t, e)),
        t.icon && i.appendChild(function(t) {
            const e = _("span");
            N.addClass(e, "select-option-icon-container");
            const i = _("img");
            return N.addClass(i, "select-option-icon"),
            N.addClass(i, "rounded-circle"),
            i.src = t.icon,
            e.appendChild(i),
            e
        }(t)),
        t.setNode(i),
        i
    }
    function Qb(t, e) {
        const i = _("span");
        N.addClass(i, "select-option-text");
        const n = document.createTextNode(t.label);
        return e.multiple && i.appendChild(function(t) {
            const e = _("input");
            e.setAttribute("type", "checkbox"),
            N.addClass(e, "form-check-input");
            const i = _("label");
            t.selected && e.setAttribute("checked", !0);
            t.disabled && e.setAttribute("disabled", !0);
            return e.appendChild(i),
            e
        }(t)),
        i.appendChild(n),
        (t.secondaryText || "number" == typeof t.secondaryText) && i.appendChild(function(t) {
            const e = _("span");
            N.addClass(e, "select-option-secondary-text");
            const i = document.createTextNode(t);
            return e.appendChild(i),
            e
        }(t.secondaryText)),
        i
    }
    const Jb = {
        autoSelect: !1,
        container: "body",
        clearButton: !1,
        disabled: !1,
        displayedLabels: 5,
        formWhite: !1,
        multiple: !1,
        optionsSelectedLabel: "options selected",
        optionHeight: 38,
        selectAll: !0,
        selectAllLabel: "Select all",
        searchPlaceholder: "Search...",
        size: "default",
        visibleOptions: 5,
        filter: !1,
        filterDebounce: 300,
        noResultText: "No results",
        validation: !1,
        validFeedback: "Valid",
        invalidFeedback: "Invalid",
        placeholder: "",
        filterFn: null,
        clearButtonLabel: "Clear selection"
    }
      , tv = {
        autoSelect: "boolean",
        container: "string",
        clearButton: "boolean",
        disabled: "boolean",
        displayedLabels: "number",
        formWhite: "boolean",
        multiple: "boolean",
        optionsSelectedLabel: "string",
        optionHeight: "number",
        selectAll: "boolean",
        selectAllLabel: "string",
        searchPlaceholder: "string",
        size: "string",
        visibleOptions: "number",
        filter: "boolean",
        filterDebounce: "number",
        noResultText: "string",
        validation: "boolean",
        validFeedback: "string",
        invalidFeedback: "string",
        placeholder: "",
        filterFn: "(function|null)",
        clearButtonLabel: "string"
    }
      , ev = "select"
      , iv = "mdb.select"
      , nv = `.${iv}`
      , sv = `close${nv}`
      , ov = `open${nv}`
      , av = `optionSelected${nv}`
      , rv = `optionDeselected${nv}`
      , lv = `valueChanged${nv}`
      , hv = `opened${nv}`
      , cv = `closed${nv}`
      , dv = `search${nv}`
      , uv = ".select-input"
      , pv = ".select-options-list"
      , fv = ".form-outline"
      , gv = "select-initialized"
      , mv = "open"
      , _v = "active"
      , bv = "focused";
    class vv extends ao {
        constructor(t, e) {
            super(t),
            this._config = this._getConfig(e),
            this._optionsToRender = this._getOptionsToRender(t),
            this._plainOptions = this._getPlainOptions(this._optionsToRender),
            this._filteredOptionsList = null,
            this._selectionModel = new Yb(this.multiple),
            this._activeOptionIndex = -1,
            this._activeOption = null,
            this._wrapperId = this._element.id ? `select-wrapper-${this._element.id}` : o("select-wrapper-"),
            this._dropdownContainerId = this._element.id ? `select-dropdown-container-${this._element.id}` : o("select-dropdown-container-"),
            this._inputId = this._element.id ? `select-input-${this._element.id}` : o("select-input-"),
            this._selectAllId = this._element.id ? `select-all-${this._element.id}` : o("select-all-"),
            this._debounceTimeoutId = null,
            this._dropdownHeight = this._config.optionHeight * this._config.visibleOptions,
            this._popper = null,
            this._input = null,
            this._label = B.next(this._element, ".select-label")[0],
            this._fakeValue = null,
            this._isFakeValueActive = !1,
            this._customContent = B.next(t, ".select-custom-content")[0],
            this._toggleButton = null,
            this._elementToggle = null,
            this._wrapper = null,
            this._inputEl = null,
            this._dropdownContainer = null,
            this._container = null,
            this._selectAllOption = null,
            this._init(),
            this._mutationObserver = null,
            this._isOpen = !1,
            this._animationTransitionTime = 200,
            this._addMutationObserver(),
            this._inputHandler = this._handleInput.bind(this),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return ev
        }
        get filterInput() {
            return B.findOne(".select-filter-input", this._dropdownContainer)
        }
        get dropdown() {
            return B.findOne(".select-dropdown", this._dropdownContainer)
        }
        get optionsList() {
            return B.findOne(pv, this._dropdownContainer)
        }
        get optionsWrapper() {
            return B.findOne(".select-options-wrapper", this._dropdownContainer)
        }
        get clearButton() {
            return B.findOne(".select-clear-btn", this._wrapper)
        }
        get options() {
            return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions
        }
        get value() {
            return this.multiple ? this._selectionModel.values : this._selectionModel.value
        }
        get multiple() {
            return this._config.multiple
        }
        get hasSelectAll() {
            return this.multiple && this._config.selectAll
        }
        get hasSelection() {
            return this._selectionModel.selection || this._selectionModel.selections.length > 0
        }
        _getConfig(t) {
            const e = N.getDataAttributes(this._element);
            return t = {
                ...Jb,
                ...e,
                ...t
            },
            this._element.hasAttribute("multiple") && (t.multiple = !0),
            this._element.hasAttribute("disabled") && (t.disabled = !0),
            this._element.tabIndex && (t.tabIndex = this._element.getAttribute("tabIndex")),
            d(ev, t, tv),
            t
        }
        _getOptionsToRender(t) {
            const e = [];
            return t.childNodes.forEach(t => {
                if ("OPTGROUP" === t.nodeName) {
                    const i = {
                        id: t.id ? `group-${t.id}` : o("group-"),
                        label: t.label,
                        disabled: t.hasAttribute("disabled"),
                        hidden: t.hasAttribute("hidden"),
                        options: []
                    };
                    t.childNodes.forEach(t => {
                        "OPTION" === t.nodeName && i.options.push(this._createOptionObject(t, i))
                    }
                    ),
                    e.push(i)
                } else
                    "OPTION" === t.nodeName && e.push(this._createOptionObject(t))
            }
            ),
            e
        }
        _getPlainOptions(t) {
            if (!B.findOne("optgroup", this._element))
                return t;
            const e = [];
            return t.forEach(t => {
                t.hasOwnProperty("options") ? t.options.forEach(t => {
                    e.push(t)
                }
                ) : e.push(t)
            }
            ),
            e
        }
        _createOptionObject(t, e={}) {
            const i = t.id ? `option-${t.id}` : o("option-")
              , n = e.id ? e.id : null
              , s = !!e.disabled && e.disabled
              , a = t.selected || t.hasAttribute("selected")
              , r = t.hasAttribute("disabled") || s
              , l = t.hasAttribute("hidden") || e && e.hidden
              , h = this.multiple
              , c = t.value
              , d = t.label
              , u = N.getDataAttribute(t, "secondaryText")
              , p = N.getDataAttribute(t, "icon");
            return new Vb(i,t,h,c,d,a,r,l,u,n,p)
        }
        _getNavigationOptions() {
            const t = this.options.filter(t => !t.hidden);
            return this.hasSelectAll ? [this._selectAllOption, ...t] : t
        }
        _init() {
            this._renderMaterialWrapper(),
            this._wrapper = B.findOne(`#${this._wrapperId}`),
            this._input = B.findOne(uv, this._wrapper),
            "off" === this._element.getAttribute("autocomplete") && this._input.setAttribute("autocomplete", "off");
            const t = this._config.container;
            this._container = "body" === t ? document.body : B.findOne(t),
            this._initOutlineInput(),
            this._setDefaultSelections(),
            this._updateInputValue(),
            this._appendFakeValue(),
            this._updateFakeLabelPosition(),
            this._updateLabelPosition(),
            this._updateClearButtonVisibility(),
            this._bindComponentEvents(),
            this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()),
            this._dropdownContainer = Ub(this._dropdownContainerId, this._config, this._input.offsetWidth, this._dropdownHeight, this._selectAllOption, this._optionsToRender, this._customContent),
            this._setFirstActiveOption()
        }
        _renderMaterialWrapper() {
            const t = function(t, e, i, n, s) {
                const o = document.createElement("div");
                o.setAttribute("id", t),
                o.classList.add("select-wrapper");
                const a = _("div");
                N.addClass(a, "form-outline"),
                a.setAttribute("data-mdb-input-init", ""),
                e.formWhite && N.addClass(a, "form-white");
                const r = _("input")
                  , l = e.disabled ? "true" : "false";
                N.addClass(r, "form-control"),
                N.addClass(r, "select-input"),
                "sm" === e.size && N.addClass(r, "form-control-sm"),
                "lg" === e.size && N.addClass(r, "form-control-lg"),
                r.setAttribute("type", "text"),
                r.setAttribute("role", "combobox"),
                r.setAttribute("aria-disabled", l),
                r.setAttribute("aria-haspopup", "listbox"),
                r.setAttribute("aria-expanded", !1),
                r.setAttribute("aria-controls", n),
                r.setAttribute("id", s),
                e.tabIndex && r.setAttribute("tabIndex", e.tabIndex),
                e.disabled && r.setAttribute("disabled", ""),
                "" !== e.placeholder && r.setAttribute("placeholder", e.placeholder),
                e.validation ? (N.addStyle(r, {
                    "pointer-events": "none",
                    "caret-color": "transparent"
                }),
                N.addStyle(a, {
                    cursor: "pointer"
                })) : r.setAttribute("readonly", "true"),
                e.validation && (r.setAttribute("required", "true"),
                r.setAttribute("aria-required", "true"),
                r.addEventListener("keydown", Kb));
                const h = _("div");
                N.addClass(h, "valid-feedback");
                const c = document.createTextNode(`${e.validFeedback}`);
                h.appendChild(c);
                const d = _("div");
                N.addClass(d, "invalid-feedback");
                const u = document.createTextNode(`${e.invalidFeedback}`);
                d.appendChild(u);
                const p = _("span");
                N.addClass(p, "select-clear-btn");
                const f = document.createTextNode("âœ•");
                p.appendChild(f),
                p.setAttribute("tabindex", "0"),
                p.setAttribute("aria-label", e.clearButtonLabel);
                const g = _("span");
                if (N.addClass(g, "select-arrow"),
                a.appendChild(r),
                i) {
                    a.appendChild(i);
                    const t = i.getAttribute("id");
                    i.setAttribute("for", s),
                    t && r.setAttribute("aria-labelledby", t)
                }
                return e.validation && (a.appendChild(h),
                a.appendChild(d)),
                e.clearButton && a.appendChild(p),
                a.appendChild(g),
                o.appendChild(a),
                o
            }(this._wrapperId, this._config, this._label, this._dropdownContainerId, this._inputId);
            this._element.parentNode.insertBefore(t, this._element),
            N.addClass(this._element, gv),
            t.appendChild(this._element)
        }
        _initOutlineInput() {
            const t = B.findOne(fv, this._wrapper);
            new go(t).init()
        }
        _updateOutlineInput() {
            const t = B.findOne(fv, this._wrapper);
            go.getInstance(t).update()
        }
        _bindComponentEvents() {
            this._listenToComponentKeydown(),
            this._listenToWrapperClick(),
            this._config.disabled || (this._listenToClearBtnClick(),
            this._listenToClearBtnKeydown())
        }
        _setDefaultSelections() {
            this.options.forEach(t => {
                t.selected && this._selectionModel.select(t)
            }
            )
        }
        _listenToComponentKeydown() {
            this._wrapperKeydownHandler = this._handleKeydown.bind(this),
            I.on(this._wrapper, "keydown", this._wrapperKeydownHandler)
        }
        _handleKeydown(t) {
            this._isOpen && !this._config.filter ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t)
        }
        _handleOpenKeydown(t) {
            const e = t.keyCode
              , i = e === lg || (e === eg || e === ng) && t.altKey || 9 === e;
            if (9 === e && this._config.autoSelect && !this.multiple && this._handleAutoSelection(this._activeOption),
            i)
                return this.close(),
                void this._input.focus();
            switch (e) {
            case ng:
                this._setNextOptionActive(),
                this._scrollToOption(this._activeOption);
                break;
            case eg:
                this._setPreviousOptionActive(),
                this._scrollToOption(this._activeOption);
                break;
            case sg:
                this._setFirstOptionActive(),
                this._scrollToOption(this._activeOption);
                break;
            case og:
                this._setLastOptionActive(),
                this._scrollToOption(this._activeOption);
                break;
            case ag:
                return t.preventDefault(),
                void (this._activeOption && (this.hasSelectAll && 0 === this._activeOptionIndex ? this._handleSelectAll() : this._handleSelection(this._activeOption)));
            default:
                return
            }
            t.preventDefault()
        }
        _handleClosedKeydown(t) {
            const e = t.keyCode;
            e !== ag && e !== rg || t.preventDefault();
            if ((e === ag || e === rg || (e === ng || e === eg) && t.altKey || e === ng && this.multiple) && this.open(),
            this.multiple)
                switch (e) {
                case ng:
                case eg:
                    this.open();
                    break;
                default:
                    return
                }
            else
                switch (e) {
                case ng:
                    if (t.altKey)
                        return;
                    this._setNextOptionActive(),
                    this._handleSelection(this._activeOption);
                    break;
                case eg:
                    if (t.altKey)
                        return;
                    this._setPreviousOptionActive(),
                    this._handleSelection(this._activeOption);
                    break;
                case sg:
                    this._setFirstOptionActive(),
                    this._handleSelection(this._activeOption);
                    break;
                case og:
                    this._setLastOptionActive(),
                    this._handleSelection(this._activeOption);
                    break;
                default:
                    return
                }
            t.preventDefault()
        }
        _scrollToOption(t) {
            if (!t)
                return;
            let e;
            const i = this.options.filter(t => !t.hidden);
            e = this.hasSelectAll ? i.indexOf(t) + 1 : i.indexOf(t);
            const n = e + this._getNumberOfGroupsBeforeOption(e)
              , s = this.optionsWrapper
              , o = s.offsetHeight
              , a = this._config.optionHeight
              , r = s.scrollTop;
            if (e > -1) {
                const t = n * a
                  , e = t + a > r + o
                  , i = t < r;
                s.scrollTop = i ? t : e ? t - o + a : r
            }
        }
        _getNumberOfGroupsBeforeOption(t) {
            const e = this.options.filter(t => !t.hidden)
              , i = this._optionsToRender.filter(t => !t.hidden)
              , n = this.hasSelectAll ? t - 1 : t;
            let s = 0;
            for (let o = 0; o <= n; o++)
                e[o].groupId && i[s] && i[s].id && e[o].groupId === i[s].id && s++;
            return s
        }
        _setNextOptionActive() {
            let t = this._activeOptionIndex + 1;
            const e = this._getNavigationOptions();
            if (e[t]) {
                for (; e[t].disabled; )
                    if (t += 1,
                    !e[t])
                        return;
                this._updateActiveOption(e[t], t)
            }
        }
        _setPreviousOptionActive() {
            let t = this._activeOptionIndex - 1;
            const e = this._getNavigationOptions();
            if (e[t]) {
                for (; e[t].disabled; )
                    if (t -= 1,
                    !e[t])
                        return;
                this._updateActiveOption(e[t], t)
            }
        }
        _setFirstOptionActive() {
            const t = this._getNavigationOptions();
            this._updateActiveOption(t[0], 0)
        }
        _setLastOptionActive() {
            const t = this._getNavigationOptions()
              , e = t.length - 1;
            this._updateActiveOption(t[e], e)
        }
        _updateActiveOption(t, e) {
            const i = this._activeOption;
            i && i.removeActiveStyles(),
            t.setActiveStyles(),
            this._activeOptionIndex = e,
            this._activeOption = t
        }
        _listenToWrapperClick() {
            I.on(this._wrapper, "click", () => {
                this.toggle()
            }
            )
        }
        _listenToClearBtnClick() {
            I.on(this.clearButton, "click", t => {
                t.preventDefault(),
                t.stopPropagation(),
                this._handleClear()
            }
            )
        }
        _listenToClearBtnKeydown() {
            I.on(this.clearButton, "keydown", t => {
                t.keyCode === ag && (this._handleClear(),
                t.preventDefault(),
                t.stopPropagation())
            }
            )
        }
        _handleClear() {
            if (this.multiple)
                this._selectionModel.clear(),
                this._deselectAllOptions(this.options),
                this.hasSelectAll && this._updateSelectAllState();
            else {
                const t = this._selectionModel.selection;
                this._selectionModel.clear(),
                t.deselect()
            }
            !0 === this._optionsToRender[0].hidden ? this._singleOptionSelect(this._optionsToRender[0]) : (this._emitValueChangeEvent(null),
            this._emitNativeChangeEvent()),
            this._updateInputValue(),
            this._updateFakeLabelPosition(),
            this._updateLabelPosition(),
            this._updateClearButtonVisibility()
        }
        _listenToOptionsClick() {
            I.on(this.optionsWrapper, "click", t => {
                if (t.target.classList.contains("select-option-group-label"))
                    return;
                const e = "DIV" === t.target.nodeName ? t.target : B.closest(t.target, ".select-option");
                if (e.classList.contains("select-all-option"))
                    return void this._handleSelectAll();
                const i = e.dataset.mdbId
                  , n = this.options.find(t => t.id === i);
                n && !n.disabled && this._handleSelection(n)
            }
            )
        }
        _handleSelectAll() {
            this._selectAllOption.selected ? (this._deselectAllOptions(this.options),
            this._selectAllOption.deselect()) : (this._selectAllOptions(this.options),
            this._selectAllOption.select()),
            this._updateInputValue(),
            this._updateFakeLabelPosition(),
            this._updateLabelPosition(),
            this._updateClearButtonVisibility(),
            this._emitValueChangeEvent(this.value),
            this._emitNativeChangeEvent()
        }
        _selectAllOptions(t) {
            t.forEach(t => {
                t.selected || t.disabled || (this._selectionModel.select(t),
                t.select())
            }
            )
        }
        _deselectAllOptions(t) {
            t.forEach(t => {
                t.selected && !t.disabled && (this._selectionModel.deselect(t),
                t.deselect())
            }
            )
        }
        _handleSelection(t) {
            this.multiple ? (this._handleMultiSelection(t),
            this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t),
            this._updateInputValue(),
            this._updateFakeLabelPosition(),
            this._updateLabelPosition(),
            this._updateClearButtonVisibility(),
            this._updateOutlineInput()
        }
        _handleAutoSelection(t) {
            this._singleOptionSelect(t),
            this._updateInputValue(),
            this._updateFakeLabelPosition(),
            this._updateLabelPosition(),
            this._updateClearButtonVisibility(),
            this._updateOutlineInput()
        }
        _handleSingleSelection(t) {
            this._singleOptionSelect(t),
            this.close(),
            this._input.focus()
        }
        _singleOptionSelect(t) {
            const e = this._selectionModel.selections[0];
            e && e !== t && this._singleOptionClear(e),
            e && t === e || (this._selectionModel.select(t),
            t.select(),
            t.node.setAttribute("selected", !0),
            I.trigger(this._element, av, {
                value: t.value
            }),
            this._emitValueChangeEvent(this.value),
            this._emitNativeChangeEvent())
        }
        _singleOptionClear(t) {
            this._selectionModel.deselect(t),
            t.deselect(),
            t.node.setAttribute("selected", !1),
            I.trigger(this._element, rv, {
                value: t.value
            })
        }
        _handleMultiSelection(t) {
            t.selected ? this._singleOptionClear(t) : (this._selectionModel.select(t),
            t.select(),
            t.node.setAttribute("selected", !0),
            I.trigger(this._element, av, {
                value: t.value
            })),
            this._emitValueChangeEvent(this.value),
            this._emitNativeChangeEvent()
        }
        _emitValueChangeEvent(t) {
            I.trigger(this._element, lv, {
                value: t
            })
        }
        _emitNativeChangeEvent() {
            I.trigger(this._element, "change")
        }
        _updateInputValue() {
            const t = this.multiple ? this._selectionModel.labels : this._selectionModel.label;
            let e;
            e = this.multiple && -1 !== this._config.displayedLabels && this._selectionModel.selections.length > this._config.displayedLabels ? `${this._selectionModel.selections.length} ${this._config.optionsSelectedLabel}` : t,
            this.multiple || this._isSelectionValid(this._selectionModel.selection) ? this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = " " : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] || this._config.placeholder ? this._input.value = "" : this._input.value = this._optionsToRender[0].label : this._input.value = ""
        }
        _isSelectionValid(t) {
            return !t || !t.disabled && "" !== t.value
        }
        _isLabelEmpty(t) {
            return !(!t || "" !== t.label)
        }
        _appendFakeValue() {
            if (!this._selectionModel.selection || this._selectionModel._multiple || this._config.placeholder)
                return;
            const t = this._selectionModel.selection.label;
            this._fakeValue = function(t) {
                const e = _("div");
                return e.textContent = t,
                N.addClass(e, "form-label"),
                N.addClass(e, "select-fake-value"),
                e
            }(t);
            B.findOne(fv, this._wrapper).appendChild(this._fakeValue)
        }
        _updateLabelPosition() {
            const t = N.hasClass(this._element, gv)
              , e = "" !== this._input.value;
            this._label && (t && (e || this._isOpen || this._isFakeValueActive) ? N.addClass(this._label, _v) : N.removeClass(this._label, _v))
        }
        _updateLabelPositionWhileClosing() {
            this._label && ("" !== this._input.value || this._isFakeValueActive ? N.addClass(this._label, _v) : N.removeClass(this._label, _v))
        }
        _updateFakeLabelPosition() {
            this._fakeValue && (this.hasSelection && (this._fakeValue.textContent = this.hasSelection.label),
            "" === this._input.value && "" !== this._fakeValue.innerHTML ? (this._isFakeValueActive = !0,
            N.addClass(this._fakeValue, _v)) : (this._isFakeValueActive = !1,
            N.removeClass(this._fakeValue, _v)))
        }
        _updateClearButtonVisibility() {
            var t, e;
            this.clearButton && ((null == (t = this._optionsToRender[0]) ? void 0 : t.hidden) && (null == (e = this._optionsToRender[0]) ? void 0 : e.selected) || !this.hasSelection ? N.addStyle(this.clearButton, {
                display: "none"
            }) : N.addStyle(this.clearButton, {
                display: "block"
            }))
        }
        _updateSelectAllState() {
            const t = this._selectAllOption.selected
              , e = Xb(this.options);
            !e && t ? this._selectAllOption.deselect() : e && !t && this._selectAllOption.select()
        }
        toggle() {
            this._isOpen ? this.close() : this.open()
        }
        open() {
            const t = this._config.disabled
              , e = I.trigger(this._element, ov);
            this._isOpen || t || e.defaultPrevented || (this._openDropdown(),
            this._updateDropdownWidth(),
            this._setFirstActiveOption(),
            this._scrollToOption(this._activeOption),
            this._config.filter && (setTimeout( () => {
                this.filterInput.focus(),
                this._filterOptions(this.filterInput.value)
            }
            , 0),
            this._listenToSelectSearch(),
            this._listenToDropdownKeydown()),
            this._listenToOptionsClick(),
            this._listenToOutsideClick(),
            this._listenToWindowResize(),
            this._isOpen = !0,
            this._input.setAttribute("aria-expanded", !0),
            I.trigger(this._element, hv),
            this._updateLabelPosition(),
            this._setInputActiveStyles())
        }
        _openDropdown() {
            this._popper = Ln(this._input, this._dropdownContainer, {
                placement: "bottom-start",
                modifiers: [{
                    name: "offset",
                    options: {
                        offset: [0, 1]
                    }
                }]
            }),
            this._container.appendChild(this._dropdownContainer),
            setTimeout( () => {
                N.addClass(this.dropdown, mv)
            }
            , 0)
        }
        _updateDropdownWidth() {
            const t = this._input.offsetWidth;
            N.addStyle(this._dropdownContainer, {
                width: `${t}px`
            })
        }
        _setFirstActiveOption() {
            const t = this._getNavigationOptions()
              , e = this._activeOption;
            e && e.removeActiveStyles();
            const i = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;
            i ? (this._activeOption = i,
            i.setActiveStyles(),
            this._activeOptionIndex = t.findIndex(t => t === i)) : (this._activeOption = null,
            this._activeOptionIndex = -1)
        }
        _setInputActiveStyles() {
            N.addClass(this._input, bv)
        }
        _listenToWindowResize() {
            this._windowResizeHandler = this._handleWindowResize.bind(this),
            I.on(window, "resize", this._windowResizeHandler)
        }
        _handleWindowResize() {
            this._dropdownContainer && (this._updateDropdownWidth(),
            this._popper.forceUpdate())
        }
        _listenToSelectSearch() {
            I.on(this.filterInput, "input", this._inputHandler)
        }
        _handleInput(t) {
            const e = t.target.value
              , i = this._config.filterDebounce;
            I.trigger(this._element, dv, {
                value: e
            }).defaultPrevented || this._debounceFilter(e, i)
        }
        _debounceFilter(t, e) {
            this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId),
            this._debounceTimeoutId = setTimeout( () => {
                this._filterOptions(t)
            }
            , e)
        }
        _filterOptions(t) {
            const e = []
              , i = this._config.filterFn;
            this._optionsToRender.forEach(n => {
                const s = n.hasOwnProperty("options")
                  , o = !s && n.label.toLowerCase().includes(t.toLowerCase())
                  , a = {};
                if (s && (a.label = n.label,
                a.options = this._filter(t, n.options),
                a.options.length > 0 && e.push(a)),
                i && !s) {
                    i(t, n) && e.push(n)
                } else
                    o && e.push(n)
            }
            );
            const n = "" !== this._config.noResultText
              , s = 0 !== e.length;
            if (s)
                this._updateOptionsListTemplate(e),
                this._popper.forceUpdate(),
                this._filteredOptionsList = this._getPlainOptions(e),
                this.hasSelectAll && this._updateSelectAllState(),
                this._setFirstActiveOption();
            else if (!s && n) {
                const t = this._getNoResultTemplate();
                this.optionsWrapper.innerHTML = t
            }
        }
        _updateOptionsListTemplate(t) {
            const e = B.findOne(pv, this._dropdownContainer) || B.findOne(".select-no-results", this._dropdownContainer)
              , i = qb(t, this._selectAllOption, this._config, this._label);
            this.optionsWrapper.removeChild(e),
            this.optionsWrapper.appendChild(i)
        }
        _getNoResultTemplate() {
            return `<div class="select-no-results" style="height: ${this._config.optionHeight}px">${this._config.noResultText}</div>`
        }
        _filter(t, e) {
            const i = this._config.filterFn;
            if (i)
                return e.filter(e => i(t, e) && !e.hidden);
            const n = t.toLowerCase();
            return e.filter(t => t.label.toLowerCase().includes(n) && !t.hidden)
        }
        _listenToDropdownKeydown() {
            this._dropdownKeydownHandler = this._handleOpenKeydown.bind(this),
            I.on(this.dropdown, "keydown", this._dropdownKeydownHandler)
        }
        _listenToOutsideClick() {
            this._outsideClickHandler = this._handleOutSideClick.bind(this),
            I.on(document, "click", this._outsideClickHandler)
        }
        _handleOutSideClick(t) {
            const e = this._wrapper && this._wrapper.contains(t.target)
              , i = t.target === this._dropdownContainer
              , n = this._dropdownContainer && this._dropdownContainer.contains(t.target);
            let s;
            this._toggleButton || (this._elementToggle = B.find("[data-mdb-toggle]")),
            this._elementToggle && this._elementToggle.forEach(e => {
                const i = N.getDataAttribute(e, "toggle");
                (i === this._element.id || this._element.classList.contains(i)) && (this._toggleButton = e,
                s = this._toggleButton.contains(t.target))
            }
            ),
            e || i || n || s || this.close()
        }
        close() {
            const t = I.trigger(this._element, sv);
            this._isOpen && !t.defaultPrevented && (this._config.filter && I.off(this.filterInput, "input", this._inputHandler),
            this._config.filter && this.hasSelectAll && (this._resetFilterState(),
            this._updateOptionsListTemplate(this._optionsToRender),
            this._config.multiple && this._updateSelectAllState()),
            this._removeDropdownEvents(),
            N.removeClass(this.dropdown, mv),
            setTimeout( () => {
                N.removeClass(this._input, bv),
                this._label && !this.hasSelection && (N.removeClass(this._label, _v),
                N.removeClass(this._input, _v)),
                this._updateLabelPositionWhileClosing()
            }
            , 0),
            setTimeout( () => {
                this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer),
                this._popper.destroy(),
                this._isOpen = !1,
                this._input.setAttribute("aria-expanded", !1),
                I.off(this.dropdown, "transitionend"),
                I.trigger(this._element, cv)
            }
            , this._animationTransitionTime))
        }
        _resetFilterState() {
            this.filterInput.value = "",
            this._filteredOptionsList = null
        }
        _removeDropdownEvents() {
            I.off(document, "click", this._outsideClickHandler),
            this._config.filter && I.off(this.dropdown, "keydown"),
            I.off(this.optionsWrapper, "click")
        }
        _addMutationObserver() {
            this._mutationObserver = new MutationObserver( () => {
                this._wrapper && (this._updateSelections(),
                this._updateDisabledState())
            }
            ),
            this._observeMutationObserver()
        }
        _updateSelections() {
            this._optionsToRender = this._getOptionsToRender(this._element),
            this._plainOptions = this._getPlainOptions(this._optionsToRender),
            this._selectionModel.clear(),
            this._setDefaultSelections(),
            this._updateInputValue(),
            this._updateFakeLabelPosition(),
            this._updateLabelPosition(),
            this._updateClearButtonVisibility(),
            this.hasSelectAll && this._updateSelectAllState();
            const t = this._config.filter && this.filterInput && this.filterInput.value;
            this._isOpen && !t ? (this._updateOptionsListTemplate(this._optionsToRender),
            this._setFirstActiveOption()) : this._isOpen && t ? (this._filterOptions(this.filterInput.value),
            this._setFirstActiveOption()) : this._dropdownContainer = Ub(this._dropdownContainerId, this._config, this._input.offsetWidth, this._dropdownHeight, this._selectAllOption, this._optionsToRender, this._customContent)
        }
        _updateDisabledState() {
            const t = B.findOne(uv, this._wrapper);
            this._element.hasAttribute("disabled") ? (this._config.disabled = !0,
            t.setAttribute("disabled", "")) : (this._config.disabled = !1,
            t.removeAttribute("disabled"))
        }
        _observeMutationObserver() {
            this._mutationObserver && this._mutationObserver.observe(this._element, {
                attributes: !0,
                childList: !0,
                characterData: !0,
                subtree: !0
            })
        }
        _disconnectMutationObserver() {
            this._mutationObserver && (this._mutationObserver.disconnect(),
            this._mutationObserver = null)
        }
        _createSelectAllOption() {
            const t = this._selectAllId
              , e = this._config.selectAllLabel
              , i = Xb(this.options);
            return new Vb(t,null,!0,"select-all",e,i,!1,!1,null,null,null)
        }
        dispose() {
            this._disconnectMutationObserver(),
            this._removeComponentEvents(),
            this._disconnectMutationObserver(),
            this._destroyMaterialSelect(),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _removeComponentEvents() {
            I.off(this.input, "click"),
            I.off(this.wrapper, this._wrapperKeydownHandler),
            I.off(this.clearButton, "click"),
            I.off(this.clearButton, "keydown"),
            I.off(window, "resize", this._windowResizeHandler)
        }
        _destroyMaterialSelect() {
            this._isOpen && this.close(),
            this._destroyMaterialTemplate()
        }
        _destroyMaterialTemplate() {
            const t = this._wrapper.parentNode
              , e = B.find("label", this._wrapper);
            t.appendChild(this._element),
            e.forEach(e => {
                t.appendChild(e)
            }
            ),
            e.forEach(t => {
                N.removeClass(t, _v)
            }
            ),
            N.removeClass(this._element, gv),
            this._customContent && t.appendChild(this._customContent),
            t.removeChild(this._wrapper)
        }
        setValue(t) {
            this._config.filter && this.filterInput.value && (this._resetFilterState(),
            I.trigger(this.filterInput, "input")),
            this._optionsToRender = this._getOptionsToRender(this._element),
            this._plainOptions = this._getPlainOptions(this._optionsToRender),
            this._plainOptions.forEach(t => {
                if (!t.node) {
                    const e = Gb(t, this._config);
                    t.setNode(e)
                }
            }
            ),
            this.options.forEach(t => {
                t.selected && (t.deselect(),
                t.nativeOption && t.nativeOption.removeAttribute("selected"),
                t.node && t.node.setAttribute("aria-selected", !1))
            }
            );
            const e = Array.isArray(t);
            e || this._selectByValue(t),
            e && this.multiple && t.forEach(t => {
                this._selectByValue(t)
            }
            ),
            this._updateSelections(),
            this._emitValueChangeEvent(t),
            this._updateOutlineInput()
        }
        _selectByValue(t) {
            const e = this.options.find(e => e.value === t);
            e && (e.select(),
            e.nativeOption && e.nativeOption.setAttribute("selected", !0),
            e.node && e.node.setAttribute("aria-selected", !0))
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                let i = s.getData(this, iv);
                const n = "object" == typeof t && t;
                if ((i || !/dispose/.test(t)) && (i || (i = new vv(this,n)),
                "string" == typeof t)) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
    }
    const yv = ".datatable-pagination"
      , xv = "paginationChange.mdb.datatable"
      , wv = "valueChanged.mdb.select";
    class Cv {
        constructor(t, e) {
            this._element = t,
            this._options = e,
            this._left = null,
            this._right = null,
            this._start = null,
            this._end = null,
            this._select = null,
            this._selectInstance = null,
            this._pagination = null,
            this._activePage = null,
            this._total = null,
            this._entries = null,
            this._setPaginationValues()
        }
        get options() {
            return {
                entries: this._options.entries,
                entriesOptions: this._options.entriesOptions,
                fullPagination: this._options.fullPagination,
                rowsText: this._options.rowsText,
                ofText: this._options.ofText,
                allText: this._options.allText
            }
        }
        get activePage() {
            return this._activePage
        }
        get pages() {
            return "all" === this._optionToLowerCase(this._entries) ? 1 : Math.ceil(this._total / this._entries)
        }
        get pagination() {
            return {
                page: this._activePage,
                entries: this._entries,
                total: this._total
            }
        }
        get navigationText() {
            const t = "all" === this._optionToLowerCase(this._options.entries) ? this._total : this._entries
              , {ofText: e} = this._options
              , i = this._activePage * Number(t)
              , n = Math.min(i + Number(t), this._total);
            return 0 === this._total ? `0 ${e} 0` : "all" === this._optionToLowerCase(this._entries) ? `1 - ${this._total} ${e} ${this._total}` : `${i + 1} - ${n} ${e} ${this._total}`
        }
        appendPagination() {
            this._appendPagination(),
            this._setupPagination(),
            this._setupPaginationSelect(),
            this._selectInstance.setValue(String(this._entries)),
            this._toggleDisableState()
        }
        updatePagination() {
            this._setPaginationValues(),
            this._removeEventListeners(),
            this._updatePaginationButtonsTemplate(),
            this._setupPagination(),
            this._setNavigationText(),
            this._setSelectLabel(),
            this._selectInstance.setValue(String(this._entries))
        }
        removePagination() {
            this._disposePaginationSelect(),
            this._removeEventListeners();
            const t = B.findOne(yv, this._element);
            t && t.remove(),
            this._pagination = null
        }
        _setNavigationText() {
            B.findOne(".datatable-pagination-nav", this._pagination).innerHTML = this.navigationText
        }
        _setSelectLabel() {
            B.findOne(".datatable-select-text", this._pagination).innerHTML = this._options.rowsText
        }
        _updatePaginationButtonsTemplate() {
            const t = Hb(this._options.fullPagination);
            B.findOne(".datatable-pagination-buttons", this._pagination).outerHTML = t
        }
        _setPaginationValues() {
            const {pagination: t} = this._options;
            this._activePage = t.page || 0,
            this._total = t.total || 0,
            this._entries = t.entries || this._options.entries
        }
        _appendPagination() {
            const t = ( ({entries: t, entriesOptions: e, fullPagination: i, rowsText: n, allText: s}, o, a) => `\n    <div class="datatable-pagination">\n      ${Fb(t, e, o, n, s)}\n      <div class="datatable-pagination-nav">\n        ${a}\n      </div>\n      ${Hb(i)}\n    </div>\n  `)(this.options, this._options.loading, this.navigationText);
            this._element.insertAdjacentHTML("beforeend", t),
            this._pagination = B.findOne(yv, this._element)
        }
        _optionToLowerCase(t) {
            return "string" == typeof t ? t.toLowerCase() : t
        }
        _toggleDisableState() {
            !1 !== this._options.pagination && (0 === this._activePage || this._options.loading ? (this._left.setAttribute("disabled", !0),
            this._options.fullPagination && this._start.setAttribute("disabled", !0)) : (this._left.removeAttribute("disabled"),
            this._options.fullPagination && this._start.removeAttribute("disabled")),
            this._activePage === this.pages - 1 || this._options.loading || 0 === this.pages ? (this._right.setAttribute("disabled", !0),
            this._options.fullPagination && this._end.setAttribute("disabled", !0)) : (this._right.removeAttribute("disabled"),
            this._options.fullPagination && this._end.removeAttribute("disabled")))
        }
        _removeEventListeners() {
            I.off(this._right, "click"),
            I.off(this._left, "click"),
            this._options.fullPagination && (I.off(this._start, "click"),
            I.off(this._end, "click"))
        }
        _setupPagination() {
            this._right = B.findOne(".datatable-pagination-right", this._element),
            this._left = B.findOne(".datatable-pagination-left", this._element);
            const t = [{
                button: this._right,
                action: () => this._activePage += 1
            }, {
                button: this._left,
                action: () => this._activePage -= 1
            }];
            this._options.fullPagination && (this._start = B.findOne(".datatable-pagination-start", this._element),
            this._end = B.findOne(".datatable-pagination-end", this._element),
            t.push({
                button: this._start,
                action: () => this._activePage = 0
            }, {
                button: this._end,
                action: () => this._activePage = this.pages - 1
            })),
            t.forEach( ({button: t, action: e}) => {
                t && I.on(t, "click", () => {
                    e(),
                    I.trigger(this._element, xv, {
                        pagination: this.pagination
                    })
                }
                )
            }
            )
        }
        _setupPaginationSelect() {
            this._selectInstance && this._selectInstance.dispose(),
            this._select = B.findOne(".datatable-select", this._element),
            this._selectInstance = new vv(this._select),
            I.on(this._select, wv, t => {
                this._entries !== t.value && (this._entries = t.value,
                I.trigger(this._element, xv, {
                    pagination: this.pagination
                }))
            }
            )
        }
        _disposePaginationSelect() {
            I.off(this._select, wv),
            this._selectInstance && this._selectInstance.dispose()
        }
    }
    const kv = "datatable"
      , Sv = `mdb.${kv}`
      , Tv = "datatable"
      , Av = "fixed-cell"
      , Ev = "td"
      , Mv = ".datatable-sort-icon"
      , Ov = ".datatable-body tr"
      , Dv = ".datatable-row-checkbox"
      , $v = ".datatable-pagination"
      , Iv = `.${Sv}`
      , Lv = `rowSelected${Iv}`
      , Pv = `render${Iv}`
      , Rv = `rowClicked${Iv}`
      , Nv = `update${Iv}`
      , Bv = "valueChanged.mdb.select"
      , Hv = "paginationChange.mdb.datatable"
      , Fv = {
        bordered: "boolean",
        borderless: "boolean",
        borderColor: "(string|null)",
        clickableRows: "boolean",
        color: "(string|null)",
        defaultValue: "string",
        edit: "boolean",
        entries: "(number|string)",
        entriesOptions: "array",
        fullPagination: "boolean",
        hover: "boolean",
        loading: "boolean",
        loadingMessage: "string",
        maxWidth: "(null|number|string)",
        maxHeight: "(null|number|string)",
        multi: "boolean",
        noFoundMessage: "string",
        pagination: "boolean|object",
        selectable: "boolean",
        serverSide: "boolean",
        sm: "boolean",
        sortField: "(null|string)",
        sortOrder: "(null|string)",
        loaderClass: "string",
        fixedHeader: "boolean",
        striped: "boolean",
        rowsText: "string",
        ofText: "string",
        allText: "string",
        forceSort: "boolean",
        columnSearch: "boolean"
    }
      , zv = {
        label: "string",
        field: "string",
        fixed: "(boolean|string)",
        format: "(function|null)",
        width: "(number|null)",
        sort: "boolean"
    }
      , jv = {
        bordered: !1,
        borderless: !1,
        borderColor: null,
        clickableRows: !1,
        color: null,
        defaultValue: "-",
        edit: !1,
        entries: 10,
        entriesOptions: [10, 25, 50, 200],
        fixedHeader: !1,
        fullPagination: !1,
        hover: !1,
        loaderClass: "bg-primary",
        loading: !1,
        loadingMessage: "Loading results...",
        maxWidth: null,
        maxHeight: null,
        multi: !1,
        noFoundMessage: "No matching results found",
        pagination: !0,
        selectable: !1,
        serverSide: !1,
        sm: !1,
        sortField: null,
        sortOrder: "asc",
        striped: !1,
        rowsText: "Rows per page:",
        ofText: "of",
        allText: "All",
        forceSort: !1,
        columnSearch: !1
    }
      , Wv = {
        label: "",
        field: "",
        fixed: !1,
        format: null,
        width: null,
        sort: !0
    };
    class Vv extends ao {
        constructor(t, e={}, i={}) {
            super(t),
            this._options = this._getOptions(i),
            this._sortReverse = !1,
            this._activePage = 0,
            this._search = "",
            this._searchColumn = null,
            this._pagination = new Cv(t,this._options),
            this._selected = [],
            this._checkboxes = null,
            this._headerCheckbox = null,
            this._columnSearchInputs = null,
            this._rows = this._getRows(e.rows),
            this._columns = this._getColumns(e.columns),
            this._tableId = null,
            this._hasFixedColumns = null,
            this._element && (this._perfectScrollbar = null,
            this._setup(),
            this._enforceOptionDependency(),
            this._hasFixedColumns = this._columns.some(t => t.hasOwnProperty("fixed")),
            this._hasFixedColumns && this._listenToWindowResize(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor))
        }
        static get NAME() {
            return kv
        }
        get columns() {
            return this._columns.map( (t, e) => {
                let i = {
                    ...Wv,
                    field: `field_${e}`,
                    columnIndex: e
                };
                return "string" == typeof t ? i.label = t : "object" == typeof t && (i = {
                    ...i,
                    ...t
                }),
                d("column", i, zv),
                i
            }
            )
        }
        get rows() {
            return this._rows.map( (t, e) => {
                const i = {
                    rowIndex: e
                };
                return Array.isArray(t) ? this.columns.forEach( (e, n) => {
                    0 === t[n] ? i[e.field] = t[n] : i[e.field] = t[n] || this._options.defaultValue
                }
                ) : "object" == typeof t && this.columns.forEach(e => {
                    0 === t[e.field] ? i[e.field] = t[e.field] : i[e.field] = t[e.field] || this._options.defaultValue
                }
                ),
                i
            }
            )
        }
        get searchResult() {
            return ( (t, e, i) => {
                if (!e)
                    return t;
                const n = t => {
                    const i = document.createElement("div");
                    return i.innerHTML = t,
                    (t = i.textContent || i.innerText || "").toString().toLowerCase().match(e.toLowerCase())
                }
                ;
                return t.filter(t => {
                    if (i && "string" == typeof i)
                        return n(t[i]);
                    let e = Object.values(t);
                    return i && Array.isArray(i) && (e = Object.keys(t).filter(t => i.includes(t)).map(e => t[e])),
                    e.filter(t => n(t)).length > 0
                }
                )
            }
            )(this.rows, this._search, this._searchColumn)
        }
        get computedRows() {
            let t = [...this.searchResult];
            if (this._pagination._total = t.length,
            this._options.sortOrder && (t = ( ({rows: t, field: e, order: i}) => t.sort( (t, n) => {
                let s = t[e]
                  , o = n[e];
                return "string" == typeof s && (s = s.toLowerCase()),
                "string" == typeof o && (o = o.toLowerCase()),
                s < o ? "desc" === i ? 1 : -1 : s > o ? "desc" === i ? -1 : 1 : 0
            }
            ))({
                rows: t,
                field: this._options.sortField,
                order: this._options.sortOrder
            })),
            this._options.pagination) {
                t = ( ({rows: t, entries: e, activePage: i}) => {
                    const n = i * e;
                    return t.slice(n, n + Number(e))
                }
                )({
                    rows: t,
                    entries: "all" === this._optionToLowerCase(this._options.entries) ? t.length : this._options.entries,
                    activePage: this._activePage
                })
            }
            return t
        }
        get pages() {
            return "all" === this._optionToLowerCase(this._options.entries) ? 1 : Math.ceil(this.searchResult.length / this._options.entries)
        }
        get pagination() {
            return this._pagination.pagination
        }
        get classNames() {
            return [Tv, this._options.color, this._options.borderColor && `border-${this._options.borderColor}`, this._options.hover && "datatable-hover", this._options.bordered && "datatable-bordered", this._options.borderless && "datatable-borderless", this._options.sm && "datatable-sm", this._options.striped && "datatable-striped", this._options.loading && "datatable-loading", this._options.clickableRows && "datatable-clickable-rows"].filter(t => t)
        }
        get tableOptions() {
            return {
                columns: this.columns,
                rows: this._options.serverSide ? this.rows : this.computedRows,
                noFoundMessage: this._options.noFoundMessage,
                edit: this._options.edit,
                loading: this._options.loading,
                loaderClass: this._options.loaderClass,
                loadingMessage: this._options.loadingMessage,
                selectable: this._options.selectable,
                multi: this._options.multi,
                forceSort: this._options.forceSort,
                columnSearch: this._options.columnSearch
            }
        }
        update(t, e={}) {
            t && t.rows && (this._rows = t.rows),
            t && t.columns && (this._columns = t.columns),
            this._clearClassList(e),
            this._options = this._getOptions({
                ...this._options,
                ...e
            }),
            this._pagination._options = this._options,
            this._setup(),
            this._renderRows()
        }
        dispose() {
            this._removeEventListeners(),
            this._pagination && this._pagination.removePagination(),
            this._perfectScrollbar.destroy(),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        search(t, e) {
            this._search = t,
            this._searchColumn = e,
            this._activePage = 0,
            this._pagination._activePage = this._activePage,
            this._renderRows(),
            this._options.maxHeight && (this._perfectScrollbar.element.scrollTop = 0,
            this._perfectScrollbar.update())
        }
        sort(t, e="asc") {
            this._options.sortOrder = e,
            this._options.sortField = "string" == typeof t ? this.columns.find(e => e.field === t).field : "number" == typeof t ? this.columns[t].field : t.field;
            const i = B.findOne(`i[data-mdb-sort="${this._options.sortField}"]`, this._element);
            this._setActiveSortIcon(i),
            this._options.serverSide || this._renderRows()
        }
        setActivePage(t) {
            t < this.pages && this._changeActivePage(t)
        }
        _changeActivePage(t) {
            this._activePage = t,
            this._pagination._activePage = this._activePage,
            this._pagination._toggleDisableState(),
            this._renderRows()
        }
        _enforceOptionDependency() {
            this._options.serverSide && this._options.pagination && "object" != typeof this._options.pagination && console.warn("A pagination object is required when serverSide is enabled and pagination is intended to be used.")
        }
        _optionToLowerCase(t) {
            return "string" == typeof t ? t.toLowerCase() : t
        }
        _clearClassList(t) {
            this._options.color && t.color && N.removeClass(this._element, this._options.color),
            this._options.borderColor && t.borderColor && N.removeClass(this._element, `border-${this._options.borderColor}`),
            ["hover", "bordered", "borderless", "sm", "striped", "loading"].forEach(e => {
                this._options[e] && !t[e] && N.removeClass(this._element, `datatable-${e}`)
            }
            )
        }
        _emitSelectEvent() {
            I.trigger(this._element, Lv, {
                selectedRows: this.rows.filter(t => -1 !== this._selected.indexOf(t.rowIndex)),
                selectedIndexes: this._selected,
                allSelected: this._selected.length === this.rows.length
            })
        }
        _getRows(t=[]) {
            const e = B.findOne("tbody", this._element);
            if (!e)
                return t;
            return [...B.find("tr", e).map(t => B.find("td", t).map(t => t.innerHTML)), ...t]
        }
        _getColumns(t=[]) {
            const e = B.findOne("thead", this._element);
            if (!e)
                return t;
            const i = B.findOne("tr", e);
            return [...B.find("th", i).map(t => ({
                label: t.innerHTML,
                ...N.getDataAttributes(t)
            })), ...t]
        }
        _getCSSValue(t) {
            return "string" == typeof t ? t : `${t}px`
        }
        _getOptions(t) {
            const e = {
                ...jv,
                ...N.getDataAttributes(this._element),
                ...t
            }
              , i = N.getDataAttributes(this._element).entriesOptions
              , n = Array.isArray(e.entriesOptions) ? e.entriesOptions : JSON.parse(i.replaceAll("'", '"'));
            return e.entriesOptions = n,
            d(kv, e, Fv),
            e
        }
        _setActiveRows() {
            B.find(Ov, this._element).forEach(t => {
                this._selected.includes(N.getDataAttribute(t, "index")) ? N.addClass(t, "active") : N.removeClass(t, "active")
            }
            )
        }
        _setEntries(t) {
            this._options = this._getOptions({
                ...this._options,
                entries: t.target.value
            }),
            this._pagination._options = this._options,
            this._activePage > this.pages - 1 && (this._activePage = this.pages - 1,
            this._pagination._activePage = this._activePage),
            this._pagination._toggleDisableState(),
            this._renderRows()
        }
        _setSelected() {
            B.find(Dv, this._element).forEach(t => {
                const e = N.getDataAttribute(t, "rowIndex");
                t.checked = this._selected.includes(e)
            }
            ),
            this._setActiveRows()
        }
        _setActiveSortIcon(t) {
            B.find(Mv, this._element).forEach(e => {
                const i = "desc" === this._options.sortOrder && e === t ? 180 : 0;
                N.style(e, {
                    transform: `rotate(${i}deg)`
                }),
                e === t && this._options.sortOrder ? N.addClass(e, "active") : N.removeClass(e, "active")
            }
            )
        }
        _setClassNames() {
            this.classNames.forEach(t => {
                N.addClass(this._element, t)
            }
            )
        }
        _setup() {
            this._setClassNames(),
            this._renderTable(),
            this._options.edit && this._setupEditable(),
            this._options.clickableRows && this._setupClickableRows(),
            this._options.selectable && this._setupSelectable(),
            this._options.columnSearch && this._setupColumnSearch(),
            this._setupScroll(),
            this._setupSort()
        }
        _setupPagination() {
            B.findOne($v, this._element) ? this._pagination.updatePagination() : (this._pagination.appendPagination(),
            this._setupPaginationListeners())
        }
        _listenToWindowResize() {
            this._windowResizeHandler = this._handleWindowResize.bind(this),
            L.on(window, "resize DOMContentLoaded", this._windowResizeHandler)
        }
        _handleWindowResize() {
            this._renderRows()
        }
        _setupClickableRows() {
            B.find(Ov, this._element).forEach(t => {
                const e = N.getDataAttribute(t, "index");
                I.on(t, "click", t => {
                    B.matches(t.target, Dv) || I.trigger(this._element, Rv, {
                        index: e,
                        row: this.rows[e]
                    })
                }
                )
            }
            )
        }
        _setupEditable() {
            B.find(Ov, this._element).forEach(t => {
                const e = N.getDataAttribute(t, "index");
                B.find(Ev, t).forEach(t => {
                    I.on(t, "input", t => this._updateRow(t, e)),
                    I.on(t, "focus", () => {
                        t.classList.add("editable-active")
                    }
                    ),
                    I.on(t, "blur", () => {
                        t.classList.remove("editable-active")
                    }
                    )
                }
                )
            }
            )
        }
        _setupScroll() {
            const t = B.findOne(".datatable-inner", this._element)
              , e = {
                overflow: "auto",
                position: "relative"
            };
            if (this._options.maxHeight && (e.maxHeight = this._getCSSValue(this._options.maxHeight)),
            this._options.maxWidth) {
                const t = this._getCSSValue(this._options.maxWidth);
                e.maxWidth = t,
                N.style(this._element, {
                    maxWidth: t
                })
            }
            if (N.style(t, e),
            this._options.fixedHeader) {
                let t = B.find(".datatable-header th", this._element);
                this._options.selectable && (t = t.filter( (t, e) => (N.addClass(t, Av),
                this._options.color && N.addClass(t, this._options.color),
                0 !== e))),
                t.forEach( (t, e) => {
                    N.addClass(t, Av),
                    this.columns[e].fixed && N.addStyle(t, {
                        zIndex: 4
                    }),
                    this._options.color && N.addClass(t, this._options.color)
                }
                )
            }
            this._perfectScrollbar = new Qf(t)
        }
        _setupSort() {
            B.find(Mv, this._element).forEach(t => {
                const e = N.getDataAttribute(t, "sort")
                  , [i] = B.parents(t, "div");
                N.style(i, {
                    cursor: "pointer"
                }),
                e === this._options.sortField && this._setActiveSortIcon(t),
                I.on(i, "click", () => {
                    this._options.sortField === e && "asc" === this._options.sortOrder ? this._options.sortOrder = "desc" : this._options.sortField === e && "desc" === this._options.sortOrder ? this._options.sortOrder = this._options.forceSort ? "asc" : null : this._options.sortOrder = "asc",
                    this._options.sortField = e,
                    I.trigger(this._element, "sortChange.mdb.datatable", {
                        sorting: {
                            field: e,
                            columnIndex: this._getColumnIndex(e),
                            order: this._options.sortOrder
                        }
                    }),
                    this._options.serverSide || (this._renderRows(),
                    this._setActiveSortIcon(t))
                }
                )
            }
            )
        }
        _setupColumnSearch() {
            this._columnSearchInputs = B.find(".datatable-header-filter-input", this._element),
            this._columnSearchInputs.forEach(t => {
                I.on(t, "input", e => {
                    const i = e.target.value
                      , n = N.getDataAttribute(t, "field")
                      , s = this._getColumnIndex(n);
                    I.trigger(this._element, "columnSearch.mdb.datatable", {
                        value: i,
                        field: n,
                        columnIndex: s
                    }),
                    this._options.serverSide || this.search(i, n)
                }
                )
            }
            )
        }
        _getColumnIndex(t) {
            return this.columns.findIndex(e => e.field === t)
        }
        _setupSelectable() {
            this._checkboxes = B.find(Dv, this._element),
            this._headerCheckbox = B.findOne(".datatable-header-checkbox", this._element),
            I.on(this._headerCheckbox, "input", t => this._toggleSelectAll(t)),
            this._checkboxes.forEach(t => {
                const e = N.getDataAttribute(t, "rowIndex");
                I.on(t, "input", t => this._toggleSelectRow(t, e))
            }
            )
        }
        _removeEventListeners() {
            this._options.pagination && (I.off(this._element, Hv),
            I.off(this._pagination._select, Bv)),
            L.off(window, "resize DOMContentLoaded", this._windowResizeHandler),
            this._options.editable && B.find(Ev, this._element).forEach(t => {
                I.off(t, "input"),
                I.off(t, "focus"),
                I.off(t, "blur")
            }
            ),
            this._options.clickableRows && B.find(Ov, this._element).forEach(t => {
                I.off(t, "click")
            }
            ),
            B.find(Mv, this._element).forEach(t => {
                const [e] = B.parents(t, "th");
                I.off(e, "click")
            }
            ),
            this._options.selectable && (I.off(this._headerCheckbox, "input"),
            this._checkboxes.forEach(t => {
                I.off(t, "input")
            }
            )),
            this._options.columnSearch && this._columnSearchInputs.forEach(t => {
                I.off(t, "input")
            }
            )
        }
        _renderTable() {
            const t = B.findOne("table", this._element);
            this._tableId = null == t ? void 0 : t.getAttribute("id");
            const e = this.tableOptions
              , {rows: i} = e
              , n = B.findOne($v, this._element);
            if (n && !this._options.pagination && this._pagination.removePagination(),
            [...this._element.children].forEach(t => {
                t !== n && t.remove()
            }
            ),
            this._element.insertAdjacentHTML("afterbegin", Bb(e).table),
            this._options.pagination && this._setupPagination(),
            this._tableId) {
                B.findOne("table", this._element).setAttribute("id", this._tableId)
            }
            this._formatCells(i),
            I.trigger(this._element, Pv)
        }
        _renderRows() {
            const t = B.findOne("tbody", this._element)
              , e = this.tableOptions
              , {rows: i} = e;
            t.innerHTML = Bb(e).rows,
            this._options.pagination && (this._pagination._setNavigationText(),
            this._pagination._toggleDisableState()),
            this._formatCells(i),
            this._options.edit && this._setupEditable(),
            this._options.selectable && (this._setupSelectable(),
            this._setSelected()),
            this._options.clickableRows && this._setupClickableRows(),
            I.trigger(this._element, Pv)
        }
        _formatCells(t) {
            const e = new Map(this.columns.map(t => [t.field, t]))
              , i = B.find(Ov, this._element)
              , n = [];
            i.forEach( (i, s) => {
                B.find(Ev, i).forEach(i => {
                    const o = N.getDataAttribute(i, "field")
                      , a = e.get(o);
                    if (a && null !== a.format) {
                        const e = t[s][o];
                        n.push({
                            cell: i,
                            column: a,
                            cellData: e
                        })
                    }
                }
                )
            }
            ),
            n.forEach( ({cell: t, column: e, cellData: i}) => e.format(t, i))
        }
        _setupPaginationListeners() {
            this._options.serverSide || (I.on(this._element, Hv, t => {
                var e;
                this._activePage !== (null == (e = t.pagination) ? void 0 : e.page) && this._changeActivePage(t.pagination.page)
            }
            ),
            I.on(this._pagination._select, Bv, t => {
                this._options.entries !== t.value && this._setEntries(t)
            }
            ))
        }
        _toggleSelectAll(t) {
            t.target.checked ? this._selected = this.rows.map(t => t.rowIndex) : this._selected = [],
            this._setSelected(),
            this._emitSelectEvent()
        }
        _toggleSelectRow(t, e) {
            t.target.checked ? this._options.multi && !this._selected.includes(e) ? this._selected = [...this._selected, e] : (this._selected = [e],
            this._checkboxes.forEach(e => {
                e !== t.target && (e.checked = !1)
            }
            )) : this._selected = this._selected.filter(t => t !== e),
            this._options.multi && !t.target.checked && (this._headerCheckbox.checked = !1),
            this._setActiveRows(),
            this._emitSelectEvent()
        }
        _updateRow(t, e) {
            const i = N.getDataAttribute(t.target, "field")
              , n = t.target.textContent
              , s = this._rows[e];
            if (Array.isArray(s)) {
                s[this.columns.find(t => t.field === i).columnIndex] = n
            } else
                s[i] = n;
            I.trigger(this._element, Nv, {
                rows: this._rows,
                columns: this._columns
            })
        }
        static jQueryInterface(t, e, i) {
            return this.each(function() {
                let n = s.getData(this, Sv);
                const o = "object" == typeof t && t;
                if ((n || !/dispose/.test(t)) && (n || (n = new Vv(this,o,e)),
                "string" == typeof t)) {
                    if (void 0 === n[t])
                        throw new TypeError(`No method named "${t}"`);
                    n[t](e, i)
                }
            })
        }
    }
    const Yv = "stepper"
      , Xv = "mdb.stepper"
      , Kv = `.${Xv}`
      , Uv = "horizontal"
      , qv = "vertical"
      , Zv = "mobile"
      , Gv = {
        stepperType: "string",
        stepperLinear: "boolean",
        stepperNoEditable: "boolean",
        stepperActive: "string",
        stepperCompleted: "string",
        stepperInvalid: "string",
        stepperDisabled: "string",
        stepperVerticalBreakpoint: "number",
        stepperMobileBreakpoint: "number",
        stepperMobileBarBreakpoint: "number",
        animations: "boolean",
        stepperHeadClick: "boolean",
        stepperMobileNextBtn: "string",
        stepperMobileBackBtn: "string",
        stepperMobileStepTxt: "string",
        stepperMobileOfTxt: "string"
    }
      , Qv = {
        stepperType: Uv,
        stepperLinear: !1,
        stepperNoEditable: !1,
        stepperActive: "",
        stepperCompleted: "",
        stepperInvalid: "",
        stepperDisabled: "",
        stepperVerticalBreakpoint: 0,
        stepperMobileBreakpoint: 0,
        stepperMobileBarBreakpoint: 4,
        animations: !0,
        stepperHeadClick: !0,
        stepperMobileNextBtn: "NEXT",
        stepperMobileBackBtn: "BACK",
        stepperMobileStepTxt: "step",
        stepperMobileOfTxt: "of"
    }
      , Jv = `mousedown${Kv}`
      , ty = `submit${Kv}`
      , ey = `keydown${Kv}`
      , iy = `keyup${Kv}`
      , ny = `resize${Kv}`
      , sy = `click${Kv}`
      , oy = "animationend"
      , ay = `stepChange${Kv}`
      , ry = `stepChanged${Kv}`
      , ly = `stepInvalid${Kv}`
      , hy = `stepValid${Kv}`
      , cy = `${Yv}-step`
      , dy = `${Yv}-head`
      , uy = `${Yv}-head-text`
      , py = `${Yv}-content`
      , fy = `${Yv}-active`
      , gy = `${Yv}-completed`
      , my = `${Yv}-invalid`
      , _y = `${Yv}-disabled`
      , by = `${Yv}-${qv}`
      , vy = `${Yv}-content-hide`
      , yy = `${Yv}-${Uv}`
      , xy = `${Yv}-${Zv}`
      , wy = `${Yv}-${Zv}-head`
      , Cy = `${Yv}-${Zv}-footer`
      , ky = `${Yv}-${Zv}-progress-bar`
      , Sy = `${Yv}-next-btn`
      , Ty = `${Yv}-back-btn`
      , Ay = `${Yv}-active-step`
      , Ey = `${Yv}-all-steps`
      , My = `\n  <div class="${`${Yv}-${Zv}-progress`} gray-500">\n    <div class="${ky}"></div>\n  </div>\n`
      , Oy = `\n  <div class="${Cy}"></div>\n`;
    class Dy extends ao {
        constructor(t, e) {
            super(t),
            this._options = this._getConfig(e),
            this._elementHeight = 0,
            this._steps = B.find(`.${cy}`, this._element),
            this._currentView = "",
            this._activeStepIndex = 0,
            this._verticalStepperStyles = [],
            this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations,
            this._element && (this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor))
        }
        static get NAME() {
            return Yv
        }
        get activeStep() {
            return this._steps[this._activeStepIndex]
        }
        get activeStepIndex() {
            return this._activeStepIndex
        }
        dispose() {
            this._steps.forEach(t => {
                I.off(t, Jv),
                I.off(t, ey)
            }
            ),
            I.off(window, ny),
            this._unbindMouseDown(),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        changeStep(t) {
            this._toggleStep(t)
        }
        nextStep() {
            this._toggleStep(this._activeStepIndex + 1)
        }
        prevStep() {
            this._toggleStep(this._activeStepIndex - 1)
        }
        resizeStepper() {
            this._currentView === qv && this._setSingleStepHeight(this.activeStep),
            this._currentView === Uv && this._setHeight(this.activeStep),
            (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView()
        }
        _init() {
            const t = B.findOne(`.${fy}`, this._element);
            switch (t ? (this._activeStepIndex = this._steps.indexOf(t),
            this._toggleStepClass(this._activeStepIndex, "add", this._options.stepperActive)) : (this._toggleStepClass(this._activeStepIndex, "add", fy),
            this._toggleStepClass(this._activeStepIndex, "add", this._options.stepperActive)),
            this._setOptional(),
            this._options.stepperHeadClick && this._bindMouseDown(),
            this._bindKeysNavigation(),
            this._options.stepperType) {
            case qv:
                this._toggleVertical();
                break;
            case Zv:
                this._toggleMobile();
                break;
            default:
                this._toggleHorizontal()
            }
            (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView(),
            this._options.stepperLinear && this._setValidation(),
            this._bindResize()
        }
        _getConfig(t) {
            const e = N.getDataAttributes(this._element);
            return t = {
                ...Qv,
                ...e,
                ...t
            },
            d(Yv, t, Gv),
            t
        }
        _bindMouseDown() {
            this._steps.forEach(t => {
                const e = B.findOne(`.${dy}`, t);
                I.on(e, Jv, t => {
                    const e = B.parents(t.target, `.${cy}`)[0]
                      , i = this._steps.indexOf(e);
                    t.preventDefault(),
                    this._toggleStep(i)
                }
                )
            }
            )
        }
        _unbindMouseDown() {
            this._steps.forEach(t => {
                const e = B.findOne(`.${dy}`, t);
                I.off(e, Jv)
            }
            )
        }
        _bindResize() {
            I.on(window, ny, () => {
                this.resizeStepper()
            }
            )
        }
        _toggleStepperView() {
            const t = this._options.stepperVerticalBreakpoint < window.innerWidth
              , e = this._options.stepperVerticalBreakpoint > window.innerWidth
              , i = this._options.stepperMobileBreakpoint > window.innerWidth;
            t && this._currentView !== Uv && this._toggleHorizontal(),
            e && !i && this._currentView !== qv && (this._steps.forEach(t => {
                const e = B.findOne(`.${py}`, t);
                this._resetStepperHeight(),
                this._showElement(e)
            }
            ),
            this._toggleVertical()),
            i && this._currentView !== Zv && this._toggleMobile()
        }
        _toggleStep(t) {
            const e = this._steps.length
              , i = this._validateStep(t)
              , n = this._activeStepIndex;
            if (!i)
                return;
            if (this._options.stepperLinear && I.trigger(this.activeStep, hy, {
                currentStep: this._activeStepIndex,
                nextStep: t
            }),
            this._options.stepperNoEditable && this._toggleDisabled(),
            this._showElement(B.findOne(`.${py}`, this._steps[t])),
            this._toggleActive(t),
            (!this._options.stepperLinear || t > this._activeStepIndex) && this._toggleCompleted(this._activeStepIndex),
            this._currentView === Uv || this._currentView === Zv ? this._animateHorizontalStep(t) : (this._animateVerticalStep(t),
            this._setSingleStepHeight(this._steps[t])),
            this._toggleStepTabIndex(B.findOne(`.${dy}`, this.activeStep), B.findOne(`.${dy}`, this._steps[t])),
            this._activeStepIndex = t,
            this._currentView === Zv) {
                B.findOne(`#${Ay}`, this._element).textContent = this._activeStepIndex + 1,
                e > this._options.stepperMobileBarBreakpoint && this._updateProgressBar()
            }
            const s = this.activeStep.querySelectorAll(".form-outline")
              , o = B.find(".form-notch", s[0]);
            s.length && o.length < 1 && s.forEach(t => {
                new mdb.Input(t).init()
            }
            ),
            I.trigger(this.activeStep, ry, {
                currentStep: this._activeStepIndex,
                prevStep: n
            })
        }
        _resetStepperHeight() {
            this._element.style.height = ""
        }
        _setStepsHeight() {
            this._steps.forEach(t => {
                const e = B.findOne(`.${py}`, t)
                  , i = window.getComputedStyle(e);
                this._verticalStepperStyles.push({
                    paddingTop: parseFloat(i.paddingTop),
                    paddingBottom: parseFloat(i.paddingBottom)
                });
                const n = e.scrollHeight;
                e.style.height = `${n}px`
            }
            )
        }
        _setSingleStepHeight(t) {
            const e = B.findOne(`.${py}`, t)
              , i = this.activeStep === t
              , n = this._steps.indexOf(t);
            let s;
            i ? (e.style.height = "",
            s = e.scrollHeight) : s = e.scrollHeight + this._verticalStepperStyles[n].paddingTop + this._verticalStepperStyles[n].paddingBottom,
            e.style.height = `${s}px`
        }
        _createMobileElements() {
            this._element.insertAdjacentHTML("beforeend", Oy);
            const t = B.findOne(`.${Cy}`, this._element);
            var e;
            this._steps.length > this._options.stepperMobileBarBreakpoint && (this._element.classList.add("stepper-progress-bar"),
            t.insertAdjacentHTML("afterbegin", My),
            this._updateProgressBar()),
            t.insertAdjacentHTML("afterbegin", (e = this._options,
            `\n  <div class="${Ty}">\n    <button type="button" class="btn btn-link">\n      <i class="fas fa-chevron-left"></i>\n      ${e.stepperMobileBackBtn}\n    </button>\n  </div>\n`)),
            t.insertAdjacentHTML("beforeend", (t => `\n  <div class="${Sy}">\n    <button type="button" class="btn btn-link">\n      ${t.stepperMobileNextBtn}\n      <i class="fas fa-chevron-right"></i>\n    </button>\n  </div>\n`)(this._options)),
            this._element.insertAdjacentHTML("afterbegin", (t => `\n  <div class ="${wy}">\n    ${t.stepperMobileStepTxt} <span id="${Ay}"></span> ${t.stepperMobileOfTxt} <span id="${Ey}"></span>\n  </div>\n`)(this._options));
            B.findOne(`#${Ey}`, this._element).textContent = this._steps.length;
            B.findOne(`#${Ay}`, this._element).textContent = this._activeStepIndex + 1
        }
        _toggleMobile() {
            this._currentView = Zv,
            this._toggleStepperClass(xy),
            this._createMobileElements(),
            this._bindMobileButtons(),
            this._setHeight(this.activeStep),
            this._hideInactiveSteps()
        }
        _toggleVertical() {
            this._currentView === Zv && (this._deleteMobileElements(),
            this._unbindMobileButtons()),
            this._currentView = qv,
            this._toggleStepperClass(by),
            this._setStepsHeight(),
            this._hideInactiveSteps()
        }
        _toggleHorizontal() {
            this._currentView === Zv && (this._deleteMobileElements(),
            this._unbindMobileButtons()),
            this._currentView = Uv,
            this._toggleStepperClass(yy),
            this._setHeight(this.activeStep),
            this._hideInactiveSteps()
        }
        _toggleStepperClass(t) {
            this._element.classList.remove(yy, xy, by),
            this._element.classList.add(t),
            t !== by && this._steps.forEach(t => {
                B.findOne(`.${py}`, t).classList.remove(vy)
            }
            )
        }
        _toggleStepClass(t, e, i) {
            i && this._steps[t].classList[e](i)
        }
        _deleteMobileElements() {
            const t = B.findOne(`.${Cy}`, this._element)
              , e = B.findOne(`.${wy}`, this._element);
            t.remove(),
            e.remove()
        }
        _bindKeysNavigation() {
            this._toggleStepTabIndex(!1, B.findOne(`.${dy}`, this.activeStep)),
            this._steps.forEach(t => {
                const e = B.findOne(`.${dy}`, t);
                I.on(e, ey, t => {
                    const e = B.parents(t.currentTarget, `.${cy}`)[0]
                      , i = B.next(e, `.${cy}`)[0]
                      , n = B.prev(e, `.${cy}`)[0]
                      , s = B.findOne(`.${dy}`, e)
                      , o = B.findOne(`.${dy}`, this.activeStep);
                    let a = null
                      , r = null;
                    if (i && (a = B.findOne(`.${dy}`, i)),
                    n && (r = B.findOne(`.${dy}`, n)),
                    t.keyCode === tg && this._currentView !== qv && (!m && r ? (this._toggleStepTabIndex(s, r),
                    this._toggleOutlineStyles(s, r),
                    r.focus()) : m && a && (this._toggleStepTabIndex(s, a),
                    this._toggleOutlineStyles(s, a),
                    a.focus())),
                    t.keyCode === ig && this._currentView !== qv && (!m && a ? (this._toggleStepTabIndex(s, a),
                    this._toggleOutlineStyles(s, a),
                    a.focus()) : m && r && (this._toggleStepTabIndex(s, r),
                    this._toggleOutlineStyles(s, r),
                    r.focus())),
                    t.keyCode === ng && this._currentView === qv && (t.preventDefault(),
                    a && (this._toggleStepTabIndex(s, a),
                    this._toggleOutlineStyles(s, a),
                    a.focus())),
                    t.keyCode === eg && this._currentView === qv && (t.preventDefault(),
                    r && (this._toggleStepTabIndex(s, r),
                    this._toggleOutlineStyles(s, r),
                    r.focus())),
                    t.keyCode === sg) {
                        const t = B.findOne(`.${dy}`, this._steps[0]);
                        this._toggleStepTabIndex(s, t),
                        this._toggleOutlineStyles(s, t),
                        t.focus()
                    }
                    if (t.keyCode === og) {
                        const t = this._steps[this._steps.length - 1]
                          , e = B.findOne(`.${dy}`, t);
                        this._toggleStepTabIndex(s, e),
                        this._toggleOutlineStyles(s, e),
                        e.focus()
                    }
                    t.keyCode !== ag && t.keyCode !== rg || (t.preventDefault(),
                    this.changeStep(this._steps.indexOf(e))),
                    9 === t.keyCode && (this._toggleStepTabIndex(s, o),
                    this._toggleOutlineStyles(s, !1),
                    o.focus())
                }
                ),
                I.on(e, iy, t => {
                    const e = B.parents(t.currentTarget, `.${cy}`)[0]
                      , i = B.findOne(`.${dy}`, e)
                      , n = B.findOne(`.${dy}`, this.activeStep);
                    9 === t.keyCode && (this._toggleStepTabIndex(i, n),
                    this._toggleOutlineStyles(!1, n),
                    n.focus())
                }
                )
            }
            )
        }
        _bindMobileButtons() {
            const t = B.findOne(`.${Ty}`, this._element)
              , e = B.findOne(`.${Sy}`, this._element);
            I.on(t, sy, () => this.prevStep()),
            I.on(e, sy, () => this.nextStep())
        }
        _unbindMobileButtons() {
            const t = B.findOne(`.${Ty}`, this._element)
              , e = B.findOne(`.${Sy}`, this._element);
            I.off(t, sy, () => this.prevStep()),
            I.off(e, sy, () => this.nextStep())
        }
        _toggleStepTabIndex(t, e) {
            t && t.setAttribute("tabIndex", -1),
            e && e.setAttribute("tabIndex", 0)
        }
        _validateActiveStepRequiredElements() {
            return B.find("[required]", this.activeStep).every(t => !0 === t.checkValidity())
        }
        _validateStep(t) {
            const e = this._steps.length;
            let i = !0;
            t === this._activeStepIndex && (i = !1),
            (t >= e || t < 0) && (i = !1);
            const n = I.trigger(this.activeStep, ay, {
                currentStep: this._activeStepIndex,
                nextStep: t
            });
            if (this._options.stepperLinear) {
                const n = t - this.activeStepIndex - 1;
                if (t > this._activeStepIndex + 1) {
                    let t = B.next(this.activeStep, "li")[0];
                    for (let e = 0; e < n; e++)
                        t.classList.contains("stepper-completed") || (t.classList.add("stepper-invalid"),
                        i = !1),
                        t = B.next(t, "li")[0]
                }
                t < this._activeStepIndex && (this._validateActiveStepRequiredElements() || this.activeStep.classList.remove("stepper-completed")),
                (t > this._activeStepIndex || t === e - 1) && (this.activeStep.classList.add("was-validated"),
                this._validateActiveStepRequiredElements() || (this._toggleInvalid(this._activeStepIndex),
                I.trigger(this.activeStep, ly, {
                    currentStep: this._activeStepIndex,
                    nextStep: t
                }),
                this._currentView !== qv ? setTimeout( () => {
                    this._setHeight(this.activeStep)
                }
                , 210) : setTimeout( () => {
                    this._setSingleStepHeight(this.activeStep)
                }
                , 210),
                i = !1))
            }
            return t > this._activeStepIndex && n.defaultPrevented && (i = !1),
            this._options.stepperNoEditable && this._steps[t].classList.contains(_y) && (i = !1),
            i
        }
        _updateProgressBar() {
            const t = this._steps.length;
            B.findOne(`.${ky}`, this._element).style.width = (this._activeStepIndex + 1) / t * 100 + "%"
        }
        _toggleOutlineStyles(t, e) {
            t && (t.style.outline = ""),
            e && (e.style.outline = "revert")
        }
        _toggleDisabled() {
            this._toggleStepClass(this._activeStepIndex, "add", _y),
            this._toggleStepClass(this._activeStepIndex, "add", this._options.stepperDisabled)
        }
        _toggleActive(t) {
            this._toggleStepClass(t, "add", fy),
            this._toggleStepClass(this._activeStepIndex, "remove", fy),
            this._toggleStepClass(t, "add", this._options.stepperActive),
            this._toggleStepClass(this._activeStepIndex, "remove", this._options.stepperActive)
        }
        _toggleCompleted(t) {
            this._toggleStepClass(t, "add", gy),
            this._toggleStepClass(t, "remove", my),
            this._toggleStepClass(t, "add", this._options.stepperCompleted),
            this._toggleStepClass(t, "remove", this._options.stepperInvalid)
        }
        _toggleInvalid(t) {
            this._toggleStepClass(t, "add", my),
            this._toggleStepClass(t, "remove", gy),
            this._toggleStepClass(t, "add", this._options.stepperInvalid),
            this._toggleStepClass(t, "remove", this._options.stepperCompleted)
        }
        _setOptional() {
            this._steps.forEach(t => {
                if (N.getDataAttribute(t, "stepper-optional")) {
                    B.findOne(`.${uy}`, t).setAttribute("data-mdb-content", "Optional")
                }
            }
            )
        }
        _hideInactiveSteps() {
            this._steps.forEach(t => {
                t.classList.contains(fy) || this._hideElement(B.findOne(`.${py}`, t))
            }
            )
        }
        _setValidation() {
            const t = B.findOne(".needs-validation.stepper-form", this._element);
            I.on(t, ty, e => {
                t.checkValidity() || (e.preventDefault(),
                e.stopPropagation()),
                this._steps.forEach( (t, e) => {
                    this._validateStep(e) || (this._toggleInvalid(e),
                    I.trigger(this.activeStep, ly))
                }
                )
            }
            , !1)
        }
        _setHeight(t) {
            const e = B.findOne(`.${py}`, t)
              , i = B.findOne(`.${Cy}`, this._element)
              , n = getComputedStyle(e)
              , s = i ? getComputedStyle(i) : "";
            let o;
            o = this._currentView === Zv ? B.findOne(`.${wy}`, this._element) : B.findOne(`.${dy}`, t);
            const a = getComputedStyle(o)
              , r = e.offsetHeight + parseFloat(n.marginTop) + parseFloat(n.marginBottom)
              , l = o.offsetHeight + parseFloat(a.marginTop) + parseFloat(a.marginBottom)
              , h = s ? i.offsetHeight + parseFloat(s.marginTop) + parseFloat(s.marginBottom) : 0;
            this._element.style.height = `${l + r + h}px`
        }
        _hideElement(t) {
            B.parents(t, `.${cy}`)[0].classList.contains(fy) || this._currentView === qv ? t.classList.add(vy) : t.style.display = "none"
        }
        _showElement(t) {
            this._currentView === qv ? t.classList.remove(vy) : t.style.display = "block"
        }
        _animateHorizontalStep(t) {
            if (!this._animations)
                return this._steps.forEach( (e, i) => {
                    const n = B.findOne(`.${py}`, e);
                    i !== t && this._hideElement(n)
                }
                ),
                void this._setHeight(this._steps[t]);
            const e = t > this._activeStepIndex
              , i = B.findOne(`.${py}`, this._steps[t])
              , n = B.findOne(`.${py}`, this.activeStep);
            let s, o;
            this._steps.forEach( (e, i) => {
                const n = B.findOne(`.${py}`, e);
                this._clearStepAnimation(n),
                i !== t && i !== this._activeStepIndex && this._hideElement(n)
            }
            ),
            e ? (o = "slide-out-left",
            s = "slide-in-right") : (o = "slide-out-right",
            s = "slide-in-left"),
            this._animations && (n.classList.add(o, "animation", "fast"),
            i.classList.add(s, "animation", "fast")),
            this._setHeight(this._steps[t]),
            I.one(n, oy, t => {
                this._clearStepAnimation(t.target),
                this._hideElement(t.target)
            }
            ),
            I.one(i, oy, t => {
                this._clearStepAnimation(t.target)
            }
            )
        }
        _animateVerticalStep(t) {
            const e = B.findOne(`.${py}`, this._steps[t])
              , i = B.findOne(`.${py}`, this.activeStep);
            this._hideElement(i),
            this._showElement(e)
        }
        _clearStepAnimation(t) {
            t.classList.remove("slide-out-left", "slide-in-right", "slide-out-right", "slide-in-left", "animation", "fast")
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                let i = s.getData(this, Xv);
                const n = "object" == typeof t && t;
                if ((i || !/dispose|hide/.test(t)) && (i || (i = new Dy(this,n)),
                "string" == typeof t)) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
    }
    const $y = "sticky"
      , Iy = "mdb.sticky"
      , Ly = "animation"
      , Py = `.${Iy}`
      , Ry = `activated${Py}`
      , Ny = `deactivated${Py}`
      , By = {
        stickyActiveClass: "",
        stickyAnimationSticky: "",
        stickyAnimationUnsticky: "",
        stickyBoundary: !1,
        stickyDelay: 0,
        stickyDirection: "down",
        stickyMedia: 0,
        stickyOffset: 0,
        stickyPosition: "top"
    }
      , Hy = {
        stickyActiveClass: "string",
        stickyAnimationSticky: "string",
        stickyAnimationUnsticky: "string",
        stickyBoundary: "(boolean|string)",
        stickyDelay: "number",
        stickyDirection: "string",
        stickyMedia: "number",
        stickyOffset: "number",
        stickyPosition: "string"
    };
    class Fy extends ao {
        constructor(t, e) {
            super(t),
            this._hiddenElement = null,
            this._elementPositionStyles = {},
            this._scrollDirection = "",
            this._isSticked = !1,
            this._elementOffsetTop = null,
            this._scrollTop = 0,
            this._pushPoint = "",
            this._manuallyDeactivated = !1,
            this._element && (this._options = this._getConfig(e),
            this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor))
        }
        static get NAME() {
            return $y
        }
        dispose() {
            const {stickyAnimationUnsticky: t} = this._options;
            let {animationDuration: e} = getComputedStyle(this._element);
            e = "" !== t ? 1e3 * parseFloat(e) : 0,
            this._disableSticky(),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            setTimeout( () => {
                super.dispose()
            }
            , e)
        }
        activate() {
            this._isSticked || (this._createHiddenElement(),
            this._enableSticky(),
            this._changeBoundaryPosition(),
            this._isSticked = !0,
            this._manuallyDeactivated = !1)
        }
        deactivate() {
            this._isSticked && (this._disableSticky(),
            this._isSticked = !1,
            this._manuallyDeactivated = !0)
        }
        _init() {
            this._userActivityListener()
        }
        _userActivityListener() {
            I.on(window, "resize", () => {
                this._updateElementPosition(),
                this._updateElementOffset()
            }
            ),
            I.on(window, "scroll", () => {
                if (!this._element)
                    return;
                if (window.innerWidth <= this._options.stickyMedia)
                    return;
                if (this._manuallyDeactivated)
                    return;
                const t = document.documentElement
                  , {stickyDirection: e} = this._options
                  , i = window.pageYOffset || t.scrollTop;
                this._updateElementOffset(),
                this._updatePushPoint(),
                this._updateScrollDirection(i),
                this._clearInProgressAnimations();
                const n = [this._scrollDirection, "both"].includes(e)
                  , s = this._pushPoint <= i
                  , o = s && !this._isSticked && n
                  , a = (!s || !n) && this._isSticked;
                o && (this._createHiddenElement(),
                this._enableSticky(),
                this._changeBoundaryPosition(),
                this._isSticked = !0),
                a && (this._disableSticky(),
                this._isSticked = !1),
                this._isSticked && (this._updatePosition({
                    styles: this._elementPositionStyles
                }),
                this._changeBoundaryPosition()),
                this._scrollTop = i <= 0 ? 0 : i
            }
            )
        }
        _updatePushPoint() {
            "top" === this._options.stickyPosition ? this._pushPoint = this._elementOffsetTop - this._options.stickyDelay : this._pushPoint = this._elementOffsetTop + this._element.height - document.body.scrollHeight + this._options.stickyDelay
        }
        _updateElementOffset() {
            this._hiddenElement ? this._elementOffsetTop = this._hiddenElement.offsetTop : this._elementOffsetTop = this._element.offsetTop,
            this._options.stickyAnimationUnsticky && (this._elementOffsetTop += this._element.height || 0)
        }
        _updateElementPosition() {
            if (this._hiddenElement) {
                const {left: t} = this._hiddenElement.getBoundingClientRect();
                this._elementPositionStyles = {
                    left: `${t}px`
                }
            } else
                this._elementPositionStyles = {};
            this._setStyle(this._element, this._elementPositionStyles)
        }
        _updateScrollDirection(t) {
            t > this._scrollTop ? this._scrollDirection = "down" : this._scrollDirection = "up"
        }
        _clearInProgressAnimations() {
            const t = "up" === this._scrollDirection
              , e = this._element.classList.contains(this._options.stickyAnimationUnsticky)
              , i = window.scrollY <= this._elementOffsetTop - this._element.height;
            t && e && i && (this._removeUnstickyAnimation(),
            this._resetStyles(),
            this._removeHiddenElement())
        }
        _enableSticky() {
            const {stickyActiveClass: t, stickyAnimationSticky: e, stickyAnimationUnsticky: i, stickyOffset: n, stickyPosition: s} = this._options
              , {height: o, left: a, width: r} = this._element.getBoundingClientRect();
            "" !== e && (N.addClass(this._element, Ly),
            this._toggleClass(e, i, this._element)),
            this._toggleClass(t, "", this._element),
            this._setStyle(this._element, {
                top: "top" === s && `${0 + n}px`,
                bottom: "bottom" === s && `${0 + n}px`,
                height: `${o}px`,
                width: `${r}px`,
                left: `${a}px`,
                zIndex: "100",
                position: "fixed"
            }),
            this._hiddenElement.hidden = !1,
            I.trigger(this._element, Ry)
        }
        _changeBoundaryPosition() {
            const {stickyPosition: t, stickyBoundary: e, stickyOffset: i} = this._options
              , {height: n} = this._element.getBoundingClientRect()
              , s = {
                height: this._element.parentElement.getBoundingClientRect().height,
                ...this._getOffset(this._element.parentElement)
            };
            let o;
            const a = B.findOne(e);
            o = a ? this._getOffset(a).top - n - i : s.height + s[t] - n - i;
            const r = "top" === t
              , l = "bottom" === t
              , h = e
              , c = o < 0
              , d = o > s.height - n;
            let u;
            r && (u = c && h ? {
                top: `${i + o}px`
            } : {
                top: `${i + 0}px`
            }),
            l && (u = c && h ? {
                bottom: `${i + o}px`
            } : d && h ? {
                bottom: `${i + s.bottom}px`
            } : {
                bottom: `${i + 0}px`
            }),
            this._setStyle(this._element, u)
        }
        _disableSticky() {
            const {stickyActiveClass: t, stickyAnimationUnsticky: e, stickyAnimationSticky: i} = this._options;
            let {animationDuration: n} = getComputedStyle(this._element);
            n = "" !== e ? 1e3 * parseFloat(n) : 0,
            "" !== this._options.stickyAnimationUnsticky && (N.addClass(this._element, Ly),
            this._toggleClass(e, i, this._element)),
            setTimeout( () => {
                this._element.classList.contains(i) || (this._removeUnstickyAnimation(),
                this._resetStyles(),
                this._removeHiddenElement(),
                this._toggleClass("", t, this._element),
                I.trigger(this._element, Ny))
            }
            , n)
        }
        _createHiddenElement() {
            this._hiddenElement || (this._hiddenElement = this._copyElement(this._element))
        }
        _removeHiddenElement() {
            this._hiddenElement && (this._hiddenElement.remove(),
            this._hiddenElement = null)
        }
        _removeUnstickyAnimation() {
            this._toggleClass("", this._options.stickyAnimationUnsticky, this._element)
        }
        _resetStyles() {
            this._setStyle(this._element, {
                top: null,
                bottom: null,
                position: null,
                left: null,
                zIndex: null,
                width: null,
                height: null
            })
        }
        _updatePosition({styles: t}) {
            this._setStyle(this._element, t)
        }
        _toggleClass(t, e, i) {
            t && N.addClass(i, t),
            e && N.removeClass(i, e)
        }
        _getOffset(t) {
            const e = N.offset(t)
              , i = t.getBoundingClientRect()
              , n = 0 === e.left && 0 === e.top ? 0 : window.innerHeight - i.bottom;
            return {
                ...e,
                bottom: n
            }
        }
        _copyElement(t) {
            const {height: e, width: i} = t.getBoundingClientRect()
              , n = t.cloneNode(!1);
            return n.hidden = !0,
            this._setStyle(n, {
                height: `${e}px`,
                width: `${i}px`,
                opacity: "0"
            }),
            t.parentElement.insertBefore(n, t),
            n
        }
        _getConfig(t={}) {
            const e = N.getDataAttributes(this._element);
            return t = {
                ...By,
                ...e,
                ...t
            },
            d($y, t, Hy),
            t
        }
        _setStyle(t, e) {
            Object.keys(e).forEach(i => {
                t.style[i] = e[i]
            }
            )
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                let i = s.getData(this, Iy);
                const n = "object" == typeof t && t;
                if ((i || !/dispose|hide/.test(t)) && (i || (i = new Fy(this,n)),
                "string" == typeof t)) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
    }
    class zy {
        _getCoordinates(t) {
            const [e] = t.touches;
            return {
                x: e.clientX,
                y: e.clientY
            }
        }
        _getDirection({x: t, y: e}) {
            return {
                x: {
                    direction: t < 0 ? "left" : "right",
                    value: Math.abs(t)
                },
                y: {
                    direction: e < 0 ? "up" : "down",
                    value: Math.abs(e)
                }
            }
        }
        _getOrigin({x: t, y: e}, {x: i, y: n}) {
            return {
                x: t - i,
                y: e - n
            }
        }
        _getDistanceBetweenTwoPoints(t, e, i, n) {
            return Math.hypot(e - t, n - i)
        }
        _getMidPoint({x1: t, x2: e, y1: i, y2: n}) {
            return {
                x: (t + e) / 2,
                y: (i + n) / 2
            }
        }
        _getVectorLength({x1: t, x2: e, y1: i, y2: n}) {
            return Math.sqrt((e - t) ** 2 + (n - i) ** 2)
        }
        _getRightMostTouch(t) {
            let e = null;
            const i = Number.MIN_VALUE;
            return t.forEach(t => {
                t.clientX > i && (e = t)
            }
            ),
            e
        }
        _getAngle(t, e, i, n) {
            return Math.atan2(n - e, i - t)
        }
        _getAngularDistance(t, e) {
            return e - t
        }
        _getCenterXY({x1: t, x2: e, y1: i, y2: n}) {
            return {
                x: t + (e - t) / 2,
                y: i + (n - i) / 2
            }
        }
        _getPinchTouchOrigin(t) {
            const [e,i] = t
              , n = {
                x1: e.clientX,
                x2: i.clientX,
                y1: e.clientY,
                y2: i.clientY
            };
            return [this._getVectorLength(n), this._getCenterXY(n)]
        }
        _getPosition({x1: t, x2: e, y1: i, y2: n}) {
            return {
                x1: t,
                x2: e,
                y1: i,
                y2: n
            }
        }
    }
    const jy = {
        time: 250,
        pointers: 1
    }
      , Wy = "press";
    class Vy extends zy {
        constructor(t, e={}) {
            super(),
            this._element = t,
            this._options = {
                ...jy,
                ...e
            },
            this._timer = null
        }
        static get NAME() {
            return Wy
        }
        handleTouchStart(t) {
            const {time: e, pointers: i} = this._options;
            t.touches.length === i && (this._timer = setTimeout( () => {
                I.trigger(this._element, Wy, {
                    touch: t,
                    time: e
                }),
                I.trigger(this._element, "pressup", {
                    touch: t
                })
            }
            , e))
        }
        handleTouchEnd() {
            clearTimeout(this._timer)
        }
    }
    const Yy = {
        threshold: 10,
        direction: "all"
    };
    class Xy {
        constructor(t, e) {
            this._element = t,
            this._startPosition = null,
            this._options = {
                ...Yy,
                ...e
            }
        }
        handleTouchStart(t) {
            this._startPosition = this._getCoordinates(t)
        }
        handleTouchMove(t) {
            if (!this._startPosition)
                return;
            const e = this._getCoordinates(t)
              , i = {
                x: e.x - this._startPosition.x,
                y: e.y - this._startPosition.y
            }
              , n = this._getDirection(i);
            if ("all" === this._options.direction) {
                if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)
                    return;
                const e = n.y.value > n.x.value ? n.y.direction : n.x.direction;
                return I.trigger(this._element, `swipe${e}`, {
                    touch: t
                }),
                I.trigger(this._element, "swipe", {
                    touch: t,
                    direction: e
                }),
                void (this._startPosition = null)
            }
            const s = "left" === this._options.direction || "right" === this._options ? "x" : "y";
            n[s].direction === this._options.direction && n[s].value > this._options.threshold && (I.trigger(this._element, `swipe${n[s].direction}`, {
                touch: t
            }),
            this._startPosition = null)
        }
        handleTouchEnd() {
            this._startPosition = null
        }
        _getCoordinates(t) {
            const [e] = t.touches;
            return {
                x: e.clientX,
                y: e.clientY
            }
        }
        _getDirection(t) {
            return {
                x: {
                    direction: t.x < 0 ? "left" : "right",
                    value: Math.abs(t.x)
                },
                y: {
                    direction: t.y < 0 ? "up" : "down",
                    value: Math.abs(t.y)
                }
            }
        }
    }
    const Ky = {
        threshold: 20,
        direction: "all",
        pointers: 1
    }
      , Uy = "pan"
      , qy = `${Uy}start`
      , Zy = `${Uy}end`
      , Gy = `${Uy}move`;
    class Qy extends zy {
        constructor(t, e={}) {
            super(),
            this._element = t,
            this._options = {
                ...Ky,
                ...e
            },
            this._startTouch = null
        }
        static get NAME() {
            return Uy
        }
        handleTouchStart(t) {
            this._startTouch = this._getCoordinates(t),
            this._movedTouch = t,
            I.trigger(this._element, qy, {
                touch: t
            })
        }
        handleTouchMove(t) {
            "touchmove" === t.type && t.preventDefault();
            const {threshold: e, direction: i} = this._options
              , n = this._getCoordinates(t)
              , s = this._getCoordinates(this._movedTouch)
              , o = this._getOrigin(n, this._startTouch)
              , a = this._getOrigin(n, s)
              , r = this._getDirection(o)
              , l = this._getDirection(a)
              , {x: h, y: c} = r;
            if ("all" === i && (c.value > e || h.value > e)) {
                const e = c.value > h.value ? c.direction : h.direction;
                I.trigger(this._element, `${Uy}${e}`, {
                    touch: t
                }),
                I.trigger(this._element, Uy, {
                    ...a,
                    touch: t
                })
            }
            const d = "left" === i || "right" === i ? "x" : "y";
            l[d].direction === i && r[d].value > e && I.trigger(this._element, `${Uy}${i}`, {
                touch: t,
                [d]: n[d] - s[d]
            }),
            this._movedTouch = t,
            I.trigger(this._element, Gy, {
                touch: t
            })
        }
        handleTouchEnd(t) {
            "touchend" === t.type && t.preventDefault(),
            this._movedTouch = null,
            this._startTouch = null,
            I.trigger(this._element, Zy, {
                touch: t
            })
        }
    }
    const Jy = {
        pointers: 2,
        threshold: 10
    }
      , tx = "pinch"
      , ex = `${tx}end`
      , ix = `${tx}start`
      , nx = `${tx}move`;
    class sx extends zy {
        constructor(t, e={}) {
            super(),
            this._element = t,
            this._options = {
                ...Jy,
                ...e
            },
            this._startTouch = null,
            this._origin = null,
            this._touch = null,
            this._math = null,
            this._ratio = null
        }
        static get NAME() {
            return tx
        }
        get isNumber() {
            return "number" == typeof this._startTouch && "number" == typeof this._touch && !isNaN(this._startTouch) && !isNaN(this._touch)
        }
        handleTouchStart(t) {
            if (t.touches.length !== this._options.pointers)
                return;
            "touchstart" === t.type && t.preventDefault();
            const [e,i] = this._getPinchTouchOrigin(t.touches);
            this._touch = e,
            this._origin = i,
            this._startTouch = this._touch,
            I.trigger(this._element, ix, {
                touch: t,
                ratio: this._ratio,
                origin: this._origin
            })
        }
        handleTouchMove(t) {
            const {threshold: e, pointers: i} = this._options;
            t.touches.length === i && ("touchmove" === t.type && t.preventDefault(),
            this._touch = this._getPinchTouchOrigin(t.touches)[0],
            this._ratio = this._touch / this._startTouch,
            this.isNumber && (this._origin.x > e || this._origin.y > e) && (this._startTouch = this._touch,
            I.trigger(this._element, tx, {
                touch: t,
                ratio: this._ratio,
                origin: this._origin
            }),
            I.trigger(this._element, nx, {
                touch: t,
                ratio: this._ratio,
                origin: this._origin
            })))
        }
        handleTouchEnd(t) {
            this.isNumber && (this._startTouch = null,
            I.trigger(this._element, ex, {
                touch: t,
                ratio: this._ratio,
                origin: this._origin
            }))
        }
    }
    const ox = {
        interval: 500,
        time: 250,
        taps: 1,
        pointers: 1
    };
    class ax extends zy {
        constructor(t, e) {
            super(),
            this._element = t,
            this._options = {
                ...ox,
                ...e
            },
            this._timer = null,
            this._tapCount = 0
        }
        static get NAME() {
            return "tap"
        }
        handleTouchStart(t) {
            const {x: e, y: i} = this._getCoordinates(t)
              , {interval: n, taps: s, pointers: o} = this._options;
            return t.touches.length === o && (this._tapCount += 1,
            1 === this._tapCount && (this._timer = setTimeout( () => {
                this._tapCount = 0
            }
            , n)),
            this._tapCount === s && (clearTimeout(this._timer),
            this._tapCount = 0,
            I.trigger(this._element, "tap", {
                touch: t,
                origin: {
                    x: e,
                    y: i
                }
            }))),
            t
        }
        handleTouchEnd() {}
        handleTouchMove() {}
    }
    const rx = {
        angle: 0,
        pointers: 2
    }
      , lx = "rotate"
      , hx = `${lx}end`
      , cx = `${lx}start`;
    class dx extends zy {
        constructor(t, e) {
            super(),
            this._element = t,
            this._options = {
                ...rx,
                ...e
            },
            this._origin = {}
        }
        static get NAME() {
            return lx
        }
        handleTouchStart(t) {
            "touchstart" === t.type && t.preventDefault(),
            t.touches.length < 2 || (this._startTouch = t,
            this._origin = {},
            I.trigger(this._element, cx, {
                touch: t
            }))
        }
        handleTouchMove(t) {
            let e, i;
            "touchmove" === t.type && t.preventDefault();
            const n = t.touches;
            if (1 === n.length && 1 === this._options.pointers) {
                const {left: t, top: s, width: o, height: a} = this._element.getBoundingClientRect();
                e = {
                    x: t + o / 2,
                    y: s + a / 2
                },
                i = n[0]
            } else {
                if (2 !== t.touches.length || 2 !== this._options.pointers)
                    return;
                {
                    const [n,s] = t.touches
                      , o = {
                        x1: s.clientX,
                        x2: n.clientX,
                        y1: s.clientY,
                        y2: n.clientY
                    };
                    e = this._getMidPoint(o),
                    i = this._getRightMostTouch(t.touches)
                }
            }
            this.currentAngle = this._getAngle(e.x, e.y, i.clientX, i.clientY),
            this._origin.initialAngle ? (this._origin.change = this._getAngularDistance(this._origin.previousAngle, this.currentAngle),
            this._origin.distance += this._origin.change) : (this._origin.initialAngle = this._origin.previousAngle = this.currentAngle,
            this._origin.distance = this._origin.change = 0),
            this._origin.previousAngle = this.currentAngle,
            this.rotate = {
                currentAngle: this.currentAngle,
                distance: this._origin.distance,
                change: this._origin.change
            },
            I.trigger(this._element, lx, {
                ...this.rotate,
                touch: t
            })
        }
        handleTouchEnd(t) {
            "touchend" === t.type && t.preventDefault(),
            this._origin = {},
            I.trigger(this._element, hx, {
                touch: t
            })
        }
    }
    class ux extends ao {
        constructor(t, e="swipe", i={}) {
            super(t),
            this._options = this._getConfig(i),
            this._event = this._options.event || e,
            this.swipe = "swipe" === this._event ? new Xy(t,this._options) : null,
            this.press = "press" === this._event ? new Vy(t,this._options) : null,
            this.pan = "pan" === this._event ? new Qy(t,this._options) : null,
            this.pinch = "pinch" === this._event ? new sx(t,this._options) : null,
            this.tap = "tap" === this._event ? new ax(t,this._options) : null,
            this.rotate = "rotate" === this._event ? new dx(t,this._options) : null,
            this._touchStartHandler = this._handleTouchStart.bind(this),
            this._touchMoveHandler = this._handleTouchMove.bind(this),
            this._touchEndHandler = this._handleTouchEnd.bind(this),
            this.init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return "touch"
        }
        dispose() {
            I.off(this._element, "touchstart", this._touchStartHandler),
            I.off(this._element, "touchmove", this._touchMoveHandler),
            I.off(this._element, "touchend", this._touchEndHandler),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        init() {
            I.on(this._element, "touchstart", this._touchStartHandler),
            I.on(this._element, "touchmove", this._touchMoveHandler),
            I.on(this._element, "touchend", this._touchEndHandler)
        }
        _getConfig(t) {
            return t = {
                ...N.getDataAttributes(this._element),
                ...t
            }
        }
        _handleTouchStart(t) {
            this[this._event].handleTouchStart(t)
        }
        _handleTouchMove(t) {
            this[this._event].handleTouchMove && this[this._event].handleTouchMove(t)
        }
        _handleTouchEnd(t) {
            this[this._event].handleTouchEnd(t)
        }
        static jQueryInterface(t) {
            return this.each(function() {
                let e = s.getData(this, "mdb.touch");
                const i = "object" == typeof t && t;
                if ((e || !/dispose/.test(t)) && (e || (e = new ux(this,i)),
                "string" == typeof t)) {
                    if (void 0 === e[t])
                        throw new TypeError(`No method named "${t}"`);
                    return e[t]
                }
            })
        }
    }
    const px = "smoothScroll"
      , fx = `mdb.${px}`
      , gx = `.${fx}`
      , mx = {
        container: "string",
        offset: "number",
        easing: "string",
        duration: "number"
    }
      , _x = {
        container: "body",
        offset: 0,
        easing: "linear",
        duration: 500
    }
      , bx = `scrollStart${gx}`
      , vx = `scrollEnd${gx}`
      , yx = `scrollCancel${gx}`;
    class xx extends ao {
        constructor(t, e={}) {
            super(t),
            this._options = this._getConfig(e),
            this._href = this._element.getAttribute("href"),
            this.isCancel = !1,
            this._element && (this._setup(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor))
        }
        static get NAME() {
            return px
        }
        get isWindow() {
            return "body" === this._options.container
        }
        get containerToScroll() {
            return this.isWindow ? document.documentElement : B.findOne(this._options.container, document.documentElement)
        }
        get elFromHrefExist() {
            return !!B.findOne(this._href, this.containerToScroll)
        }
        get offsetFromEl() {
            const t = this.containerToScroll.scrollTop
              , e = B.findOne(this._href, this.containerToScroll);
            if (this.isWindow)
                return N.offset(e).top - this._options.offset + t;
            return e.getBoundingClientRect().y - this.containerToScroll.getBoundingClientRect().y - this._options.offset + t
        }
        get easingFunction() {
            const t = this._options.easing
              , e = `_motion${t[0].toUpperCase()}${t.slice(1)}`;
            return this[e] ? this[e] : this._motionLinear
        }
        dispose() {
            I.off(this._element, "click"),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        cancelScroll() {
            this.isCancel = !0
        }
        _getConfig(t) {
            const e = {
                ..._x,
                ...N.getDataAttributes(this._element),
                ...t
            };
            return d(px, e, mx),
            e
        }
        _inViewport() {
            if (this.isWindow)
                return !0;
            const t = this.containerToScroll.getBoundingClientRect();
            return t.top >= 0 && t.bottom <= (window.innerHeight || document.documentElement.clientHeight)
        }
        _setup() {
            const t = void 0 !== this._href
              , e = this._href.includes("#");
            t && e && this.elFromHrefExist && (this._scrollOnClickEvent(),
            this._preventNativeScroll())
        }
        _scrollOnClickEvent() {
            I.on(this._element, "click", t => {
                this._handleClick(t)
            }
            )
        }
        _handleClick(t) {
            t.preventDefault(),
            this.isCancel = !1,
            I.trigger(this._element, bx);
            const e = this.containerToScroll
              , i = this.containerToScroll.scrollTop
              , n = this.offsetFromEl
              , s = 1 / this._options.duration
              , o = 4.25
              , a = this.easingFunction;
            this._inViewport() ? this._scrollOnNextTick(e, i, n, 0, s, o, a) : (this._scrollOnNextTick(document.documentElement, document.documentElement.scrollTop, this.containerToScroll.offsetTop, 0, s, o, a),
            setTimeout( () => {
                this._scrollOnNextTick(e, i, n, 0, s, o, a),
                this.isCancel = !1
            }
            , this._options.duration))
        }
        _scrollOnNextTick(t, e, i, n, s, o, a) {
            if (n < 0 || n > 1 || s <= 0 || this.isCancel)
                return this.isCancel ? (this.isInViewport && (this.isCancel = !1),
                void I.trigger(this._element, yx)) : (I.trigger(this._element, vx),
                void (t.scrollTop = i));
            t.scrollTo({
                top: e - (e - i) * a(n)
            }),
            n += s * o,
            setTimeout( () => {
                this._scrollOnNextTick(t, e, i, n, s, o, a)
            }
            )
        }
        _preventDefault(t) {
            t.preventDefault()
        }
        _preventNativeScroll() {
            let e = !1;
            try {
                window.addEventListener("test", null, Object.defineProperty({}, "passive", {
                    get: () => e = !0
                }))
            } catch (t) {
                this._scrollError = t
            }
            const i = !!e && {
                passive: !1
            }
              , n = "onwheel"in _("div") ? "wheel" : "mousewheel";
            this.isWindow && (this._deleteScrollOnStart(i, n),
            this._addScrollOnEnd(i, n),
            this._addScrollOnCancel(i, n))
        }
        _deleteScrollOnStart(t, e) {
            I.on(this._element, "scrollStart.mdb.smoothScroll", () => {
                window.addEventListener(e, this._preventDefault, t),
                window.addEventListener("touchmove", this._preventDefault, t)
            }
            )
        }
        _addScrollOnEnd(t, e) {
            I.on(this._element, "scrollEnd.mdb.smoothScroll", () => {
                window.removeEventListener(e, this._preventDefault, t),
                window.removeEventListener("touchmove", this._preventDefault, t)
            }
            )
        }
        _addScrollOnCancel(t, e) {
            I.on(this._element, "scrollCancel.mdb.smoothScroll", () => {
                window.removeEventListener(e, this._preventDefault, t),
                window.removeEventListener("touchmove", this._preventDefault, t)
            }
            )
        }
        _motionLinear(t) {
            return t
        }
        _motionEaseInQuad(t) {
            return t * t
        }
        _motionEaseInCubic(t) {
            return t * t * t
        }
        _motionEaseInQuart(t) {
            return t * t * t * t
        }
        _motionEaseInQuint(t) {
            return t * t * t * t * t
        }
        _motionEaseInOutQuad(t) {
            return t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1
        }
        _motionEaseInOutCubic(t) {
            return (t /= .5) < 1 ? t * t * t / 2 : ((t -= 2) * t * t + 2) / 2
        }
        _motionEaseInOutQuart(t) {
            return (t /= .5) < 1 ? .5 * t * t * t * t : -((t -= 2) * t * t * t - 2) / 2
        }
        _motionEaseInOutQuint(t) {
            return (t /= .5) < 1 ? t * t * t * t * t / 2 : ((t -= 2) * t * t * t * t + 2) / 2
        }
        _motionEaseOutQuad(t) {
            return -t * (t - 2)
        }
        _motionEaseOutCubic(t) {
            return --t * t * t + 1
        }
        _motionEaseOutQuart(t) {
            return -(--t * t * t * t - 1)
        }
        _motionEaseOutQuint(t) {
            return --t * t * t * t * t + 1
        }
        static jQueryInterface(t) {
            return this.each(function() {
                let e = s.getData(this, fx);
                if (e || (e = new xx(this,"object" == typeof t && t)),
                "string" == typeof t) {
                    if (void 0 === e[t])
                        throw new TypeError(`No method named "${t}"`);
                    e[t](this)
                }
            })
        }
    }
    const wx = "perfectScrollbar"
      , Cx = "mdb"
      , kx = "ps"
      , Sx = [{
        mdb: `scrollX.${Cx}.${kx}`,
        ps: "ps-scroll-x"
    }, {
        mdb: `scrollY.${Cx}.${kx}`,
        ps: "ps-scroll-y"
    }, {
        mdb: `scrollUp.${Cx}.${kx}`,
        ps: "ps-scroll-up"
    }, {
        mdb: `scrollDown.${Cx}.${kx}`,
        ps: "ps-scroll-down"
    }, {
        mdb: `scrollLeft.${Cx}.${kx}`,
        ps: "ps-scroll-left"
    }, {
        mdb: `scrollRight.${Cx}.${kx}`,
        ps: "ps-scroll-right"
    }, {
        mdb: `scrollXEnd.${Cx}.${kx}`,
        ps: "ps-x-reach-end"
    }, {
        mdb: `scrollYEnd.${Cx}.${kx}`,
        ps: "ps-y-reach-end"
    }, {
        mdb: `scrollXStart.${Cx}.${kx}`,
        ps: "ps-x-reach-start"
    }, {
        mdb: `scrollYStart.${Cx}.${kx}`,
        ps: "ps-y-reach-start"
    }]
      , Tx = {
        handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
        wheelSpeed: 1,
        wheelPropagation: !0,
        swipeEasing: !0,
        minScrollbarLength: null,
        maxScrollbarLength: null,
        scrollingThreshold: 1e3,
        useBothWheelAxes: !1,
        suppressScrollX: !1,
        suppressScrollY: !1,
        scrollXMarginOffset: 0,
        scrollYMarginOffset: 0
    }
      , Ax = {
        handlers: "(string|array)",
        wheelSpeed: "number",
        wheelPropagation: "boolean",
        swipeEasing: "boolean",
        minScrollbarLength: "(number|null)",
        maxScrollbarLength: "(number|null)",
        scrollingThreshold: "number",
        useBothWheelAxes: "boolean",
        suppressScrollX: "boolean",
        suppressScrollY: "boolean",
        scrollXMarginOffset: "number",
        scrollYMarginOffset: "number"
    };
    class Ex extends ao {
        constructor(t, e={}) {
            super(t),
            this._options = this._getConfig(e),
            this.perfectScrollbar = null,
            this._element && N.addClass(this._element, "perfect-scrollbar"),
            this.init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return wx
        }
        _getConfig(t) {
            const e = N.getDataAttributes(this._element);
            return void 0 !== e.handlers && (e.handlers = e.handlers.split(" ")),
            t = {
                ...Tx,
                ...e,
                ...t
            },
            d(wx, t, Ax),
            t
        }
        dispose() {
            this.removeEvent(Sx),
            this.perfectScrollbar.destroy(),
            this.perfectScrollbar = null,
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        init() {
            this.perfectScrollbar = new Qf(this._element,this._options),
            this._initEvents(Sx)
        }
        update() {
            return this.perfectScrollbar.update()
        }
        _initEvents(t=[]) {
            t.forEach( ({ps: t, mdb: e}) => I.on(this._element, t, t => I.trigger(this._element, e, {
                e: t
            })))
        }
        removeEvent(t) {
            let e = [];
            "string" == typeof t && (e = Sx.filter( ({mdb: e}) => e === t)),
            e.forEach( ({ps: t, mdb: e}) => {
                I.off(this._element, t),
                I.off(this._element, e)
            }
            )
        }
        static jQueryInterface(t) {
            return this.each(function() {
                let e = s.getData(this, "mdb.perfectScrollbar");
                const i = "object" == typeof t && t;
                if ((e || !/dispose|hide/.test(t)) && (e || (e = new Ex(this,i)),
                "string" == typeof t)) {
                    if (void 0 === e[t])
                        throw new TypeError(`No method named "${t}"`);
                    e[t]()
                }
            })
        }
    }
    const Mx = "loading"
      , Ox = "loading-spinner"
      , Dx = {
        backdrop: "(null|boolean)",
        backdropColor: "string",
        backdropOpacity: "(number|string)",
        backdropID: "string",
        delay: "(null|number)",
        loader: "string",
        parentSelector: "(null|string)",
        loadingIcon: "boolean",
        loadingText: "boolean",
        scroll: "boolean"
    }
      , $x = {
        backdrop: !0,
        backdropColor: "rgba(0, 0, 0)",
        backdropOpacity: .4,
        backdropID: "",
        delay: null,
        loader: "",
        parentSelector: null,
        scroll: !0,
        loadingText: !0,
        loadingIcon: !0
    };
    class Ix extends ao {
        constructor(t, e={}) {
            super(t),
            this._options = this._getConfig(e),
            this._backdropElement = null,
            this._parentElement = B.findOne(this._options.parentSelector),
            this._loadingIcon = B.findOne(".loading-icon", this._element),
            this._loadingText = B.findOne(".loading-text", this._element),
            this.init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return Mx
        }
        init() {
            const t = this._loadingIcon.cloneNode(!0)
              , e = this._loadingText.cloneNode(!0);
            this._removeElementsOnStart(),
            setTimeout( () => {
                N.addClass(this._element, Ox),
                this._setBackdrop(),
                this._setLoadingIcon(t),
                this._setLoadingText(e),
                this._setScrollOption(),
                I.trigger(this._element, "show.mdb.loading")
            }
            , this._options.delay)
        }
        dispose() {
            N.removeClass(this._element, Ox);
            const t = this._options.delay;
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            setTimeout( () => {
                this._removeBackdrop(),
                setTimeout( () => {
                    super.dispose()
                }
                , t)
            }
            , t)
        }
        _setBackdrop() {
            const {backdrop: t} = this._options;
            t && (this._backdropElement = function({backdropID: t, backdropOpacity: e, backdropColor: i}) {
                const n = _("div");
                return N.addClass(n, "loading-backdrop"),
                n.id = t,
                N.addStyle(n, {
                    opacity: e,
                    backgroundColor: i
                }),
                n
            }(this._options),
            null !== this._parentElement ? (N.addClass(this._element, "position-absolute"),
            N.addClass(this._parentElement, "position-relative"),
            N.addClass(this._backdropElement, "position-absolute"),
            this._parentElement.appendChild(this._backdropElement)) : (N.addClass(this._element, "position-fixed"),
            document.body.appendChild(this._backdropElement),
            document.body.appendChild(this._element)))
        }
        _removeBackdrop() {
            const {backdrop: t} = this._options;
            t && (null !== this._parentElement ? (N.removeClass(this._element, "position-absolute"),
            N.removeClass(this._parentElement, "position-relative"),
            this._backdropElement.remove()) : (this._backdropElement.remove(),
            this._element.remove()))
        }
        _setLoadingIcon(t) {
            this._options.loadingIcon ? (this._element.appendChild(t),
            t.id = this._options.loader) : t.remove()
        }
        _setLoadingText(t) {
            this._options.loadingText ? this._element.appendChild(t) : t.remove()
        }
        _removeElementsOnStart() {
            null !== this._element && (this._loadingIcon.remove(),
            this._loadingText.remove())
        }
        _setScrollOption() {
            if (this._options.scroll) {
                if (null === this._parentElement)
                    return void (document.body.style.overflow = "");
                N.addStyle(this._parentElement, {
                    overflow: ""
                })
            } else {
                if (null === this._parentElement)
                    return void (document.body.style.overflow = "hidden");
                N.addStyle(this._parentElement, {
                    overflow: "hidden"
                })
            }
        }
        _getConfig(t) {
            const e = {
                ...$x,
                ...N.getDataAttributes(this._element),
                ...t
            };
            return d(Mx, e, Dx),
            e
        }
        static jQueryInterface(t) {
            return this.each(function() {
                let e = s.getData(this, "mdb.loading");
                if (e || (e = new Ix(this,"object" == typeof t && t)),
                "string" == typeof t) {
                    if (void 0 === e[t])
                        throw new TypeError(`No method named "${t}"`);
                    e[t](this)
                }
            })
        }
    }
    const Lx = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"])
      , Px = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi
      , Rx = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i
      , Nx = (t, e) => {
        const i = t.nodeName.toLowerCase();
        if (e.includes(i))
            return !Lx.has(i) || Boolean(t.nodeValue.match(Px) || t.nodeValue.match(Rx));
        const n = e.filter(t => t instanceof RegExp);
        for (let s = 0, o = n.length; s < o; s++)
            if (n[s].test(i))
                return !0;
        return !1
    }
      , Bx = {
        "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
        a: ["target", "href", "title", "rel"],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ["src", "srcset", "alt", "title", "width", "height"],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
    };
    function Hx(t, e, i) {
        if (!t.length)
            return t;
        if (i && "function" == typeof i)
            return i(t);
        const n = (new window.DOMParser).parseFromString(t, "text/html")
          , s = Object.keys(e)
          , o = [].concat(...n.body.querySelectorAll("*"));
        for (let a = 0, r = o.length; a < r; a++) {
            const t = o[a]
              , i = t.nodeName.toLowerCase();
            if (-1 === s.indexOf(i)) {
                t.parentNode.removeChild(t);
                continue
            }
            const n = [].concat(...t.attributes)
              , r = [].concat(e["*"] || [], e[i] || []);
            n.forEach(e => {
                Nx(e, r) || t.removeAttribute(e.nodeName)
            }
            )
        }
        return n.body.innerHTML
    }
    function Fx(t=[], e) {
        const i = e.displayValue
          , n = e.itemContent;
        return `\n    ${t.map( (t, e) => `<li data-mdb-index="${e}" role="option" class="autocomplete-item">${"function" == typeof n ? Hx(n(t), Bx, null) : i(t)}</li>`).join("")}\n  `
    }
    const zx = {
        autoSelect: !1,
        container: "body",
        customContent: "",
        debounce: 300,
        displayValue: t => t,
        filter: null,
        itemContent: null,
        listHeight: 190,
        noResults: "No results found",
        threshold: 0,
        itemsListLabel: "Autocomplete options"
    }
      , jx = {
        autoSelect: "boolean",
        container: "string",
        customContent: "string",
        debounce: "number",
        displayValue: "function",
        filter: "(null|function)",
        itemContent: "(null|function)",
        listHeight: "number",
        noResults: "string",
        threshold: "number",
        itemsListLabel: "string"
    }
      , Wx = "autocomplete"
      , Vx = "mdb.autocomplete"
      , Yx = "active"
      , Xx = "focused"
      , Kx = "focusing"
      , Ux = "open"
      , qx = ".autocomplete-items-list"
      , Zx = ".autocomplete-item"
      , Gx = `.${Vx}`
      , Qx = `close${Gx}`
      , Jx = `open${Gx}`
      , tw = `itemSelect${Gx}`
      , ew = `update${Gx}`;
    class iw extends ao {
        constructor(t, e) {
            super(t),
            this._options = this._getConfig(e),
            this._getContainer(),
            this._input = B.findOne(".form-control", t),
            this._label = B.findOne(".form-label", t),
            this._customContent = B.findOne(".autocomplete-custom-content", t),
            this._loader = function() {
                const t = _("div");
                return N.addClass(t, "autocomplete-loader"),
                N.addClass(t, "spinner-border"),
                t.setAttribute("role", "status"),
                t.innerHTML = '<span class="sr-only">Loading...</span>',
                t
            }(),
            this._popper = null,
            this._debounceTimeoutId = null,
            this._loaderTimeout = null,
            this._activeItemIndex = -1,
            this._activeItem = null,
            this._filteredResults = null,
            this._lastQueryValue = null,
            this._canOpenOnFocus = !0,
            this._isOpen = !1,
            this._outsideClickHandler = this._handleOutsideClick.bind(this),
            this._inputFocusHandler = this._handleInputFocus.bind(this),
            this._userInputHandler = this._handleUserInput.bind(this),
            this._keydownHandler = this._handleKeydown.bind(this),
            this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return Wx
        }
        get filter() {
            return this._options.filter
        }
        get dropdown() {
            return B.findOne(".autocomplete-dropdown", this._dropdownContainer)
        }
        get items() {
            return B.find(Zx, this._dropdownContainer)
        }
        get itemsList() {
            return B.findOne(qx, this._dropdownContainer)
        }
        search(t) {
            this._filterResults(t)
        }
        _getContainer() {
            this._container = B.findOne(this._options.container)
        }
        _getConfig(t) {
            const e = N.getDataAttributes(this._element);
            return t = {
                ...zx,
                ...e,
                ...t
            },
            d(Wx, t, jx),
            t
        }
        _init() {
            this._initDropdown(),
            this._setInputAndLabelClasses(),
            this._updateLabelPosition(),
            this._setInputAriaAttributes(),
            this._listenToInputFocus(),
            this._listenToUserInput(),
            this._listenToKeydown()
        }
        _initDropdown() {
            this._dropdownContainerId = this._element.id ? `autocomplete-dropdown-${this._element.id}` : o("autocomplete-dropdown-");
            const t = {
                id: this._dropdownContainerId,
                items: [],
                width: this._input.offsetWidth,
                options: this._options
            };
            if (this._dropdownContainer = function(t) {
                const {id: e, items: i, width: n, options: s} = t
                  , o = _("div");
                N.addClass(o, "autocomplete-dropdown-container"),
                N.addStyle(o, {
                    width: `${n}px`
                }),
                o.setAttribute("id", e);
                const a = _("div");
                N.addClass(a, "autocomplete-dropdown");
                const r = _("ul")
                  , l = s.listHeight;
                N.addClass(r, "autocomplete-items-list"),
                N.addStyle(r, {
                    maxHeight: `${l}px`
                }),
                r.setAttribute("role", "listbox"),
                r.setAttribute("aria-label", s.itemsListLabel),
                r.setAttribute("tabindex", "0");
                const h = Fx(i, s);
                return r.innerHTML = h,
                a.appendChild(r),
                o.appendChild(a),
                o
            }(t),
            "" !== this._options.customContent) {
                const t = Hx(this._options.customContent, Bx, null);
                this.dropdown.insertAdjacentHTML("beforeend", t)
            }
        }
        _setInputAndLabelClasses() {
            N.addClass(this._input, "autocomplete-input"),
            this._label && N.addClass(this._label, "autocomplete-label")
        }
        _setInputAriaAttributes() {
            this._input.setAttribute("role", "combobox"),
            this._input.setAttribute("aria-controls", this._dropdownContainerId),
            this._input.setAttribute("aria-expanded", !1),
            this._input.setAttribute("aria-owns", this._dropdownContainerId),
            this._input.setAttribute("aria-haspopup", !0),
            this._input.setAttribute("autocomplete", "off")
        }
        _updateLabelPosition() {
            this._label && ("" !== this._input.value || this._isOpen ? N.addClass(this._label, Yx) : N.removeClass(this._label, Yx))
        }
        _listenToInputFocus() {
            I.on(this._input, "focus", this._inputFocusHandler)
        }
        _handleInputFocus(t) {
            const {value: e} = t.target
              , i = this._options.threshold;
            this._canOpenOnFocus ? e.length < i || (this._lastQueryValue !== e ? this._filterResults(e) : this.open()) : this._canOpenOnFocus = !0
        }
        _listenToWindowResize() {
            this._windowResizeHandler = this._handleWindowResize.bind(this),
            I.on(window, "resize", this._windowResizeHandler)
        }
        _handleWindowResize() {
            this._dropdownContainer && this._updateDropdownWidth()
        }
        _updateDropdownWidth() {
            const t = this._input.offsetWidth;
            N.addStyle(this._dropdownContainer, {
                width: `${t}px`
            })
        }
        _listenToUserInput() {
            I.on(this._input, "input", this._userInputHandler)
        }
        _handleUserInput(t) {
            const {value: e} = t.target
              , i = this._options.threshold
              , n = this._options.debounce;
            this.filter && (e.length < i ? this._isOpen && this.close() : this._debounceFilter(e, n))
        }
        _debounceFilter(t, e) {
            this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId),
            this._debounceTimeoutId = setTimeout( () => {
                this._filterResults(t)
            }
            , e)
        }
        _filterResults(t) {
            this._lastQueryValue = t;
            const e = this.filter(t);
            this._isPromise(e) ? this._asyncUpdateResults(e) : this._updateResults(e)
        }
        _isPromise(t) {
            return !!t && "function" == typeof t.then
        }
        _asyncUpdateResults(t) {
            this._resetActiveItem(),
            this._showLoader(),
            t.then(t => {
                this._updateResults(t),
                this._loaderTimeout = setTimeout( () => {
                    this._hideLoader(),
                    this._loaderTimeout = null
                }
                , 300)
            }
            )
        }
        _resetActiveItem() {
            const t = this._activeItem;
            t && (N.removeClass(t, "active"),
            this._activeItem = null,
            this._activeItemIndex = -1)
        }
        _showLoader() {
            this._element.appendChild(this._loader)
        }
        _hideLoader() {
            B.findOne(".autocomplete-loader", this._element) && this._element.removeChild(this._loader)
        }
        _updateResults(t) {
            this._resetActiveItem(),
            this._filteredResults = t,
            I.trigger(this._element, ew, {
                results: t
            });
            const e = B.findOne(".autocomplete-items-list", this._dropdownContainer)
              , i = Fx(t, this._options)
              , n = `<li role="option" aria-disabled="true" class="autocomplete-item autocomplete-no-results">${this._options.noResults}</li>`;
            0 === t.length && "" !== this._options.noResults ? e.innerHTML = n : e.innerHTML = i,
            this._isOpen || this.open(),
            this._popper && this._popper.forceUpdate()
        }
        _listenToKeydown() {
            I.on(this._element, "keydown", this._keydownHandler)
        }
        _handleKeydown(t) {
            this._isOpen ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t)
        }
        _handleOpenKeydown(t) {
            var e, i;
            const n = t.keyCode;
            if (9 === n && this._options.autoSelect && this._selectActiveItem(),
            n === lg || n === eg && t.altKey)
                return this._input.value || N.addClass(this._input, Kx),
                this.close(),
                this._input.focus(),
                void (this._input.value || setTimeout( () => {
                    N.removeClass(this._input, Kx)
                }
                , 10));
            if (n === lg || n === eg && t.altKey || 9 === n)
                return this.close(),
                void this._input.focus();
            switch (n) {
            case ng:
                this._setActiveItem(this._activeItemIndex + 1),
                this._scrollToItem(this._activeItem);
                break;
            case eg:
                this._setActiveItem(this._activeItemIndex - 1),
                this._scrollToItem(this._activeItem);
                break;
            case sg:
                if (t.shiftKey) {
                    const t = 0
                      , e = this._input.selectionStart;
                    this._input.setSelectionRange(t, e)
                } else
                    (null == (e = this._filteredResults) ? void 0 : e.length) > 0 && this._isOpen ? (this._setActiveItem(0),
                    this._scrollToItem(this._activeItem)) : this._input.setSelectionRange(0, 0);
                break;
            case og:
                if (t.shiftKey) {
                    const t = this._input.selectionStart
                      , e = this._input.value.length;
                    this._input.setSelectionRange(t, e)
                } else if ((null == (i = this._filteredResults) ? void 0 : i.length) > 0 && this._isOpen)
                    this._setActiveItem(this.items.length - 1),
                    this._scrollToItem(this._activeItem);
                else {
                    const t = this._input.value.length;
                    this._input.setSelectionRange(t, t)
                }
                break;
            case ag:
                if (t.preventDefault(),
                this._activeItemIndex > -1) {
                    const t = this._filteredResults[this._activeItemIndex];
                    this._handleSelection(t)
                }
                return;
            default:
                return
            }
            t.preventDefault()
        }
        _setActiveItem(t) {
            const e = this.items;
            e[t] && this._updateActiveItem(e[t], t)
        }
        _updateActiveItem(t, e) {
            const i = this._activeItem;
            i && N.removeClass(i, "active"),
            N.addClass(t, "active"),
            this._activeItemIndex = e,
            this._activeItem = t
        }
        _scrollToItem(t) {
            if (!t)
                return;
            const e = this.itemsList
              , i = e.offsetHeight
              , n = this.items.indexOf(t)
              , s = t.offsetHeight
              , o = e.scrollTop;
            if (n > -1) {
                const t = n * s
                  , a = t + s > o + i
                  , r = t < o;
                e.scrollTop = r ? t : a ? t - i + s : o
            }
        }
        _handleClosedKeydown(t) {
            "Enter" === t.key && t.preventDefault();
            const e = t.keyCode;
            (e === ag || e === ng || e === ng) && this.open()
        }
        open() {
            null === this._lastQueryValue && this._filterResults("");
            const t = I.trigger(this._element, Jx);
            this._isOpen || t.defaultPrevented || (this._updateDropdownWidth(),
            this._listenToWindowResize(),
            this._popper = Ln(this._element, this._dropdownContainer, {
                modifiers: [{
                    name: "offset",
                    options: {
                        offset: [0, 1]
                    }
                }]
            }),
            this._container.appendChild(this._dropdownContainer),
            this._listenToOutsideClick(),
            this._listenToItemsClick(),
            setTimeout( () => {
                N.addClass(this.dropdown, Ux),
                this._isOpen = !0,
                this._input.setAttribute("aria-expanded", !0),
                this._setInputActiveStyles(),
                this._updateLabelPosition()
            }
            , 0))
        }
        _listenToOutsideClick() {
            I.on(document, "click", this._outsideClickHandler)
        }
        _handleOutsideClick(t) {
            const e = this._input === t.target
              , i = t.target === this._dropdownContainer
              , n = this._dropdownContainer && this._dropdownContainer.contains(t.target);
            e || i || n || this.close()
        }
        _listenToItemsClick() {
            const t = B.findOne(qx, this._dropdownContainer);
            I.on(t, "click", this._handleItemsClick.bind(this))
        }
        _handleItemsClick(t) {
            const e = B.closest(t.target, Zx)
              , i = N.getDataAttribute(e, "index")
              , n = this._filteredResults[i];
            this._handleSelection(n)
        }
        _selectActiveItem() {
            const t = this._filteredResults[this._activeItemIndex];
            if (!t)
                return;
            const e = this._options.displayValue(t);
            I.trigger(this._element, tw, {
                value: t
            }).defaultPrevented || setTimeout( () => {
                this._canOpenOnFocus = !1,
                this._updateInputValue(e),
                this._updateLabelPosition()
            }
            , 0)
        }
        _handleSelection(t) {
            if (!t)
                return;
            const e = this._options.displayValue(t);
            I.trigger(this._element, tw, {
                value: t
            }).defaultPrevented || setTimeout( () => {
                this._canOpenOnFocus = !1,
                this._updateInputValue(e),
                this._updateLabelPosition(),
                this._input.focus(),
                this.close()
            }
            , 0)
        }
        _updateInputValue(t) {
            this._input.value = t
        }
        _setInputActiveStyles() {
            N.addClass(this._input, Xx)
        }
        close() {
            const t = I.trigger(this._element, Qx);
            this._isOpen && !t.defaultPrevented && (this._resetActiveItem(),
            this._removeDropdownEvents(),
            N.removeClass(this.dropdown, Ux),
            I.on(this.dropdown, "transitionend", this._handleDropdownTransitionEnd.bind(this)),
            N.removeClass(this._input, Xx),
            N.removeClass(this._input, Yx),
            !this._input.value && this._label && N.removeClass(this._label, Yx))
        }
        _removeDropdownEvents() {
            const t = B.findOne(qx, this._dropdownContainer);
            I.off(t, "click"),
            I.off(document, "click", this._outsideClickHandler),
            I.off(window, "resize", this._windowResizeHandler)
        }
        _handleDropdownTransitionEnd(t) {
            this._isOpen && t && "opacity" === t.propertyName && (this._popper.destroy(),
            this._dropdownContainer && this._container.removeChild(this._dropdownContainer),
            this._isOpen = !1,
            this._input.setAttribute("aria-expanded", !1),
            I.off(this.dropdown, "transitionend"))
        }
        dispose() {
            this._isOpen && this.close(),
            this._removeInputAndElementEvents(),
            this._dropdownContainer.remove(),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _removeInputAndElementEvents() {
            I.off(this._input, "focus", this._inputFocusHandler),
            I.off(this._input, "input", this._userInputHandler),
            I.off(this._element, "keydown", this._keydownHandler)
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                let i = s.getData(this, Vx);
                const n = "object" == typeof t && t;
                if ((i || !/dispose/.test(t)) && (i || (i = new iw(this,n)),
                "string" == typeof t)) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
    }
    b(iw);
    const nw = ".bs.modal"
      , sw = `hide${nw}`
      , ow = `hidePrevented${nw}`
      , aw = `hidden${nw}`
      , rw = `show${nw}`
      , lw = `shown${nw}`
      , hw = `resize${nw}`
      , cw = `click.dismiss${nw}`
      , dw = `mousedown.dismiss${nw}`
      , uw = `keydown.dismiss${nw}`
      , pw = "modal-open"
      , fw = "show"
      , gw = "modal-static"
      , mw = {
        backdrop: !0,
        focus: !0,
        keyboard: !0
    }
      , _w = {
        backdrop: "(boolean|string)",
        focus: "boolean",
        keyboard: "boolean"
    };
    let bw = class t extends Ct {
        constructor(t, e) {
            super(t, e),
            this._dialog = Yt.findOne(".modal-dialog", this._element),
            this._backdrop = this._initializeBackDrop(),
            this._focustrap = this._initializeFocusTrap(),
            this._isShown = !1,
            this._isTransitioning = !1,
            this._scrollBar = new ce,
            this._addEventListeners()
        }
        static get Default() {
            return mw
        }
        static get DefaultType() {
            return _w
        }
        static get NAME() {
            return "modal"
        }
        toggle(t) {
            return this._isShown ? this.hide() : this.show(t)
        }
        show(t) {
            if (this._isShown || this._isTransitioning)
                return;
            _t.trigger(this._element, rw, {
                relatedTarget: t
            }).defaultPrevented || (this._isShown = !0,
            this._isTransitioning = !0,
            this._scrollBar.hide(),
            document.body.classList.add(pw),
            this._adjustDialog(),
            this._backdrop.show( () => this._showElement(t)))
        }
        hide() {
            if (!this._isShown || this._isTransitioning)
                return;
            _t.trigger(this._element, sw).defaultPrevented || (this._isShown = !1,
            this._isTransitioning = !0,
            this._focustrap.deactivate(),
            this._element.classList.remove(fw),
            this._queueCallback( () => this._hideModal(), this._element, this._isAnimated()))
        }
        dispose() {
            _t.off(window, nw),
            _t.off(this._dialog, nw),
            this._backdrop.dispose(),
            this._focustrap.deactivate(),
            super.dispose()
        }
        handleUpdate() {
            this._adjustDialog()
        }
        _initializeBackDrop() {
            return new Gt({
                isVisible: Boolean(this._config.backdrop) && Boolean(!this._config.modalNonInvasive),
                isAnimated: this._isAnimated()
            })
        }
        _initializeFocusTrap() {
            return new oe({
                trapElement: this._element
            })
        }
        _showElement(t) {
            document.body.contains(this._element) || document.body.append(this._element),
            this._element.style.display = "block",
            this._element.removeAttribute("aria-hidden"),
            this._element.setAttribute("aria-modal", !0),
            this._element.setAttribute("role", "dialog"),
            this._element.scrollTop = 0;
            const e = Yt.findOne(".modal-body", this._dialog);
            e && (e.scrollTop = 0),
            G(this._element),
            this._element.classList.add(fw);
            this._queueCallback( () => {
                this._config.focus && this._focustrap.activate(),
                this._isTransitioning = !1,
                _t.trigger(this._element, lw, {
                    relatedTarget: t
                })
            }
            , this._dialog, this._isAnimated())
        }
        _addEventListeners() {
            _t.on(this._element, uw, t => {
                "Escape" === t.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition())
            }
            ),
            _t.on(window, hw, () => {
                this._isShown && !this._isTransitioning && this._adjustDialog()
            }
            ),
            _t.on(this._element, dw, t => {
                _t.one(this._element, cw, e => {
                    this._element === t.target && this._element === e.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition())
                }
                )
            }
            )
        }
        _hideModal() {
            this._element.style.display = "none",
            this._element.setAttribute("aria-hidden", !0),
            this._element.removeAttribute("aria-modal"),
            this._element.removeAttribute("role"),
            this._isTransitioning = !1,
            this._backdrop.hide( () => {
                document.body.classList.remove(pw),
                this._resetAdjustments(),
                this._scrollBar.reset(),
                _t.trigger(this._element, aw)
            }
            )
        }
        _isAnimated() {
            return this._element.classList.contains("fade")
        }
        _triggerBackdropTransition() {
            if (_t.trigger(this._element, ow).defaultPrevented)
                return;
            const t = this._element.scrollHeight > document.documentElement.clientHeight
              , e = this._element.style.overflowY;
            "hidden" === e || this._element.classList.contains(gw) || (t || (this._element.style.overflowY = "hidden"),
            this._element.classList.add(gw),
            this._queueCallback( () => {
                this._element.classList.remove(gw),
                this._queueCallback( () => {
                    this._element.style.overflowY = e
                }
                , this._dialog)
            }
            , this._dialog),
            this._element.focus())
        }
        _adjustDialog() {
            const t = this._element.scrollHeight > document.documentElement.clientHeight
              , e = this._scrollBar.getWidth()
              , i = e > 0;
            if (i && !t) {
                const t = Q() ? "paddingLeft" : "paddingRight";
                this._element.style[t] = `${e}px`
            }
            if (!i && t) {
                const t = Q() ? "paddingRight" : "paddingLeft";
                this._element.style[t] = `${e}px`
            }
        }
        _resetAdjustments() {
            this._element.style.paddingLeft = "",
            this._element.style.paddingRight = ""
        }
        static jQueryInterface(e, i) {
            return this.each(function() {
                const n = t.getOrCreateInstance(this, e);
                if ("string" == typeof e) {
                    if (void 0 === n[e])
                        throw new TypeError(`No method named "${e}"`);
                    n[e](i)
                }
            })
        }
    }
    ;
    const vw = (t, e) => {
        B.find(t).forEach(t => {
            const i = N.getDataAttribute(t, e);
            void 0 === i ? t.style.removeProperty(e) : (N.removeDataAttribute(t, e),
            t.style[e] = i)
        }
        )
    }
      , yw = "modal"
      , xw = "bs.modal"
      , ww = `.${xw}`
      , Cw = "modal-non-invasive-open"
      , kw = "modal-non-invasive-show"
      , Sw = ".modal-content"
      , Tw = `show${ww}`
      , Aw = `shown${ww}`
      , Ew = `hidden${ww}`
      , Mw = [{
        name: "show",
        parametersToCopy: ["relatedTarget"]
    }, {
        name: "shown",
        parametersToCopy: ["relatedTarget"]
    }, {
        name: "hide"
    }, {
        name: "hidePrevented"
    }, {
        name: "hidden"
    }]
      , Ow = {
        backdrop: !0,
        keyboard: !0,
        focus: !0,
        modalNonInvasive: !1
    }
      , Dw = {
        backdrop: "(boolean|string)",
        keyboard: "boolean",
        focus: "boolean",
        modalNonInvasive: "boolean"
    };
    class $w extends bw {
        constructor(t, e) {
            super(t, e),
            this._config = this._getConfig(e),
            this._modalContentRect = "",
            this._modalContentComputedStyles = "",
            this._isNonInvasive = this._config.modalNonInvasive,
            this._isScrollable = "",
            this._isBottomRight = "",
            this._isBottomLeft = "",
            this._isTopRight = "",
            this._isTopLeft = "",
            this._isSideTopModal = "",
            this._isSideBottomModal = "",
            this._isSideModal = "",
            this._isModalBottom = "",
            this._isNonInvasive && (this._config.backdrop = !1,
            this._config.focus = !1,
            this._isBodyOverflowing = !0,
            this._onModalShow(),
            this._onModalShown(),
            this._onModalHidden(),
            this._listenToWindowResize()),
            s.setData(t, xw, this),
            this._bindMdbEvents(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return yw
        }
        dispose() {
            I.off(this._element, Tw),
            I.off(this._element, Aw),
            I.off(this._element, "hide.bs.modal"),
            I.off(this._element, Ew),
            I.off(this._element, "hidePrevented.bs.modal"),
            I.off(window, "resize", this._windowResizeHandler),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _onModalShow() {
            I.on(this._element, Tw, () => {
                this._addNonInvasiveClass()
            }
            )
        }
        _onModalShown() {
            I.on(this._element, Aw, () => {
                const t = B.findOne(Sw, this._element);
                this._isScrollable = B.findOne(".modal-dialog-scrollable", this._element),
                this._isBottomRight = B.findOne(".modal-bottom-right", this._element),
                this._isBottomLeft = B.findOne(".modal-bottom-left", this._element),
                this._isTopRight = B.findOne(".modal-top-right", this._element),
                this._isTopLeft = B.findOne(".modal-top-left", this._element),
                this._isSideTopModal = this._isTopLeft || this._isTopRight,
                this._isSideBottomModal = this._isBottomLeft || this._isBottomRight,
                this._isSideModal = this._isSideTopModal || this._isSideBottomModal,
                this._isModalBottom = B.findOne(".modal-bottom", this._element),
                this._modalContentRect = t.getBoundingClientRect(),
                this._modalContentComputedStyles = window.getComputedStyle(t),
                this._modalDialogComputedStyles = window.getComputedStyle(B.findOne(".modal-dialog", this._element)),
                this._topOffset = parseInt(this._modalDialogComputedStyles.top, 0),
                this._leftOffset = parseInt(this._modalDialogComputedStyles.left, 0),
                this._rightOffset = parseInt(this._modalDialogComputedStyles.right, 0),
                this._bottomOffset = parseInt(this._modalDialogComputedStyles.bottom, 0),
                this._addOpenClass(),
                this._setStyles()
            }
            )
        }
        _listenToWindowResize() {
            this._windowResizeHandler = this._handleWindowResize.bind(this),
            I.on(window, "resize", this._windowResizeHandler)
        }
        _handleWindowResize() {
            const t = B.findOne(Sw, this._element);
            if (this._resetStyles(),
            this._modalContentRect = t.getBoundingClientRect(),
            this._modalContentComputedStyles = window.getComputedStyle(t),
            this._isSideTopModal || this._isSideBottomModal) {
                let t = 0
                  , e = 0;
                return (this._isBottomRight || this._isBottomLeft) && (e = -this._bottomOffset),
                (this._isBottomRight || this._isTopRight) && (t = -this._rightOffset),
                (this._isBottomLeft || this._isTopLeft) && (t = this._leftOffset),
                void this._setStyles(t, e)
            }
            this._setStyles()
        }
        _showBackdrop(t) {
            this._isNonInvasive ? "function" == typeof t && t() : super._showBackdrop(t)
        }
        _adjustDialog() {
            super._adjustDialog();
            const t = document.body.classList.contains(Cw);
            (this._isNonInvasive || t) && (this._isBodyOverflowing = !1),
            this._isNonInvasive && (this._resetAdjustments(),
            vw("body", "overflow"),
            vw("body", "paddingRight"),
            vw(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight"),
            vw(".sticky-top", "marginRight"))
        }
        _onModalHidden() {
            I.on(this._element, Ew, t => {
                t.stopImmediatePropagation(),
                this._removeOpenClass(),
                this._resetStyles(),
                this._removeNonInvasiveClass()
            }
            )
        }
        _addOpenClass() {
            this._element.classList.add(kw)
        }
        _removeOpenClass() {
            this._element.classList.remove(kw)
        }
        _addNonInvasiveClass() {
            document.body.classList.add(Cw)
        }
        _removeNonInvasiveClass() {
            B.findOne(`.modal.show.${kw}`, document.body) ? document.body.classList.add("modal-open") : document.body.classList.remove(Cw)
        }
        _setStyles(t=0, e=0) {
            const i = window.innerWidth >= 992;
            this._element.style.left = `${this._modalContentRect.left + t}px`,
            this._element.style.width = this._modalContentComputedStyles.width,
            this._isScrollable || (this._element.style.height = this._modalContentComputedStyles.height,
            this._element.style.display = ""),
            i && ((this._isSideBottomModal || this._isModalBottom) && (this._element.style.top = `${this._modalContentRect.top + e}px`),
            this._isSideModal && (this._element.style.overflowX = "auto")),
            i || (this._element.style.height = "")
        }
        _resetStyles() {
            this._element.style.left = "",
            this._element.style.top = "",
            this._element.style.height = "",
            this._element.style.width = "",
            this._isScrollable || (this._element.style.display = ""),
            this._isSideModal && (this._element.style.overflowX = "")
        }
        _getConfig(t) {
            let e;
            this._element && (e = l(this._element));
            const i = {
                ...Ow,
                ...N.getDataAttributes(this._element),
                ...N.getDataAttributes(e),
                ...t
            };
            return d(yw, i, Dw),
            i
        }
        _bindMdbEvents() {
            I.extend(this._element, Mw, yw)
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                let i = s.getData(this, xw);
                const n = {
                    ...Ow,
                    ...N.getDataAttributes(this),
                    ..."object" == typeof t && t ? t : {}
                };
                if (i || (i = new $w(this,n)),
                "string" == typeof t) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
    }
    const Iw = "clipboard"
      , Lw = "mdb.clipboard"
      , Pw = {
        clipboardTarget: null
    }
      , Rw = {
        clipboardTarget: "null|string"
    }
      , Nw = `copied${`.${Lw}`}`;
    class Bw extends ao {
        constructor(t, e={}) {
            super(t),
            this._options = e,
            this._element && (this._initCopyHandler = this._initCopy.bind(this),
            this._setup(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor))
        }
        static get NAME() {
            return Iw
        }
        get options() {
            const t = {
                ...Pw,
                ...N.getDataAttributes(this._element),
                ...this._options
            };
            return d(Iw, t, Rw),
            t
        }
        get clipboardTarget() {
            return B.findOne(this.options.clipboardTarget)
        }
        get copyText() {
            const t = this.clipboardTarget.hasAttribute("data-mdb-clipboard-text")
              , e = this.clipboardTarget.value
              , i = this.clipboardTarget.textContent;
            return t ? this.clipboardTarget.getAttribute("data-mdb-clipboard-text") : e || i
        }
        dispose() {
            I.off(this._element, "click", this._initCopyHandler),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _setup() {
            I.on(this._element, "click", this._initCopyHandler)
        }
        _initCopy() {
            const t = this._createNewInput();
            document.body.appendChild(t),
            this._selectInput(t),
            I.trigger(this._element, Nw, {
                copyText: this.copyText
            }),
            t.remove()
        }
        _createNewInput() {
            const t = "TEXTAREA" === this.clipboardTarget.tagName ? "textarea" : "input"
              , e = _(t);
            return e.value = this.copyText,
            N.style(e, {
                left: "-9999px",
                position: "absolute"
            }),
            e
        }
        _selectInput(t) {
            t.select(),
            t.focus(),
            t.setSelectionRange(0, 99999),
            document.execCommand("copy")
        }
        static jQueryInterface(t) {
            return this.each(function() {
                let e = s.getData(this, Lw);
                if (e || (e = new Bw(this,"object" == typeof t && t)),
                "string" == typeof t) {
                    if (void 0 === e[t])
                        throw new TypeError(`No method named "${t}"`);
                    e[t](this)
                }
            })
        }
    }
    const Hw = "chip"
      , Fw = `mdb.${Hw}`
      , zw = ".close"
      , jw = {
        text: "string",
        closeIcon: "boolean",
        img: "object"
    }
      , Ww = {
        text: "",
        closeIcon: !1,
        img: {
            path: "",
            alt: ""
        }
    };
    class Vw extends ao {
        constructor(t, e={}) {
            super(t, e),
            this._options = this._getConfig(e),
            this._element && s.setData(t, Fw, this),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return Hw
        }
        init() {
            this._appendCloseIcon(),
            this._handleDelete(),
            this._handleTextChip(),
            this._handleClickOnChip()
        }
        dispose() {
            I.off(this._element, "click"),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        appendChip() {
            const {text: t, closeIcon: e} = this._options
              , i = ( ({text: t}) => `<div class="chip btn"><span class="text-chip">${t}</span> <i class="close fas fa-times"></i></div>`)({
                text: t,
                closeIcon: e
            });
            return i
        }
        _appendCloseIcon(t=this._element) {
            if (!(B.find(zw, this._element).length > 0) && this._options.closeIcon) {
                const e = _("i");
                e.classList = "close fas fa-times",
                t.insertAdjacentElement("beforeend", e)
            }
        }
        _handleClickOnChip() {
            I.on(this._element, "click", t => {
                const {textContent: e} = t.target
                  , i = {};
                i.tag = e.trim(),
                I.trigger("select.mdb.chip", {
                    event: t,
                    obj: i
                })
            }
            )
        }
        _handleDelete() {
            0 !== B.find(zw, this._element).length && I.on(this._element, "click", zw, () => {
                I.trigger(this._element, "delete.mdb.chips"),
                this._element.remove()
            }
            )
        }
        _handleTextChip() {
            "" === this._element.innerText && (this._element.innerText = this._options.text)
        }
        _getConfig(t) {
            const e = {
                ...Ww,
                ...N.getDataAttributes(this._element),
                ...t
            };
            return d(Hw, e, jw),
            e
        }
        static jQueryInterface(t) {
            return this.each(function() {
                let e = s.getData(this, Fw);
                const i = "object" == typeof t && t;
                if ((e || !/dispose|hide/.test(t)) && (e || (e = new Vw(this,i)),
                "string" == typeof t)) {
                    if (void 0 === e[t])
                        throw new TypeError(`No method named "${t}"`);
                    e[t]()
                }
            })
        }
    }
    const Yw = "chips"
      , Xw = `mdb.${Yw}`
      , Kw = "active"
      , Uw = `${Yw}-initial`
      , qw = `${Yw}-placeholder`
      , Zw = "chip-opacity"
      , Gw = `${Yw}-padding`
      , Qw = `${Yw}-transition`
      , Jw = `${Yw}-input-wrapper`
      , tC = ".chip"
      , eC = `${tC}.${Kw}`
      , iC = "delete.mdb.chips"
      , nC = "select.mdb.chips"
      , sC = {
        inputID: "string",
        parentSelector: "string",
        initialValues: "array",
        editable: "boolean",
        labelText: "string"
    }
      , oC = {
        inputID: "",
        parentSelector: "",
        initialValues: [{
            tag: "init1"
        }, {
            tag: "init2"
        }],
        editable: !1,
        labelText: "Example label"
    };
    class aC extends Vw {
        constructor(t, e={}) {
            super(t, e),
            this._options = this._getConfig(e),
            this.numberClicks = 0,
            this._inputInstance = null,
            this.init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return Yw
        }
        get activeChip() {
            return B.findOne(eC, this._element)
        }
        get input() {
            return B.findOne("input", this._element)
        }
        get allChips() {
            return B.find(tC, this._element)
        }
        get chipsInputWrapper() {
            return B.findOne(`.${Jw}`, this._element)
        }
        init() {
            this._setChipsClass(),
            this._appendInputToElement(qw),
            this._handleInitialValue(),
            this._initializeInput(),
            this._handleInputText(),
            this._handleKeyboard(),
            this._handleChipsOnSelect(),
            this._handleEditable(),
            this._handleChipsFocus(),
            this._handleClicksOnChips()
        }
        dispose() {
            N.removeClass(this._element, "chips"),
            this.allChips.forEach(t => {
                const e = Vw.getInstance(t);
                e && (t.remove(),
                I.off(t, "dblclick"),
                e.dispose())
            }
            ),
            this._inputInstance && this._inputInstance.dispose(),
            this.chipsInputWrapper.remove(),
            I.off(this._element, "click"),
            I.off(this._element, "keypress"),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        _initializeInput() {
            const t = this._element.querySelector(".form-outline");
            this._inputInstance = new go(t).init()
        }
        _setChipsClass() {
            N.addClass(this._element, "chips")
        }
        _handleDeleteEvents(t) {
            const [e] = this.allChips.slice(-1);
            if (null === this.activeChip)
                e.remove(),
                this._handleEvents(t, iC);
            else {
                const e = this.allChips.findIndex(t => t === this.activeChip)
                  , i = this._handleActiveChipAfterRemove(e)
                  , n = [];
                if (null === this.activeChip)
                    return;
                this.activeChip.remove(),
                this._handleEvents(t, iC),
                this.numberClicks = e,
                N.addClass(i, Kw),
                this.allChips.forEach(t => {
                    N.hasClass(t, Kw) && (n.push(t),
                    n.length > 1 && this.allChips.forEach(t => t.remove()))
                }
                )
            }
        }
        _handleUpEvents(t) {
            this.numberClicks += 1,
            this.numberClicks === this.allChips.length + 1 && (this.numberClicks = 0),
            this._handleRightKeyboardArrow(this.numberClicks),
            this._handleEvents(t, "arrowRight.mdb.chips"),
            this._handleEvents(t, "arrowUp.mdb.chips")
        }
        _handleDownEvents(t) {
            this.numberClicks -= 1,
            this.numberClicks <= 0 && (this.numberClicks = this.allChips.length),
            this._handleLeftKeyboardArrow(this.numberClicks),
            this._handleEvents(t, "arrowLeft.mdb.chips"),
            this._handleEvents(t, "arrowDown.mdb.chips")
        }
        _keyboardEvents(t) {
            const {target: e, keyCode: i, ctrlKey: n} = t;
            e.value.length > 0 || 0 === this.allChips.length || (8 === i || 46 === i ? this._handleDeleteEvents(t) : i === ig || i === eg ? this._handleUpEvents(t) : i === tg || i === ng ? this._handleDownEvents(t) : 65 === i && n && this._handleAddActiveClass())
        }
        _handleKeyboard() {
            I.on(this.input, "keydown", t => this._keyboardEvents(t))
        }
        _handleEditable() {
            const {editable: t} = this._options;
            t && this.allChips.forEach(t => {
                I.on(t, "dblclick", e => {
                    const i = B.findOne(".close", t);
                    t.contentEditable = !0,
                    t.focus(),
                    setTimeout( () => {
                        N.addStyle(i, {
                            display: "none"
                        })
                    }
                    , 200),
                    N.addClass(i, "close-opacity"),
                    e.target.textContent,
                    I.trigger(t, nC, {
                        event: e,
                        allChips: this.allChips
                    })
                }
                ),
                I.on(document, "click", ({target: e}) => {
                    const i = B.findOne(".close", t)
                      , n = B.findOne(".text-chip", t)
                      , s = e === t
                      , o = t && t.contains(e);
                    s || o || (t.contentEditable = !1,
                    "" !== n.textContent && setTimeout( () => {
                        N.addStyle(i, {
                            display: "block"
                        }),
                        N.removeClass(i, "close-opacity")
                    }
                    , 160)),
                    "" === n.textContent && (setTimeout( () => {
                        N.addClass(t, Zw)
                    }
                    , 200),
                    setTimeout( () => {
                        t.remove()
                    }
                    , 300))
                }
                )
            }
            )
        }
        _handleRemoveActiveClass() {
            this.allChips.forEach(t => N.removeClass(t, Kw))
        }
        _handleAddActiveClass() {
            this.allChips.forEach(t => N.addClass(t, Kw))
        }
        _handleRightKeyboardArrow(t) {
            this._handleRemoveActiveClass(),
            0 === t && (t = 1),
            this._handleAddActiveClassWithKeyboard(t)
        }
        _handleLeftKeyboardArrow(t) {
            this._handleRemoveActiveClass(),
            this._handleAddActiveClassWithKeyboard(t)
        }
        _handleActiveChipAfterRemove(t) {
            const e = 0 === t ? 1 : t - 1;
            return this.allChips[e]
        }
        _handleClicksOnChips() {
            I.on(this._element, "click", () => {
                0 === this.allChips.length && (N.removeClass(this.chipsInputWrapper, Gw),
                N.removeClass(this.input, Kw))
            }
            )
        }
        _handleTextContent() {
            const t = [];
            return this.allChips.forEach(e => t.push({
                tag: e.textContent.trim()
            })),
            t
        }
        _handleEvents(t, e) {
            const i = this._handleTextContent()
              , n = this.allChips.filter(t => N.hasClass(t, Kw) && t);
            I.trigger(this._element, e, {
                event: t,
                allChips: this.allChips,
                arrOfObjects: i,
                active: n,
                activeObj: {
                    tag: n.length <= 0 ? "" : n[0].textContent.trim()
                }
            })
        }
        _handleChipsFocus() {
            I.on(this._element, "click", ({target: {classList: t}}) => {
                t.contains("chip") || t.contains("close") || t.contains("text-chip") || this.input.focus()
            }
            )
        }
        _handleInitialValue() {
            if (this._appendInputToElement(Uw),
            N.hasClass(this._element, Uw)) {
                const {initialValues: t} = this._options;
                t.forEach( ({tag: t}) => this._handleCreateChip(this.input, t)),
                N.addClass(this.input, Kw)
            }
            this.allChips.length > 0 && (N.addClass(this.chipsInputWrapper, Gw),
            N.addClass(this.chipsInputWrapper, Qw))
        }
        _handleKeysInputToElement(t) {
            const {keyCode: e, target: i} = t;
            if (N.hasClass(i, "chip")) {
                const t = B.findOne(".close", i);
                return void (e === ag && (i.contentEditable = !1,
                "" !== i.textContent ? setTimeout( () => {
                    N.addStyle(t, {
                        display: "block"
                    }),
                    N.removeClass(t, "close-opacity")
                }
                , 160) : "" === i.textContent && (setTimeout( () => {
                    N.addClass(i, Zw)
                }
                , 200),
                setTimeout( () => {
                    i.remove()
                }
                , 300))))
            }
            if (e === ag) {
                if ("" === i.value)
                    return;
                t.preventDefault(),
                this._handleCreateChip(i, i.value),
                this._handleRemoveActiveClass(),
                this.numberClicks = this.allChips.length + 1
            }
            this.allChips.length > 0 ? (N.addClass(this.chipsInputWrapper, Gw),
            N.addClass(this.chipsInputWrapper, Qw)) : N.removeClass(this.chipsInputWrapper, Gw)
        }
        _handleBlurInput(t) {
            const {target: e} = t;
            e.value.length > 0 && this._handleCreateChip(e, e.value),
            this.allChips.length > 0 ? (N.addClass(e, Kw),
            N.addClass(this.chipsInputWrapper, Gw)) : (N.removeClass(e, Kw),
            N.removeClass(this.chipsInputWrapper, Gw)),
            this.allChips.forEach(t => N.removeClass(t, Kw))
        }
        _handleInputText() {
            const t = B.findOne(qw, this._element);
            I.on(this._element, "keypress", t, t => this._handleKeysInputToElement(t)),
            I.on(this.input, "blur", t => this._handleBlurInput(t))
        }
        _appendInputToElement(t) {
            if (!N.hasClass(this._element, t))
                return;
            const e = ( ({inputID: t, labelText: e}) => `<div class="form-outline chips-input-wrapper">\n      <input type="text" id="${t}" class="form-control chips-input" />\n      <label class="form-label" for="${t}">\n        ${e}\n      </label>\n    </div>`)(this._options);
            this._element.insertAdjacentHTML("beforeend", e)
        }
        _handleCreateChip(t, e) {
            if (I.trigger(this._element, "add.mdb.chips", {
                value: e
            }).defaultPrevented)
                return;
            const i = _("div")
              , n = new Vw(i,{
                text: e
            });
            let s;
            if ("" !== this._options.parentSelector) {
                const t = document.querySelector(this._options.parentSelector);
                t.insertAdjacentHTML("beforeend", n.appendChip()),
                s = t
            } else
                t.insertAdjacentHTML("beforebegin", n.appendChip()),
                s = t.parentNode;
            t.value = "",
            B.find(tC, s).forEach(t => {
                let e = Vw.getInstance(t);
                e || (e = new Vw(t),
                e.init())
            }
            ),
            this._handleEditable(),
            I.trigger(this._element, "added.mdb.chips", {
                value: e
            })
        }
        _handleChipsOnSelect() {
            this.allChips.forEach(t => {
                I.on(this._element, "click", e => {
                    I.trigger(t, nC, {
                        event: e,
                        allChips: this.allChips
                    })
                }
                )
            }
            )
        }
        _handleAddActiveClassWithKeyboard(t) {
            let e;
            e = void 0 === this.allChips[t - 1] ? this.allChips[t - 2] : this.allChips[t - 1],
            N.addClass(e, Kw)
        }
        _getConfig(t) {
            const e = {
                ...oC,
                ...N.getDataAttributes(this._element),
                ...t
            };
            return d(Yw, e, sC),
            e
        }
        static jQueryInterface(t) {
            return this.each(function() {
                let e = s.getData(this, Xw);
                const i = "object" == typeof t && t;
                if ((e || !/dispose|hide/.test(t)) && (e || (e = new aC(this,i)),
                "string" == typeof t)) {
                    if (void 0 === e[t])
                        throw new TypeError(`No method named "${t}"`);
                    e[t]()
                }
            })
        }
    }
    const rC = () => '<div class="multi-range-slider-hand">\n  <div class="multi-range-slider-handle"></div>\n</div>'
      , lC = t => "touchmove" === t.type ? t.touches[0].clientX : t.clientX
      , hC = "multiRangeSlider"
      , cC = `mdb.${hC}`
      , dC = `.${cC}`
      , uC = `valueChanged${dC}`
      , pC = `start${dC}`
      , fC = `end${dC}`
      , gC = ".multi-range-slider-hand"
      , mC = "active"
      , _C = "multi-range-slider-horizontal"
      , bC = {
        max: "number",
        min: "number",
        numberOfRanges: "number",
        startValues: "array",
        step: "(string||null||number)",
        tooltip: "boolean"
    }
      , vC = {
        max: 100,
        min: 0,
        numberOfRanges: 2,
        startValues: [0, 100],
        step: null,
        tooltip: !1
    };
    class yC extends ao {
        constructor(t, e={}) {
            super(t),
            this._options = this._getConfig(e),
            this._mousemove = !1,
            this._movingHand = null,
            this.init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return hC
        }
        get hands() {
            return B.find(gC, this._element)
        }
        get connect() {
            return B.findOne(".multi-range-slider-connect", this._element)
        }
        get leftConnectRect() {
            return this.connect.getBoundingClientRect().left
        }
        get handsNoActive() {
            return this.hands.filter(t => !N.hasClass(t, "active"))
        }
        get handActive() {
            return B.findOne(`${gC}.active`, this._element)
        }
        get activeTooltip() {
            return B.findOne(".multi-range-slider-tooltip", this._element)
        }
        get activeTooltipValue() {
            const t = B.findOne(`${gC}.active`, this._element);
            return B.findOne(".multi-range-slider-tooltip-value", t)
        }
        init() {
            this._setClassHorizontalOrVertical(),
            this._setRangeConnectsElement(),
            this._setRangeHandleElements(),
            this._setTransformationOnStart(),
            this._setTooltipToHand(),
            this._addEventListeners()
        }
        dispose() {
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            N.removeClass(this._element, _C),
            this._removeEventListeners(),
            this._removeSliderElements(),
            super.dispose()
        }
        _removeSliderElements() {
            this.hands.forEach(t => {
                t.remove()
            }
            ),
            this.connect.parentNode.remove()
        }
        _addEventListeners() {
            this._onWindowResize = this._handleWindowResize.bind(this),
            this._onConnectMousedown = this._handleClickOnRange.bind(this),
            this._onHandMouseDown = this._handleClickEventOnHand.bind(this),
            this._onDocumentMouseUp = this._handleEndMoveEventDocument.bind(this),
            L.on(this.connect, "mousedown touchstart", this._onConnectMousedown),
            L.on(document, "mouseup touchend", this._onDocumentMouseUp),
            this.hands.forEach(t => {
                L.on(t, "mousedown touchstart", this._onHandMouseDown)
            }
            ),
            I.on(window, "resize", this._onWindowResize)
        }
        _removeEventListeners() {
            L.off(this.connect, "mousedown touchstart", this._onConnectMousedown),
            L.off(document, "mouseup touchend", this._onDocumentMouseUp),
            this.hands.forEach(t => {
                L.off(t, "mousedown touchstart", this._onHandMouseDown)
            }
            ),
            I.off(window, "resize", this._onWindowResize)
        }
        _handleWindowResize() {
            this._setTransformationOnStart()
        }
        _setTransformationOnStart() {
            const {startValues: t, max: e, min: i} = this._options;
            0 === t.length ? this.hands.forEach(t => {
                const e = -t.offsetWidth;
                N.setDataAttribute(t, "translation", Math.round(e)),
                N.addStyle(t, {
                    transform: `translate(${e}px,-25%)`
                })
            }
            ) : this.hands.forEach( (n, s) => {
                if (t[s] > e || t[s] < i)
                    return;
                const o = (t[s] - i) / (e - i) * this.connect.offsetWidth - n.offsetWidth / 2;
                N.setDataAttribute(n, "translation", Math.round(o)),
                N.addStyle(n, {
                    transform: `translate(${o}px,-25%)`
                })
            }
            )
        }
        _handleClickEventOnHand(t) {
            const e = t.target.closest(gC);
            this._disableTextSelection();
            const {max: i, min: n} = this._options;
            this._mousemove = !0;
            const s = lC(t) - this.leftConnectRect - e.offsetWidth / 2
              , o = (lC(t) - this.leftConnectRect) / (this.connect.offsetWidth / (i - n)) % (i - n);
            N.addStyle(e, {
                transform: `translate(${s}px,-25%)`
            }),
            N.setDataAttribute(e, "translation", s),
            this.hands.forEach(t => {
                N.addStyle(t, {
                    zIndex: t === e ? "10" : "1"
                })
            }
            ),
            N.addClass(e, mC),
            this._options.tooltip && (N.addClass(e.children[1], "active"),
            this.activeTooltipValue.innerText = Math.round(o)),
            this._movingHand = e,
            this._onDocumentMouseMove || (this._onDocumentMouseMove = this._handleMouseMoveEventDocument.bind(this)),
            this._onHandMouseUp || (this._onHandMouseUp = this._handleEndMoveEvent.bind(this)),
            L.on(document, "mousemove touchmove", this._onDocumentMouseMove),
            L.on(e, "mouseup touchend", this._onHandMouseUp),
            I.trigger(e, pC, {
                hand: e
            })
        }
        _setClassHorizontalOrVertical() {
            this._element && N.addClass(this._element, "multi-range-slider"),
            N.addClass(this._element, _C)
        }
        _setRangeConnectsElement() {
            this._element.insertAdjacentHTML("afterbegin", '<div class="multi-range-slider-connects">\n<div class="multi-range-slider-connect"></div>\n</div>')
        }
        _setRangeHandleElements() {
            for (let t = 0; t < this._options.numberOfRanges; t++)
                this._element.insertAdjacentHTML("beforeend", rC());
            this.hands.forEach( (t, e) => {
                t.setAttribute("aria-orientation", "horizontal"),
                t.setAttribute("role", "slider"),
                N.setDataAttribute(t, "handle", e)
            }
            )
        }
        _setTooltipToHand() {
            this._options.tooltip && this.hands.forEach(t => {
                return t.insertAdjacentHTML("beforeend", `\n  <span class="multi-range-slider-tooltip">\n    <span class="multi-range-slider-tooltip-value">${e}</span>\n  </span>\n  `);
                var e
            }
            )
        }
        _handleMouseMoveEventDocument(t) {
            const {tooltip: e, step: i} = this._options
              , n = this._movingHand;
            "mousemove" === t.type && t.preventDefault();
            const {max: s, min: o, numberOfRanges: a} = this._options;
            if (N.hasClass(n, mC)) {
                const r = (lC(t) - this.leftConnectRect) / this.connect.offsetWidth * s;
                let l = (lC(t) - this.leftConnectRect) / (this.connect.offsetWidth / (s - o)) % (s - o) + o
                  , h = lC(t) - this.leftConnectRect - n.offsetWidth / 2;
                if (l < o)
                    h = o - n.offsetWidth / 2,
                    l = o;
                else if (r >= s)
                    return;
                if (null !== i) {
                    const t = Math.round(l / i) * i;
                    h = (t - o) / (s - o) * this.connect.offsetWidth - n.offsetWidth / 2,
                    l = t
                }
                let c = !0;
                if (a >= 2)
                    for (const t of this.handsNoActive) {
                        const e = parseFloat(N.getDataAttribute(t, "translation"))
                          , i = parseInt(N.getDataAttribute(t, "handle"), 10)
                          , s = parseInt(N.getDataAttribute(n, "handle"), 10);
                        if (s < i && h > e) {
                            c = !1;
                            break
                        }
                        if (s > i && h < e) {
                            c = !1;
                            break
                        }
                    }
                c && ((Math.round(l) % i === 0 && null !== i || null === i) && (N.addStyle(n, {
                    transform: `translate(${h}px,-25%)`
                }),
                e && (this.activeTooltipValue.innerText = Math.round(l))),
                N.setDataAttribute(n, "translation", h)),
                a < 2 ? I.trigger(this._element, uC, {
                    values: {
                        value: l + o,
                        rounded: Math.round(l + o)
                    }
                }) : this._handleMultiValuesOnRange()
            }
        }
        _handleMultiValuesOnRange() {
            const {max: t, min: e} = this._options
              , i = [];
            this.hands.forEach(n => {
                const s = n.getBoundingClientRect().left - this.leftConnectRect + n.offsetWidth / 2;
                let o = s / (this.connect.offsetWidth / (t - e)) % (t - e);
                s === this.connect.offsetWidth ? o = t : o += e,
                N.setDataAttribute(n, "value", Math.round(10 * o) / 10),
                i.push({
                    value: o
                })
            }
            ),
            I.trigger(this._element, uC, {
                values: {
                    value: i.map( ({value: t}) => t),
                    rounded: i.map( ({value: t}) => Math.round(t))
                }
            })
        }
        _handleEndMoveEventDocument() {
            const t = this._movingHand;
            this._mousemove && (t && L.off(t, "mouseup touchend", this._onHandMouseUp),
            this.hands.forEach(t => {
                N.removeClass(t, mC),
                this._options.tooltip && N.removeClass(t.children[1], "active")
            }
            ),
            this._mousemove = !1),
            I.trigger(t, fC, {
                hand: t
            }),
            this._movingHand = null,
            L.off(document, "mousemove touchmove", this._onDocumentMouseMove),
            this._enableTextSelection()
        }
        _handleEndMoveEvent(t) {
            const e = t.target.closest(gC);
            N.removeClass(e, mC),
            this._options.tooltip && N.removeClass(e.children[1], "active"),
            this._mousemove = !1,
            this._enableTextSelection()
        }
        _handleClickOnRange(t) {
            this.hands.forEach(e => {
                if (this._mousemove = !0,
                this._options.numberOfRanges < 2)
                    N.addClass(e, mC),
                    N.addStyle(e, {
                        transform: `translate(${lC(t) - this.leftConnectRect - e.offsetWidth / 2}px,-25%)`
                    });
                else {
                    const i = this.hands[0];
                    N.addClass(i, mC);
                    const n = lC(t) - this.leftConnectRect - e.offsetWidth / 2
                      , s = parseInt(N.getDataAttribute(i, "handle"), 10);
                    let o = !0;
                    for (let t = 1; t < this.hands.length; t++) {
                        const e = this.hands[t]
                          , i = parseFloat(N.getDataAttribute(e, "translation"))
                          , a = parseInt(N.getDataAttribute(e, "handle"), 10);
                        if (s < a && n > i) {
                            o = !1;
                            break
                        }
                        if (s > a && n < i) {
                            o = !1;
                            break
                        }
                    }
                    o && (N.addStyle(i, {
                        transform: `translate(${n}px,-25%)`
                    }),
                    N.setDataAttribute(i, "translation", n))
                }
            }
            )
        }
        _disableTextSelection() {
            document.body.style.userSelect = "none"
        }
        _enableTextSelection() {
            document.body.style.userSelect = ""
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                let i = s.getData(this, cC);
                const n = "object" == typeof t && t;
                if ((i || !/dispose|hide/.test(t)) && (i || (i = new yC(this,n)),
                "string" == typeof t)) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
        _getConfig(t) {
            const e = {
                ...vC,
                ...N.getDataAttributes(this._element),
                ...t
            };
            return d(hC, e, bC),
            e
        }
    }
    const xC = (t, e) => e.findIndex(e => e === t)
      , wC = "datetimepicker"
      , CC = `mdb.${wC}`
      , kC = "datepicker"
      , SC = "timepicker"
      , TC = `.${SC}`
      , AC = `.${kC}`
      , EC = `[data-mdb-toggle="${wC}"]`
      , MC = `.${`${wC}-toggle-button`}`
      , OC = `.${CC}`
      , DC = `open${OC}`
      , $C = `close${OC}`
      , IC = `valueChanged${OC}`
      , LC = "close.mdb.datepicker"
      , PC = "valueChanged.mdb.datepicker"
      , RC = "valueChanged.mdb.timepicker"
      , NC = _("div")
      , BC = {
        inline: !1,
        toggleButton: !0,
        container: "body",
        disabled: !1,
        disablePast: !1,
        disableFuture: !1,
        defaultTime: "",
        defaultDate: "",
        timepicker: {},
        datepicker: {},
        showFormat: !1
    }
      , HC = {
        inline: "boolean",
        toggleButton: "boolean",
        container: "string",
        disabled: "boolean",
        disablePast: "boolean",
        disableFuture: "boolean",
        defaultTime: "(string|date|number)",
        defaultDate: "(string|date|number)",
        timepicker: "object",
        datepicker: "object",
        showFormat: "boolean"
    };
    class FC extends ao {
        constructor(t, e) {
            super(t),
            this._input = B.findOne("input", this._element),
            this._options = this._getConfig(e),
            this._timepicker = null,
            this._datepicker = null,
            this._dateValue = this._options.defaultDate ? this._options.defaultDate : "",
            this._timeValue = this._options.defaultTime ? this._options.defaultTime : "",
            this._isInvalidTimeFormat = !1,
            this._format = this._options.datepicker.format ? this._options.datepicker.format : "dd/mm/yyyy",
            this._cancel = !1,
            this._scrollBar = new ce,
            this._init(),
            N.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0),
            At(this.constructor)
        }
        static get NAME() {
            return wC
        }
        get toggleButton() {
            return B.findOne(MC, this._element)
        }
        dispose() {
            I.off(this._element, "click", this._openDatePicker),
            I.off(this._input, "input", this._handleInput),
            I.off(this._element, "click"),
            this._removeTimePicker(),
            this._removeDatepicker();
            this.toggleButton && this.toggleButton.remove(),
            N.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`),
            super.dispose()
        }
        update(t={}) {
            const e = this._getConfig({
                ...this._options,
                ...t
            });
            I.off(this._element, "click", this._openDatePicker),
            I.off(this._input, "input", this._handleInput),
            I.off(this._element, "click"),
            this._removeTimePicker(),
            this._removeDatepicker();
            this.toggleButton && this.toggleButton.remove(),
            this._options = BC,
            this._timepicker = null,
            this._datepicker = null,
            this._dateValue = null,
            this._timeValue = null,
            this._isInvalidTimeFormat = null,
            this._options = e,
            this._init()
        }
        _init() {
            this._addDatepicker(),
            this._addTimePicker(),
            this._appendToggleButton(),
            this._listenToToggleClick(),
            this._listenToUserInput(),
            this._disableInput(),
            this._setInitialDefaultInput(),
            this._applyFormatPlaceholder(),
            this._options.disablePast && this._handleTimepickerDisablePast(),
            this._options.disableFuture && this._handleTimepickerDisableFuture(),
            this._input.value && this._handleInput(this._input.value)
        }
        _removeDatepicker() {
            const t = this._element.querySelector(".datepicker");
            t && t.remove()
        }
        _addDatepicker() {
            const t = _("div");
            t.id = this._element.id ? `datepicker-${this._element.id}` : o("datepicker-");
            t.innerHTML = '<input type="text" class="form-control">',
            N.addClass(t, kC),
            this._element.appendChild(t),
            N.style(t, {
                display: "none"
            });
            let e = {
                ...this._options.datepicker,
                container: this._options.container,
                disablePast: this._options.disablePast,
                disableFuture: this._options.disableFuture
            };
            (this._options.inline || this._options.datepicker.inline) && (e = {
                ...e,
                inline: !0
            }),
            this._datepicker = new Mb(t,e),
            this._datepicker._input.value = this._dateValue
        }
        _removeTimePicker() {
            const t = this._element.querySelector(".timepicker");
            t && (t.remove(),
            this._scrollBar.reset())
        }
        _addTimePicker() {
            const t = _("div");
            t.id = this._element.id ? `timepicker-${this._element.id}` : o("timepicker-");
            t.innerHTML = '<input type="text" class="form-control">',
            N.addClass(t, SC),
            this._element.appendChild(t),
            N.style(t, {
                display: "none"
            });
            let e = {
                ...this._options.timepicker,
                container: this._options.container
            };
            (this._options.inline || this._options.timepicker.inline) && (e = {
                ...e,
                inline: !0
            }),
            this._timepicker = new w_(t,e),
            this._timepicker._input.value = this._timeValue
        }
        _addIconButtons() {
            if (N.addClass(NC, "buttons-container"),
            NC.innerHTML = '\n  <button type="button" class="datepicker-button-toggle"  data-mdb-toggle="datepicker">\n    <i class="far fa-calendar datepicker-toggle-icon"></i>\n  </button>\n  <button type="button" class="timepicker-button-toggle" data-mdb-toggle="timepicker">\n    <i class="far fa-clock fa-sm timepicker-icon"></i>\n  </button>\n',
            !this._options.inline && !this._options.datepicker.inline)
                if (this._scrollBar.hide(),
                this._datepicker._isOpen) {
                    B.findOne(`${AC}-header`, document.body).appendChild(NC)
                } else if (this._timepicker._modal && !this._options.timepicker.inline) {
                    const t = B.findOne(`${TC}-elements`, document.body)
                      , e = B.findOne(`${TC}-clock-wrapper`, document.body);
                    t.insertBefore(NC, e)
                }
        }
        _enableOrDisableToggleButton() {
            this._options.disabled ? (this.toggleButton.disabled = !0,
            this.toggleButton.style.pointerEvents = "none") : (this.toggleButton.disabled = !1,
            this.toggleButton.style.pointerEvents = "pointer")
        }
        _appendToggleButton() {
            this._options.toggleButton && (this._element.insertAdjacentHTML("beforeend", '\n  <button type="button" class="datetimepicker-toggle-button" data-mdb-toggle="datetimepicker">\n    <i class="far fa-calendar datepicker-toggle-icon"></i>\n  </button>\n'),
            this._enableOrDisableToggleButton())
        }
        _applyFormatPlaceholder() {
            this._options.showFormat && (this._input.placeholder = this._format)
        }
        _listenToCancelClick() {
            const t = B.findOne(`${AC}-cancel-btn`, document.body);
            I.one(t, "mousedown", () => {
                this._cancel = !0,
                this._scrollBar.reset(),
                I.off(t, "mousedown")
            }
            )
        }
        _listenToToggleClick() {
            I.on(this._element, "click", EC, t => {
                t.preventDefault(),
                this._openDatePicker()
            }
            )
        }
        _listenToUserInput() {
            I.on(this._input, "input", t => {
                this._handleInput(t.target.value)
            }
            )
        }
        _disableInput() {
            this._options.disabled && (this._input.disabled = "true")
        }
        _getConfig(t) {
            const e = N.getDataAttributes(this._element);
            return t = {
                ...BC,
                ...e,
                ...t
            },
            d(wC, t, HC),
            t
        }
        _handleInput(t) {
            const e = t.split(", ")
              , i = this._format.match(/[^(dmy)]{1,}/g);
            const n = e[0]
              , s = e[1] || ""
              , o = ( (t, e, i, n) => {
                let s;
                s = i[0] !== i[1] ? i[0] + i[1] : i[0];
                const o = new RegExp(`[${s}]`)
                  , a = t.split(o)
                  , r = e.split(o)
                  , l = -1 !== e.indexOf("mmm")
                  , h = [];
                for (let d = 0; d < r.length; d++)
                    -1 !== r[d].indexOf("yy") && (h[0] = {
                        value: a[d],
                        format: r[d]
                    }),
                    -1 !== r[d].indexOf("m") && (h[1] = {
                        value: a[d],
                        format: r[d]
                    }),
                    -1 !== r[d].indexOf("d") && r[d].length <= 2 && (h[2] = {
                        value: a[d],
                        format: r[d]
                    });
                let c;
                return c = -1 !== e.indexOf("mmmm") ? n.monthsFull : n.monthsShort,
                q_(Number(h[0].value), l ? xC(h[1].value, c) : Number(h[1].value) - 1, Number(h[2].value))
            }
            )(n, this._format, i, this._datepicker._options);
            if (2 === e.length) {
                const t = (t => t && "[object Date]" === Object.prototype.toString.call(t) && !isNaN(t))(o) && ((a = s).match(/^(0?[1-9]|1[012])(:[0-5]\d) [APap][mM]$/) || a.match(/^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/));
                t ? (this._dateValue = n,
                this._timeValue = s,
                this._datepicker._input.value = this._dateValue,
                this._datepicker._activeDate = this._dateValue,
                this._datepicker._selectedYear = (t => t.getFullYear())(o),
                this._datepicker._selectedMonth = (t => t.getMonth())(o),
                this._datepicker._headerDate = o,
                this._timepicker._input.value = this._timeValue,
                this._timepicker._isInvalidTimeFormat = !1) : (this._datepicker._activeDate = new Date,
                this._datepicker._selectedDate = null,
                this._datepicker._selectedMonth = null,
                this._datepicker._selectedYear = null,
                this._datepicker._headerDate = null,
                this._datepicker._headerMonth = null,
                this._datepicker._headerYear = null,
                this._timepicker._isInvalidTimeFormat = !0)
            }
            var a
        }
        _openDatePicker() {
            if (I.trigger(this._element, DC).defaultPrevented)
                return;
            this._datepicker.open(),
            this._options.inline || (this._scrollBar.hide(),
            N.addClass(this._datepicker.container, "datetimepicker-datepicker-modal")),
            (this._options.inline || this._options.datepicker.inline) && this._openDropdownDate(),
            this._addIconButtons(),
            this._listenToCancelClick(),
            this._options.inline && this._datepicker._isOpen && (this.toggleButton.style.pointerEvents = "none"),
            I.one(this._datepicker._element, LC, () => {
                this._dateValue = this._datepicker._input.value,
                this._updateInputValue(),
                this._cancel ? this._cancel = !1 : (I.on(this._datepicker.container, "click", t => {
                    !this._datepicker._selectedDate && t.target.classList.contains("datepicker-ok-btn") || this._openTimePicker()
                }
                ),
                setTimeout( () => {
                    B.findOne(`${TC}-wrapper`, document.body) || this._scrollBar.reset()
                }
                , 10),
                this._options.inline && (this.toggleButton.style.pointerEvents = "auto"))
            }
            );
            const t = B.findOne(`${TC}-button-toggle`, document.body);
            I.on(t, "click", () => {
                this._datepicker._confirmSelection(this._datepicker._headerDate),
                this._datepicker.close(),
                this._scrollBar.hide(),
                I.trigger(this._datepicker._element, LC)
            }
            )
        }
        _handleTimepickerDisablePast() {
            const t = new Date;
            t.setHours(0, 0, 0, 0),
            I.on(this._datepicker._element, PC, () => {
                this._datepicker._selectedDate.getTime() === t.getTime() ? this._timepicker.update({
                    disablePast: !0
                }) : this._timepicker.update({
                    disablePast: !1
                })
            }
            )
        }
        _handleTimepickerDisableFuture() {
            const t = new Date;
            t.setHours(0, 0, 0, 0),
            I.on(this._datepicker._element, PC, () => {
                this._datepicker._selectedDate.getTime() === t.getTime() ? this._timepicker.update({
                    disableFuture: !0
                }) : this._timepicker.update({
                    disableFuture: !1
                })
            }
            )
        }
        _openDropdownDate() {
            this._datepicker._popper.state.elements.reference = this._input,
            this._scrollBar.reset()
        }
        _openTimePicker() {
            I.trigger(this._timepicker.toggleButton, "click"),
            setTimeout( () => {
                if (this._addIconButtons(),
                (this._options.inline || this._options.timepicker.inline) && this._openDropdownTime(),
                this._timepicker._modal) {
                    const t = B.findOne(`${TC}-cancel`, document.body);
                    I.on(this._timepicker._modal, "click", e => {
                        (e.target.classList.contains(`${SC}-wrapper`) || e.target.classList.contains(`${SC}-submit`)) && setTimeout( () => {
                            this._scrollBar.reset()
                        }
                        , 200),
                        e.target.classList.contains(`${SC}-clear`) && I.trigger(this._timepicker._element, RC),
                        e.target.classList.contains(`${kC}-button-toggle`) && (I.trigger(t, "click"),
                        setTimeout( () => {
                            this._openDatePicker(),
                            this._scrollBar.hide()
                        }
                        , 200))
                    }
                    )
                }
            }
            ),
            I.one(this._timepicker._element, RC, () => {
                this._timeValue = this._timepicker._input.value,
                this._updateInputValue(),
                I.trigger(this._element, $C)
            }
            )
        }
        _openDropdownTime() {
            const t = this._timepicker._popper;
            t.state.elements.reference = this._input,
            t.update(),
            this._scrollBar.reset()
        }
        _setInitialDefaultInput() {
            (this._options.defaultDate || this._options.defaultTime) && this._updateInputValue()
        }
        _updateInputValue() {
            if (this._timeValue && this._dateValue) {
                this._input.value = `${this._dateValue}, ${this._timeValue}`;
                if (I.trigger(this._element, IC, {
                    value: this._input.value
                }).defaultPrevented)
                    return
            }
            I.trigger(this._input, "focus")
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                let i = s.getData(this, CC);
                const n = "object" == typeof t && t;
                if ((i || !/dispose/.test(t)) && (i || (i = new FC(this,n)),
                "string" == typeof t)) {
                    if (void 0 === i[t])
                        throw new TypeError(`No method named "${t}"`);
                    i[t](e)
                }
            })
        }
    }
    const zC = new Map
      , jC = (t, e) => {
        const i = t;
        zC.has(t.name) || (I.one(document, "mousedown", e, i.autoInitial(new i)),
        zC.set(t.name, !0))
    }
      , WC = new Map
      , VC = {
        alert: {
            name: "Alert",
            selector: "[data-mdb-alert-init]",
            isToggler: !0,
            callback: (t, e) => {
                const i = t;
                zC.has(t.name) || (Qt(i),
                zC.set(t.name, !0)),
                B.find(e).forEach(t => i.getOrCreateInstance(t))
            }
        },
        button: {
            name: "Button",
            selector: "[data-mdb-button-init]",
            isToggler: !0,
            callback: (t, e) => {
                const i = t
                  , n = `click.bs.${t.name}.data-api`;
                zC.has(t.name) || (I.on(document, n, e, t => {
                    t.preventDefault();
                    const n = t.target.closest(e);
                    i.getOrCreateInstance(n).toggle()
                }
                ),
                zC.set(t.name, !0)),
                B.find(e).forEach(t => i.getOrCreateInstance(t))
            }
        },
        carousel: {
            name: "Carousel",
            selector: "[data-mdb-carousel-init]",
            isToggler: !0,
            callback: (t, e) => {
                if (zC.has(t.name))
                    return;
                const i = `click.bs.${t.name}.data-api`
                  , n = t
                  , s = `load.bs.${t.name}.data-api`
                  , o = e;
                I.on(document, i, "[data-mdb-slide], [data-mdb-slide-to]", function(t) {
                    const e = l(this);
                    if (!e || !e.classList.contains("carousel"))
                        return;
                    t.preventDefault();
                    const i = n.getOrCreateInstance(e)
                      , s = this.getAttribute("data-mdb-slide-to");
                    return s ? (i.to(s),
                    void i._maybeEnableCycle()) : "next" === N.getDataAttribute(this, "slide") ? (i.next(),
                    void i._maybeEnableCycle()) : (i.prev(),
                    void i._maybeEnableCycle())
                }),
                I.on(window, s, () => {
                    B.find(o).forEach(t => {
                        n.getOrCreateInstance(t)
                    }
                    )
                }
                ),
                zC.set(t.name, !0)
            }
        },
        collapse: {
            name: "Collapse",
            selector: "[data-mdb-collapse-init]",
            isToggler: !0,
            callback: (t, e) => {
                const i = `click.bs.${t.name}.data-api`
                  , n = e
                  , s = t;
                zC.has(t.name) || (I.on(document, i, n, function(t) {
                    ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault();
                    const e = r(this);
                    B.find(e).forEach(t => {
                        s.getOrCreateInstance(t, {
                            toggle: !1
                        }).toggle()
                    }
                    )
                }),
                zC.set(t.name, !0)),
                B.find(n).forEach(t => {
                    const e = r(t);
                    B.find(e).forEach(t => {
                        s.getOrCreateInstance(t, {
                            toggle: !1
                        })
                    }
                    )
                }
                )
            }
        },
        dropdown: {
            name: "Dropdown",
            selector: "[data-mdb-dropdown-init]",
            isToggler: !0,
            callback: (t, e) => {
                const i = `click.bs.${t.name}.data-api`
                  , n = `keydown.bs.${t.name}.data-api`
                  , s = `keyup.bs.${t.name}.data-api`
                  , o = `[data-mdb-${t.NAME}-initialized]`
                  , a = t;
                zC.has(t.name) || (I.on(document, n, o, a.dataApiKeydownHandler),
                I.on(document, n, ".dropdown-menu", a.dataApiKeydownHandler),
                I.on(document, i, a.clearMenus),
                I.on(document, s, a.clearMenus),
                I.on(document, i, o, function(t) {
                    t.preventDefault(),
                    a.getOrCreateInstance(this).toggle()
                })),
                zC.set(t.name, !0),
                B.find(e).forEach(t => {
                    a.getOrCreateInstance(t)
                }
                )
            }
        },
        modal: {
            name: "Modal",
            selector: "[data-mdb-modal-init]",
            isToggler: !0,
            callback: (t, e) => {
                const i = `click.bs.${t.name}.data-api`
                  , n = t
                  , s = `show.bs.${t.name}`
                  , o = `hidden.bs.${t.name}`;
                zC.has(t.name) || (I.on(document, i, e, function(t) {
                    const e = l(this);
                    ["A", "AREA"].includes(this.tagName) && t.preventDefault(),
                    I.one(e, s, t => {
                        t.defaultPrevented || I.one(e, o, () => {
                            u(this) && this.focus()
                        }
                        )
                    }
                    );
                    B.find(".modal.show").forEach(t => {
                        t.classList.contains("modal-non-invasive-show") || n.getInstance(t).hide()
                    }
                    );
                    n.getOrCreateInstance(e).toggle(this)
                }),
                Qt(n),
                zC.set(t.name, !0)),
                B.find(e).forEach(t => {
                    const e = r(t)
                      , i = B.findOne(e);
                    n.getOrCreateInstance(i)
                }
                )
            }
        },
        offcanvas: {
            name: "Offcanvas",
            selector: "[data-mdb-offcanvas-init]",
            isToggler: !0,
            callback: (t, e) => {
                if (zC.has(t.name))
                    return;
                const i = `click.bs.${t.name}.data-api`
                  , n = ".offcanvas.show"
                  , s = t
                  , o = `hidden.bs.${t.name}`
                  , a = `load.bs.${t.name}.data-api`
                  , r = `resize.bs.${t.name}`;
                I.on(document, i, e, function(t) {
                    const e = l(this);
                    if (["A", "AREA"].includes(this.tagName) && t.preventDefault(),
                    p(this))
                        return;
                    I.one(e, o, () => {
                        u(this) && this.focus()
                    }
                    );
                    const i = B.findOne(n);
                    i && i !== e && s.getInstance(i).hide();
                    s.getOrCreateInstance(e).toggle(this)
                }),
                I.on(window, a, () => {
                    B.find(n).forEach(t => {
                        s.getOrCreateInstance(t).show()
                    }
                    )
                }
                ),
                I.on(window, r, () => {
                    B.find("[aria-modal][class*=show][class*=offcanvas-]").forEach(t => {
                        "fixed" !== getComputedStyle(t).position && s.getOrCreateInstance(t).hide()
                    }
                    )
                }
                ),
                Qt(s),
                zC.set(t.name, !0)
            }
        },
        scrollspy: {
            name: "ScrollSpy",
            selector: "[data-mdb-scrollspy-init]",
            isToggler: !0,
            callback: (t, e) => {
                if (zC.has(t.name))
                    return;
                const i = `load.bs.${t.name}.data-api`
                  , n = t;
                I.on(window, i, () => {
                    B.find(e).forEach(t => {
                        n.getOrCreateInstance(t)
                    }
                    )
                }
                ),
                zC.set(t.name, !0)
            }
        },
        tab: {
            name: "Tab",
            selector: "[data-mdb-tab-init], [data-mdb-pill-init], [data-mdb-list-init]",
            isToggler: !0,
            callback: (t, e) => {
                const i = `load.bs.${t.name}.data-api`
                  , n = `click.bs.${t.name}.data-api`
                  , s = "active"
                  , o = `.${s}[data-mdb-tab-init], .${s}[data-mdb-pill-init], .${s}[data-mdb-toggle="list"]`
                  , a = t;
                zC.has(t.name) || (I.on(document, n, e, function(t) {
                    ["A", "AREA"].includes(this.tagName) && t.preventDefault(),
                    p(this) || a.getOrCreateInstance(this).show()
                }),
                I.on(window, i, () => {
                    B.find(o).forEach(t => {
                        a.getOrCreateInstance(t)
                    }
                    )
                }
                ),
                zC.set(t.name, !0))
            }
        },
        toast: {
            name: "Toast",
            selector: "[data-mdb-toast-init]",
            isToggler: !0,
            callback: (t, e) => {
                const i = t;
                zC.has(t.name) || (Qt(i),
                zC.set(t.name, !0)),
                B.find(e).forEach(t => i.getOrCreateInstance(t))
            }
        },
        tooltip: {
            name: "Tooltip",
            selector: "[data-mdb-tooltip-init]",
            isToggler: !1
        },
        input: {
            name: "Input",
            selector: "[data-mdb-input-init]",
            isToggler: !0,
            callback: (t, e) => {
                const i = e
                  , n = `${i} input`
                  , s = `${i} textarea`
                  , o = t;
                zC.has(t.name) || (I.on(document, "focus", n, o.activate(new o)),
                I.on(document, "input", n, o.activate(new o)),
                I.on(document, "blur", n, o.deactivate(new o)),
                I.on(document, "focus", s, o.activate(new o)),
                I.on(document, "input", s, o.activate(new o)),
                I.on(document, "blur", s, o.deactivate(new o)),
                I.on(window, "shown.bs.modal", t => {
                    B.find(n, t.target).forEach(t => {
                        const e = o.getInstance(t.parentNode);
                        e && e.update()
                    }
                    ),
                    B.find(s, t.target).forEach(t => {
                        const e = o.getInstance(t.parentNode);
                        e && e.update()
                    }
                    )
                }
                ),
                I.on(window, "shown.bs.dropdown", t => {
                    const e = t.target.parentNode.querySelector(".dropdown-menu");
                    e && (B.find(n, e).forEach(t => {
                        const e = o.getInstance(t.parentNode);
                        e && e.update()
                    }
                    ),
                    B.find(s, e).forEach(t => {
                        const e = o.getInstance(t.parentNode);
                        e && e.update()
                    }
                    ))
                }
                ),
                I.on(window, "shown.bs.tab", t => {
                    let e;
                    e = t.target.href ? t.target.href.split("#")[1] : N.getDataAttribute(t.target, "target").split("#")[1];
                    const i = B.findOne(`#${e}`);
                    B.find(n, i).forEach(t => {
                        const e = o.getInstance(t.parentNode);
                        e && e.update()
                    }
                    ),
                    B.find(s, i).forEach(t => {
                        const e = o.getInstance(t.parentNode);
                        e && e.update()
                    }
                    )
                }
                ),
                I.on(window, "reset", t => {
                    B.find(n, t.target).forEach(t => {
                        const e = o.getInstance(t.parentNode);
                        e && e.forceInactive()
                    }
                    ),
                    B.find(s, t.target).forEach(t => {
                        const e = o.getInstance(t.parentNode);
                        e && e.forceInactive()
                    }
                    )
                }
                ),
                I.on(window, "onautocomplete", t => {
                    const e = o.getInstance(t.target.parentNode);
                    e && t.cancelable && e.forceActive()
                }
                ),
                zC.set(t.name, !0)),
                B.find(i).map(t => o.getOrCreateInstance(t))
            }
        },
        range: {
            name: "Range",
            selector: "[data-mdb-range-init]",
            isToggler: !1
        },
        ripple: {
            name: "Ripple",
            selector: "[data-mdb-ripple-init]",
            isToggler: !0,
            callback: jC
        },
        popover: {
            name: "Popover",
            selector: "[data-mdb-popover-init]",
            isToggler: !1,
            callback: jC
        }
    }
      , YC = {
        ...VC,
        chart: {
            name: "Chart",
            selector: "[data-mdb-chart-init]",
            isToggler: !1,
            advanced: (t, e) => {
                const i = t => {
                    const e = {};
                    return Object.keys(t).forEach(i => {
                        if (i.match(/dataset.*/)) {
                            const n = i.slice(7, 8).toLowerCase().concat(i.slice(8));
                            e[n] = (t => "string" != typeof t ? t : (t => "{" === t[0] && "}" === t[t.length - 1] || "[" === t[0] && "]" === t[t.length - 1])(t) ? JSON.parse(t.replace(/'/g, '"')) : t)(t[i])
                        }
                    }
                    ),
                    e
                }
                ;
                B.find(e).forEach(e => {
                    if (!t.getInstance(e) && "bubble" !== N.getDataAttribute(e, "chart") && "scatter" !== N.getDataAttribute(e, "chart")) {
                        const n = N.getDataAttributes(e)
                          , s = {
                            data: {
                                datasets: [i(n)]
                            }
                        };
                        return n.chart && (s.type = n.chart),
                        n.labels && (s.data.labels = JSON.parse(n.labels.replace(/'/g, '"'))),
                        new t(e,{
                            ...s,
                            ...Qp[s.type]
                        })
                    }
                    return null
                }
                )
            }
        },
        chips: {
            name: "ChipsInput",
            selector: "[data-mdb-chips-input-init]",
            isToggler: !1
        },
        chip: {
            name: "Chip",
            selector: "[data-mdb-chip-init]",
            isToggler: !1,
            onInit: "init"
        },
        datatable: {
            name: "Datatable",
            selector: "[data-mdb-datatable-init]",
            isToggler: !1
        },
        select: {
            name: "Select",
            selector: "[data-mdb-select-init]",
            isToggler: !1
        },
        datetimepicker: {
            name: "Datetimepicker",
            selector: "[data-mdb-datetimepicker-init]",
            isToggler: !1
        },
        datepicker: {
            name: "Datepicker",
            selector: "[data-mdb-datepicker-init]",
            isToggler: !1
        },
        loading: {
            name: "Loading",
            selector: "[data-mdb-loading-init]",
            isToggler: !1
        },
        multiRangeSlider: {
            name: "MultiRangeSlider",
            selector: "[data-mdb-multi-range-slider-init]",
            isToggler: !1
        },
        timepicker: {
            name: "Timepicker",
            selector: "[data-mdb-timepicker-init]",
            isToggler: !1
        },
        touch: {
            name: "Touch",
            selector: "[data-mdb-touch-init]",
            isToggler: !1
        },
        alert: {
            name: "Alert",
            selector: "[data-mdb-alert-init]",
            isToggler: !0,
            callback: (t, e) => {
                const i = t;
                WC.has(t.name) || (Qt(i),
                WC.set(t.name, !0)),
                B.find(e).forEach(t => i.getOrCreateInstance(t))
            }
        },
        animation: {
            name: "Animate",
            selector: "[data-mdb-animation-init]",
            isToggler: !1,
            onInit: "init"
        },
        clipboard: {
            name: "Clipboard",
            selector: "[data-mdb-clipboard-init]",
            isToggler: !1
        },
        infiniteScroll: {
            name: "InfiniteScroll",
            selector: "[data-mdb-infinite-scroll-init]",
            isToggler: !1
        },
        lazyLoad: {
            name: "LazyLoad",
            selector: "[data-mdb-lazy-load-init]",
            isToggler: !1
        },
        lightbox: {
            name: "Lightbox",
            selector: "[data-mdb-lightbox-init]",
            isToggler: !0,
            callback: (t, e) => {
                const i = `click.mdb.${t.name}.data-api`
                  , n = `${`[data-mdb-${t.NAME}-initialized]`} img:not(.lightbox-disabled)`
                  , s = t;
                B.find(e).forEach(t => s.getOrCreateInstance(t)),
                WC.has(t.name) || (I.on(document, i, n, t => {
                    t.preventDefault(),
                    s.toggle(t)
                }
                ),
                WC.set(t.name, !0))
            }
        },
        modal: {
            name: "Modal",
            selector: "[data-mdb-modal-init]",
            isToggler: !0,
            callback: (t, e) => {
                const i = `click.bs.${t.name}.data-api`
                  , n = t
                  , s = `show.bs.${t.name}`
                  , o = `hidden.bs.${t.name}`;
                WC.has(t.name) || (I.on(document, i, e, function(t) {
                    const e = l(this);
                    ["A", "AREA"].includes(this.tagName) && t.preventDefault(),
                    I.one(e, s, t => {
                        t.defaultPrevented || I.one(e, o, () => {
                            u(this) && this.focus()
                        }
                        )
                    }
                    );
                    B.find(".modal.show").forEach(t => {
                        t.classList.contains("modal-non-invasive-show") || n.getInstance(t).hide()
                    }
                    );
                    n.getOrCreateInstance(e).toggle(this)
                }),
                Qt(n),
                WC.set(t.name, !0)),
                B.find(e).forEach(t => {
                    const e = r(t)
                      , i = B.findOne(e);
                    n.getOrCreateInstance(i)
                }
                )
            }
        },
        navbar: {
            name: "Navbar",
            selector: "[data-mdb-navbar-init]",
            isToggler: !1,
            onInit: "init"
        },
        perfectScrollbar: {
            name: "PerfectScrollbar",
            selector: "[data-mdb-perfect-scrollbar-init]",
            isToggler: !1
        },
        popconfirm: {
            name: "Popconfirm",
            selector: "[data-mdb-popconfirm-init]",
            isToggler: !1
        },
        rating: {
            name: "Rating",
            selector: "[data-mdb-rating-init]",
            isToggler: !1
        },
        sidenav: {
            name: "Sidenav",
            selector: "[data-mdb-sidenav-init]",
            isToggler: !0,
            callback: (t, e) => {
                const i = e
                  , n = t;
                WC.has(t.name) || (I.on(document, "click", '[data-mdb-toggle="sidenav"]', n.toggleSidenav()),
                WC.set(t.name, !0)),
                B.find(i).forEach(t => n.getOrCreateInstance(t))
            }
        },
        smoothScroll: {
            name: "SmoothScroll",
            selector: "[data-mdb-smooth-scroll-init]",
            isToggler: !1
        },
        stepper: {
            name: "Stepper",
            selector: "[data-mdb-stepper-init]",
            isToggler: !1
        },
        sticky: {
            name: "Sticky",
            selector: "[data-mdb-sticky-init]",
            isToggler: !1
        },
        toast: {
            name: "Toast",
            selector: "[data-mdb-toast-init]",
            isToggler: !0,
            callback: (t, e) => {
                const i = e
                  , n = t;
                WC.has(t.name) || (Qt(n),
                WC.set(t.name, !0)),
                B.find(i).forEach(t => n.getOrCreateInstance(t))
            }
        }
    }
      , XC = new class {
        constructor(t) {
            i(this, "init", t => {
                t.forEach(t => Et(t))
            }
            ),
            i(this, "initMDB", (t, e=!1) => {
                const i = Object.keys(Mt).map(i => {
                    if (Boolean(document.querySelector(Mt[i].selector))) {
                        const n = t[Mt[i].name];
                        return n || Tt.get(i) || !e || console.warn(`Please import ${Mt[i].name} from "MDB" package and add it to a object parameter inside "initMDB" function`),
                        n
                    }
                    return null
                }
                );
                this.init(i)
            }
            ),
            Mt = t
        }
    }
    (YC).initMDB;
    XC({
        Button: Wt,
        Carousel: ii,
        Collapse: Do,
        Offcanvas: Ce,
        Dropdown: fa,
        Input: go,
        Modal: $w,
        Popover: hs,
        ScrollSpy: Ts,
        Ripple: Sa,
        Tab: io,
        Tooltip: oo,
        Range: Ma,
        Alert: zg,
        Animate: Ia,
        Chart: of,
        Datepicker: Mb,
        Datatable: Vv,
        Lightbox: pf,
        Navbar: C_,
        Popconfirm: Nb,
        Rating: Tf,
        Sidenav: Cg,
        SmoothScroll: xx,
        Timepicker: w_,
        Toast: hm,
        InfiniteScroll: M_,
        LazyLoad: H_,
        Stepper: Dy,
        Sticky: Fy,
        Select: vv,
        Touch: ux,
        PerfectScrollbar: Ex,
        Loading: Ix,
        Autocomplete: iw,
        Clipboard: Bw,
        ChipsInput: aC,
        Chip: Vw,
        MultiRangeSlider: yC,
        Datetimepicker: FC
    });
    const KC = Object.freeze(Object.defineProperty({
        __proto__: null,
        Alert: zg,
        Animate: Ia,
        Autocomplete: iw,
        Button: Wt,
        Carousel: ii,
        Chart: of,
        Chip: Vw,
        ChipsInput: aC,
        Clipboard: Bw,
        Collapse: Do,
        Datatable: Vv,
        Datepicker: Mb,
        Datetimepicker: FC,
        Dropdown: fa,
        InfiniteScroll: M_,
        Input: go,
        LazyLoad: H_,
        Lightbox: pf,
        Loading: Ix,
        Modal: $w,
        MultiRangeSlider: yC,
        Navbar: C_,
        Offcanvas: Ce,
        PerfectScrollbar: Ex,
        Popconfirm: Nb,
        Popover: hs,
        Range: Ma,
        Rating: Tf,
        Ripple: Sa,
        ScrollSpy: Ts,
        Select: vv,
        Sidenav: Cg,
        SmoothScroll: xx,
        Stepper: Dy,
        Sticky: Fy,
        Tab: io,
        Timepicker: w_,
        Toast: hm,
        Tooltip: oo,
        Touch: ux,
        initMDB: XC
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , {initMDB: UC} = KC
      , qC = {
        ...KC
    };
    return UC(qC),
    qC
});